var __extends = (this && this.__extends) || (function () { var a = function (e, c) { a = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array && function (g, f) { g.__proto__ = f }) || function (h, f) { for (var g in f) { if (f.hasOwnProperty(g)) { h[g] = f[g] } } }; return a(e, c) }; return function (f, c) { a(f, c); function e() { this.constructor = f } f.prototype = c === null ? Object.create(c) : (e.prototype = c.prototype, new e()) } })(); var spine; (function (a) { var s = (function () { function w(x, z, A) { if (x == null) { throw new Error("name cannot be null.") } if (z == null) { throw new Error("timelines cannot be null.") } this.name = x; this.timelines = z; this.timelineIds = []; for (var y = 0; y < z.length; y++) { this.timelineIds[z[y].getPropertyId()] = true } this.duration = A } w.prototype.hasTimeline = function (x) { return this.timelineIds[x] == true }; w.prototype.apply = function (A, x, z, D, H, B, F, G) { if (A == null) { throw new Error("skeleton cannot be null.") } if (D && this.duration != 0) { z %= this.duration; if (x > 0) { x %= this.duration } } var E = this.timelines; for (var C = 0, y = E.length; C < y; C++) { E[C].apply(A, x, z, H, B, F, G) } }; w.binarySearch = function (y, C, z) { if (z === void 0) { z = 1 } var x = 0; var A = y.length / z - 2; if (A == 0) { return z } var B = A >>> 1; while (true) { if (y[(B + 1) * z] <= C) { x = B + 1 } else { A = B } if (x == A) { return (x + 1) * z } B = (x + A) >>> 1 } }; w.linearSearch = function (x, B, A) { for (var y = 0, z = x.length - A; y <= z; y += A) { if (x[y] > B) { return y } } return -1 }; return w }()); a.Animation = s; var t; (function (w) { w[w.setup = 0] = "setup"; w[w.first = 1] = "first"; w[w.replace = 2] = "replace"; w[w.add = 3] = "add" })(t = a.MixBlend || (a.MixBlend = {})); var l; (function (w) { w[w.mixIn = 0] = "mixIn"; w[w.mixOut = 1] = "mixOut" })(l = a.MixDirection || (a.MixDirection = {})); var g; (function (w) { w[w.rotate = 0] = "rotate"; w[w.translate = 1] = "translate"; w[w.scale = 2] = "scale"; w[w.shear = 3] = "shear"; w[w.attachment = 4] = "attachment"; w[w.color = 5] = "color"; w[w.deform = 6] = "deform"; w[w.event = 7] = "event"; w[w.drawOrder = 8] = "drawOrder"; w[w.ikConstraint = 9] = "ikConstraint"; w[w.transformConstraint = 10] = "transformConstraint"; w[w.pathConstraintPosition = 11] = "pathConstraintPosition"; w[w.pathConstraintSpacing = 12] = "pathConstraintSpacing"; w[w.pathConstraintMix = 13] = "pathConstraintMix"; w[w.twoColor = 14] = "twoColor" })(g = a.TimelineType || (a.TimelineType = {})); var u = (function () { function w(x) { if (x <= 0) { throw new Error("frameCount must be > 0: " + x) } this.curves = a.Utils.newFloatArray((x - 1) * w.BEZIER_SIZE) } w.prototype.getFrameCount = function () { return this.curves.length / w.BEZIER_SIZE + 1 }; w.prototype.setLinear = function (x) { this.curves[x * w.BEZIER_SIZE] = w.LINEAR }; w.prototype.setStepped = function (x) { this.curves[x * w.BEZIER_SIZE] = w.STEPPED }; w.prototype.getCurveType = function (z) { var x = z * w.BEZIER_SIZE; if (x == this.curves.length) { return w.LINEAR } var y = this.curves[x]; if (y == w.LINEAR) { return w.LINEAR } if (y == w.STEPPED) { return w.STEPPED } return w.BEZIER }; w.prototype.setCurve = function (F, M, Q, L, P) { var C = (-M * 2 + L) * 0.03, B = (-Q * 2 + P) * 0.03; var A = ((M - L) * 3 + 1) * 0.006, z = ((Q - P) * 3 + 1) * 0.006; var E = C * 2 + A, D = B * 2 + z; var K = M * 0.3 + C + A * 0.16666667, I = Q * 0.3 + B + z * 0.16666667; var O = F * w.BEZIER_SIZE; var J = this.curves; J[O++] = w.BEZIER; var H = K, G = I; for (var N = O + w.BEZIER_SIZE - 1; O < N; O += 2) { J[O] = H; J[O + 1] = G; K += E; I += D; E += A; D += z; H += K; G += I } }; w.prototype.getCurvePercent = function (A, F) { F = a.MathUtils.clamp(F, 0, 1); var J = this.curves; var C = A * w.BEZIER_SIZE; var G = J[C]; if (G == w.LINEAR) { return F } if (G == w.STEPPED) { return 0 } C++; var I = 0; for (var z = C, B = C + w.BEZIER_SIZE - 1; C < B; C += 2) { I = J[C]; if (I >= F) { var E = void 0, D = void 0; if (C == z) { E = 0; D = 0 } else { E = J[C - 2]; D = J[C - 1] } return D + (J[C + 1] - D) * (F - E) / (I - E) } } var H = J[C - 1]; return H + (1 - H) * (F - I) / (1 - I) }; w.LINEAR = 0; w.STEPPED = 1; w.BEZIER = 2; w.BEZIER_SIZE = 10 * 2 - 1; return w }()); a.CurveTimeline = u; var q = (function (x) { __extends(w, x); function w(y) { var z = x.call(this, y) || this; z.frames = a.Utils.newFloatArray(y << 1); return z } w.prototype.getPropertyId = function () { return (g.rotate << 24) + this.boneIndex }; w.prototype.setFrame = function (A, y, z) { A <<= 1; this.frames[A] = y; this.frames[A + w.ROTATION] = z }; w.prototype.apply = function (C, z, B, N, D, K, L) { var J = this.frames; var M = C.bones[this.boneIndex]; if (!M.active) { return } if (B < J[0]) { switch (K) { case t.setup: M.rotation = M.data.rotation; return; case t.first: var I = M.data.rotation - M.rotation; M.rotation += (I - (16384 - ((16384.499999999996 - I / 360) | 0)) * 360) * D }return } if (B >= J[J.length - w.ENTRIES]) { var E = J[J.length + w.PREV_ROTATION]; switch (K) { case t.setup: M.rotation = M.data.rotation + E * D; break; case t.first: case t.replace: E += M.data.rotation - M.rotation; E -= (16384 - ((16384.499999999996 - E / 360) | 0)) * 360; case t.add: M.rotation += E * D }return } var A = s.binarySearch(J, B, w.ENTRIES); var H = J[A + w.PREV_ROTATION]; var G = J[A]; var F = this.getCurvePercent((A >> 1) - 1, 1 - (B - G) / (J[A + w.PREV_TIME] - G)); var y = J[A + w.ROTATION] - H; y = H + (y - (16384 - ((16384.499999999996 - y / 360) | 0)) * 360) * F; switch (K) { case t.setup: M.rotation = M.data.rotation + (y - (16384 - ((16384.499999999996 - y / 360) | 0)) * 360) * D; break; case t.first: case t.replace: y += M.data.rotation - M.rotation; case t.add: M.rotation += (y - (16384 - ((16384.499999999996 - y / 360) | 0)) * 360) * D } }; w.ENTRIES = 2; w.PREV_TIME = -2; w.PREV_ROTATION = -1; w.ROTATION = 1; return w }(u)); a.RotateTimeline = q; var r = (function (x) { __extends(w, x); function w(y) { var z = x.call(this, y) || this; z.frames = a.Utils.newFloatArray(y * w.ENTRIES); return z } w.prototype.getPropertyId = function () { return (g.translate << 24) + this.boneIndex }; w.prototype.setFrame = function (C, A, z, B) { C *= w.ENTRIES; this.frames[C] = A; this.frames[C + w.X] = z; this.frames[C + w.Y] = B }; w.prototype.apply = function (C, z, B, M, D, H, K) { var G = this.frames; var L = C.bones[this.boneIndex]; if (!L.active) { return } if (B < G[0]) { switch (H) { case t.setup: L.x = L.data.x; L.y = L.data.y; return; case t.first: L.x += (L.data.x - L.x) * D; L.y += (L.data.y - L.y) * D }return } var J = 0, I = 0; if (B >= G[G.length - w.ENTRIES]) { J = G[G.length + w.PREV_X]; I = G[G.length + w.PREV_Y] } else { var A = s.binarySearch(G, B, w.ENTRIES); J = G[A + w.PREV_X]; I = G[A + w.PREV_Y]; var F = G[A]; var E = this.getCurvePercent(A / w.ENTRIES - 1, 1 - (B - F) / (G[A + w.PREV_TIME] - F)); J += (G[A + w.X] - J) * E; I += (G[A + w.Y] - I) * E } switch (H) { case t.setup: L.x = L.data.x + J * D; L.y = L.data.y + I * D; break; case t.first: case t.replace: L.x += (L.data.x + J - L.x) * D; L.y += (L.data.y + I - L.y) * D; break; case t.add: L.x += J * D; L.y += I * D } }; w.ENTRIES = 3; w.PREV_TIME = -3; w.PREV_X = -2; w.PREV_Y = -1; w.X = 1; w.Y = 2; return w }(u)); a.TranslateTimeline = r; var b = (function (x) { __extends(w, x); function w(y) { return x.call(this, y) || this } w.prototype.getPropertyId = function () { return (g.scale << 24) + this.boneIndex }; w.prototype.apply = function (C, z, B, O, D, I, M) { var H = this.frames; var N = C.bones[this.boneIndex]; if (!N.active) { return } if (B < H[0]) { switch (I) { case t.setup: N.scaleX = N.data.scaleX; N.scaleY = N.data.scaleY; return; case t.first: N.scaleX += (N.data.scaleX - N.scaleX) * D; N.scaleY += (N.data.scaleY - N.scaleY) * D }return } var L = 0, K = 0; if (B >= H[H.length - w.ENTRIES]) { L = H[H.length + w.PREV_X] * N.data.scaleX; K = H[H.length + w.PREV_Y] * N.data.scaleY } else { var A = s.binarySearch(H, B, w.ENTRIES); L = H[A + w.PREV_X]; K = H[A + w.PREV_Y]; var F = H[A]; var E = this.getCurvePercent(A / w.ENTRIES - 1, 1 - (B - F) / (H[A + w.PREV_TIME] - F)); L = (L + (H[A + w.X] - L) * E) * N.data.scaleX; K = (K + (H[A + w.Y] - K) * E) * N.data.scaleY } if (D == 1) { if (I == t.add) { N.scaleX += L - N.data.scaleX; N.scaleY += K - N.data.scaleY } else { N.scaleX = L; N.scaleY = K } } else { var J = 0, G = 0; if (M == l.mixOut) { switch (I) { case t.setup: J = N.data.scaleX; G = N.data.scaleY; N.scaleX = J + (Math.abs(L) * a.MathUtils.signum(J) - J) * D; N.scaleY = G + (Math.abs(K) * a.MathUtils.signum(G) - G) * D; break; case t.first: case t.replace: J = N.scaleX; G = N.scaleY; N.scaleX = J + (Math.abs(L) * a.MathUtils.signum(J) - J) * D; N.scaleY = G + (Math.abs(K) * a.MathUtils.signum(G) - G) * D; break; case t.add: J = N.scaleX; G = N.scaleY; N.scaleX = J + (Math.abs(L) * a.MathUtils.signum(J) - N.data.scaleX) * D; N.scaleY = G + (Math.abs(K) * a.MathUtils.signum(G) - N.data.scaleY) * D } } else { switch (I) { case t.setup: J = Math.abs(N.data.scaleX) * a.MathUtils.signum(L); G = Math.abs(N.data.scaleY) * a.MathUtils.signum(K); N.scaleX = J + (L - J) * D; N.scaleY = G + (K - G) * D; break; case t.first: case t.replace: J = Math.abs(N.scaleX) * a.MathUtils.signum(L); G = Math.abs(N.scaleY) * a.MathUtils.signum(K); N.scaleX = J + (L - J) * D; N.scaleY = G + (K - G) * D; break; case t.add: J = a.MathUtils.signum(L); G = a.MathUtils.signum(K); N.scaleX = Math.abs(N.scaleX) * J + (L - Math.abs(N.data.scaleX) * J) * D; N.scaleY = Math.abs(N.scaleY) * G + (K - Math.abs(N.data.scaleY) * G) * D } } } }; return w }(r)); a.ScaleTimeline = b; var i = (function (w) { __extends(x, w); function x(y) { return w.call(this, y) || this } x.prototype.getPropertyId = function () { return (g.shear << 24) + this.boneIndex }; x.prototype.apply = function (C, z, B, M, D, H, K) { var G = this.frames; var L = C.bones[this.boneIndex]; if (!L.active) { return } if (B < G[0]) { switch (H) { case t.setup: L.shearX = L.data.shearX; L.shearY = L.data.shearY; return; case t.first: L.shearX += (L.data.shearX - L.shearX) * D; L.shearY += (L.data.shearY - L.shearY) * D }return } var J = 0, I = 0; if (B >= G[G.length - x.ENTRIES]) { J = G[G.length + x.PREV_X]; I = G[G.length + x.PREV_Y] } else { var A = s.binarySearch(G, B, x.ENTRIES); J = G[A + x.PREV_X]; I = G[A + x.PREV_Y]; var F = G[A]; var E = this.getCurvePercent(A / x.ENTRIES - 1, 1 - (B - F) / (G[A + x.PREV_TIME] - F)); J = J + (G[A + x.X] - J) * E; I = I + (G[A + x.Y] - I) * E } switch (H) { case t.setup: L.shearX = L.data.shearX + J * D; L.shearY = L.data.shearY + I * D; break; case t.first: case t.replace: L.shearX += (L.data.shearX + J - L.shearX) * D; L.shearY += (L.data.shearY + I - L.shearY) * D; break; case t.add: L.shearX += J * D; L.shearY += I * D } }; return x }(r)); a.ShearTimeline = i; var d = (function (x) { __extends(w, x); function w(y) { var z = x.call(this, y) || this; z.frames = a.Utils.newFloatArray(y * w.ENTRIES); return z } w.prototype.getPropertyId = function () { return (g.color << 24) + this.slotIndex }; w.prototype.setFrame = function (D, C, B, A, y, z) { D *= w.ENTRIES; this.frames[D] = C; this.frames[D + w.R] = B; this.frames[D + w.G] = A; this.frames[D + w.B] = y; this.frames[D + w.A] = z }; w.prototype.apply = function (B, P, D, z, C, K, N) { var A = B.slots[this.slotIndex]; if (!A.bone.active) { return } var F = this.frames; if (D < F[0]) { switch (K) { case t.setup: A.color.setFromColor(A.data.color); return; case t.first: var J = A.color, I = A.data.color; J.add((I.r - J.r) * C, (I.g - J.g) * C, (I.b - J.b) * C, (I.a - J.a) * C) }return } var H = 0, M = 0, O = 0, Q = 0; if (D >= F[F.length - w.ENTRIES]) { var L = F.length; H = F[L + w.PREV_R]; M = F[L + w.PREV_G]; O = F[L + w.PREV_B]; Q = F[L + w.PREV_A] } else { var G = s.binarySearch(F, D, w.ENTRIES); H = F[G + w.PREV_R]; M = F[G + w.PREV_G]; O = F[G + w.PREV_B]; Q = F[G + w.PREV_A]; var E = F[G]; var y = this.getCurvePercent(G / w.ENTRIES - 1, 1 - (D - E) / (F[G + w.PREV_TIME] - E)); H += (F[G + w.R] - H) * y; M += (F[G + w.G] - M) * y; O += (F[G + w.B] - O) * y; Q += (F[G + w.A] - Q) * y } if (C == 1) { A.color.set(H, M, O, Q) } else { var J = A.color; if (K == t.setup) { J.setFromColor(A.data.color) } J.add((H - J.r) * C, (M - J.g) * C, (O - J.b) * C, (Q - J.a) * C) } }; w.ENTRIES = 5; w.PREV_TIME = -5; w.PREV_R = -4; w.PREV_G = -3; w.PREV_B = -2; w.PREV_A = -1; w.R = 1; w.G = 2; w.B = 3; w.A = 4; return w }(u)); a.ColorTimeline = d; var v = (function (x) { __extends(w, x); function w(y) { var z = x.call(this, y) || this; z.frames = a.Utils.newFloatArray(y * w.ENTRIES); return z } w.prototype.getPropertyId = function () { return (g.twoColor << 24) + this.slotIndex }; w.prototype.setFrame = function (z, B, y, C, E, F, A, G, D) { z *= w.ENTRIES; this.frames[z] = B; this.frames[z + w.R] = y; this.frames[z + w.G] = C; this.frames[z + w.B] = E; this.frames[z + w.A] = F; this.frames[z + w.R2] = A; this.frames[z + w.G2] = G; this.frames[z + w.B2] = D }; w.prototype.apply = function (D, T, H, z, F, O, R) { var B = D.slots[this.slotIndex]; if (!B.bone.active) { return } var J = this.frames; if (H < J[0]) { switch (O) { case t.setup: B.color.setFromColor(B.data.color); B.darkColor.setFromColor(B.data.darkColor); return; case t.first: var C = B.color, A = B.darkColor, E = B.data.color, L = B.data.darkColor; C.add((E.r - C.r) * F, (E.g - C.g) * F, (E.b - C.b) * F, (E.a - C.a) * F); A.add((L.r - A.r) * F, (L.g - A.g) * F, (L.b - A.b) * F, 0) }return } var M = 0, Q = 0, S = 0, U = 0, N = 0, V = 0, G = 0; if (H >= J[J.length - w.ENTRIES]) { var P = J.length; M = J[P + w.PREV_R]; Q = J[P + w.PREV_G]; S = J[P + w.PREV_B]; U = J[P + w.PREV_A]; N = J[P + w.PREV_R2]; V = J[P + w.PREV_G2]; G = J[P + w.PREV_B2] } else { var K = s.binarySearch(J, H, w.ENTRIES); M = J[K + w.PREV_R]; Q = J[K + w.PREV_G]; S = J[K + w.PREV_B]; U = J[K + w.PREV_A]; N = J[K + w.PREV_R2]; V = J[K + w.PREV_G2]; G = J[K + w.PREV_B2]; var I = J[K]; var y = this.getCurvePercent(K / w.ENTRIES - 1, 1 - (H - I) / (J[K + w.PREV_TIME] - I)); M += (J[K + w.R] - M) * y; Q += (J[K + w.G] - Q) * y; S += (J[K + w.B] - S) * y; U += (J[K + w.A] - U) * y; N += (J[K + w.R2] - N) * y; V += (J[K + w.G2] - V) * y; G += (J[K + w.B2] - G) * y } if (F == 1) { B.color.set(M, Q, S, U); B.darkColor.set(N, V, G, 1) } else { var C = B.color, A = B.darkColor; if (O == t.setup) { C.setFromColor(B.data.color); A.setFromColor(B.data.darkColor) } C.add((M - C.r) * F, (Q - C.g) * F, (S - C.b) * F, (U - C.a) * F); A.add((N - A.r) * F, (V - A.g) * F, (G - A.b) * F, 0) } }; w.ENTRIES = 8; w.PREV_TIME = -8; w.PREV_R = -7; w.PREV_G = -6; w.PREV_B = -5; w.PREV_A = -4; w.PREV_R2 = -3; w.PREV_G2 = -2; w.PREV_B2 = -1; w.R = 1; w.G = 2; w.B = 3; w.A = 4; w.R2 = 5; w.G2 = 6; w.B2 = 7; return w }(u)); a.TwoColorTimeline = v; var n = (function () { function w(x) { this.frames = a.Utils.newFloatArray(x); this.attachmentNames = new Array(x) } w.prototype.getPropertyId = function () { return (g.attachment << 24) + this.slotIndex }; w.prototype.getFrameCount = function () { return this.frames.length }; w.prototype.setFrame = function (z, y, x) { this.frames[z] = y; this.attachmentNames[z] = x }; w.prototype.apply = function (A, x, z, H, B, E, F) { var G = A.slots[this.slotIndex]; if (!G.bone.active) { return } if (F == l.mixOut) { if (E == t.setup) { this.setAttachment(A, G, G.data.attachmentName) } return } var D = this.frames; if (z < D[0]) { if (E == t.setup || E == t.first) { this.setAttachment(A, G, G.data.attachmentName) } return } var y = 0; if (z >= D[D.length - 1]) { y = D.length - 1 } else { y = s.binarySearch(D, z, 1) - 1 } var C = this.attachmentNames[y]; A.slots[this.slotIndex].setAttachment(C == null ? null : A.getAttachment(this.slotIndex, C)) }; w.prototype.setAttachment = function (y, z, x) { z.attachment = x == null ? null : y.getAttachment(this.slotIndex, x) }; return w }()); a.AttachmentTimeline = n; var o = null; var e = (function (w) { __extends(x, w); function x(y) { var z = w.call(this, y) || this; z.frames = a.Utils.newFloatArray(y); z.frameVertices = new Array(y); if (o == null) { o = a.Utils.newFloatArray(64) } return z } x.prototype.getPropertyId = function () { return (g.deform << 27) + +this.attachment.id + this.slotIndex }; x.prototype.setFrame = function (A, z, y) { this.frames[A] = z; this.frameVertices[A] = y }; x.prototype.apply = function (V, ao, ag, B, ai, aj, E) { var L = V.slots[this.slotIndex]; if (!L.bone.active) { return } var ah = L.getAttachment(); if (!(ah instanceof a.VertexAttachment) || !(ah.deformAttachment == this.attachment)) { return } var D = L.deform; if (D.length == 0) { aj = t.setup } var U = this.frameVertices; var am = U[0].length; var T = this.frames; if (ag < T[0]) { var H = ah; switch (aj) { case t.setup: D.length = 0; return; case t.first: if (ai == 1) { D.length = 0; break } var y = a.Utils.setArraySize(D, am); if (H.bones == null) { var G = H.vertices; for (var ak = 0; ak < am; ak++) { y[ak] += (G[ak] - y[ak]) * ai } } else { ai = 1 - ai; for (var ak = 0; ak < am; ak++) { y[ak] *= ai } } }return } var af = a.Utils.setArraySize(D, am); if (ag >= T[T.length - 1]) { var S = U[T.length - 1]; if (ai == 1) { if (aj == t.add) { var H = ah; if (H.bones == null) { var G = H.vertices; for (var R = 0; R < am; R++) { af[R] += S[R] - G[R] } } else { for (var Q = 0; Q < am; Q++) { af[Q] += S[Q] } } } else { a.Utils.arrayCopy(S, 0, af, 0, am) } } else { switch (aj) { case t.setup: var X = ah; if (X.bones == null) { var G = X.vertices; for (var P = 0; P < am; P++) { var C = G[P]; af[P] = C + (S[P] - C) * ai } } else { for (var O = 0; O < am; O++) { af[O] = S[O] * ai } } break; case t.first: case t.replace: for (var N = 0; N < am; N++) { af[N] += (S[N] - af[N]) * ai } break; case t.add: var H = ah; if (H.bones == null) { var G = H.vertices; for (var M = 0; M < am; M++) { af[M] += (S[M] - G[M]) * ai } } else { for (var K = 0; K < am; K++) { af[K] += S[K] * ai } } } } return } var z = s.binarySearch(T, ag); var al = U[z - 1]; var J = U[z]; var an = T[z]; var A = this.getCurvePercent(z - 1, 1 - (ag - an) / (T[z - 1] - an)); if (ai == 1) { if (aj == t.add) { var H = ah; if (H.bones == null) { var G = H.vertices; for (var I = 0; I < am; I++) { var ab = al[I]; af[I] += ab + (J[I] - ab) * A - G[I] } } else { for (var F = 0; F < am; F++) { var ab = al[F]; af[F] += ab + (J[F] - ab) * A } } } else { for (var ae = 0; ae < am; ae++) { var ab = al[ae]; af[ae] = ab + (J[ae] - ab) * A } } } else { switch (aj) { case t.setup: var W = ah; if (W.bones == null) { var G = W.vertices; for (var ad = 0; ad < am; ad++) { var ab = al[ad], C = G[ad]; af[ad] = C + (ab + (J[ad] - ab) * A - C) * ai } } else { for (var ac = 0; ac < am; ac++) { var ab = al[ac]; af[ac] = (ab + (J[ac] - ab) * A) * ai } } break; case t.first: case t.replace: for (var aa = 0; aa < am; aa++) { var ab = al[aa]; af[aa] += (ab + (J[aa] - ab) * A - af[aa]) * ai } break; case t.add: var H = ah; if (H.bones == null) { var G = H.vertices; for (var Z = 0; Z < am; Z++) { var ab = al[Z]; af[Z] += (ab + (J[Z] - ab) * A - G[Z]) * ai } } else { for (var Y = 0; Y < am; Y++) { var ab = al[Y]; af[Y] += (ab + (J[Y] - ab) * A) * ai } } } } }; return x }(u)); a.DeformTimeline = e; var j = (function () { function w(x) { this.frames = a.Utils.newFloatArray(x); this.events = new Array(x) } w.prototype.getPropertyId = function () { return g.event << 24 }; w.prototype.getFrameCount = function () { return this.frames.length }; w.prototype.setFrame = function (y, x) { this.frames[y] = x.time; this.events[y] = x }; w.prototype.apply = function (B, x, A, H, C, F, G) { if (H == null) { return } var E = this.frames; var z = this.frames.length; if (x > A) { this.apply(B, x, Number.MAX_VALUE, H, C, F, G); x = -1 } else { if (x >= E[z - 1]) { return } } if (A < E[0]) { return } var y = 0; if (x < E[0]) { y = 0 } else { y = s.binarySearch(E, x); var D = E[y]; while (y > 0) { if (E[y - 1] != D) { break } y-- } } for (; y < z && A >= E[y]; y++) { H.push(this.events[y]) } }; return w }()); a.EventTimeline = j; var c = (function () { function w(x) { this.frames = a.Utils.newFloatArray(x); this.drawOrders = new Array(x) } w.prototype.getPropertyId = function () { return g.drawOrder << 24 }; w.prototype.getFrameCount = function () { return this.frames.length }; w.prototype.setFrame = function (z, x, y) { this.frames[z] = x; this.drawOrders[z] = y }; w.prototype.apply = function (C, y, B, K, D, H, I) { var x = C.drawOrder; var F = C.slots; if (I == l.mixOut) { if (H == t.setup) { a.Utils.arrayCopy(C.slots, 0, C.drawOrder, 0, C.slots.length) } return } var G = this.frames; if (B < G[0]) { if (H == t.setup || H == t.first) { a.Utils.arrayCopy(C.slots, 0, C.drawOrder, 0, C.slots.length) } return } var z = 0; if (B >= G[G.length - 1]) { z = G.length - 1 } else { z = s.binarySearch(G, B) - 1 } var J = this.drawOrders[z]; if (J == null) { a.Utils.arrayCopy(F, 0, x, 0, F.length) } else { for (var E = 0, A = J.length; E < A; E++) { x[E] = F[J[E]] } } }; return w }()); a.DrawOrderTimeline = c; var k = (function (w) { __extends(x, w); function x(y) { var z = w.call(this, y) || this; z.frames = a.Utils.newFloatArray(y * x.ENTRIES); return z } x.prototype.getPropertyId = function () { return (g.ikConstraint << 24) + this.ikConstraintIndex }; x.prototype.setFrame = function (E, D, C, B, z, y, A) { E *= x.ENTRIES; this.frames[E] = D; this.frames[E + x.MIX] = C; this.frames[E + x.SOFTNESS] = B; this.frames[E + x.BEND_DIRECTION] = z; this.frames[E + x.COMPRESS] = y ? 1 : 0; this.frames[E + x.STRETCH] = A ? 1 : 0 }; x.prototype.apply = function (C, y, B, L, D, H, I) { var G = this.frames; var z = C.ikConstraints[this.ikConstraintIndex]; if (!z.active) { return } if (B < G[0]) { switch (H) { case t.setup: z.mix = z.data.mix; z.softness = z.data.softness; z.bendDirection = z.data.bendDirection; z.compress = z.data.compress; z.stretch = z.data.stretch; return; case t.first: z.mix += (z.data.mix - z.mix) * D; z.softness += (z.data.softness - z.softness) * D; z.bendDirection = z.data.bendDirection; z.compress = z.data.compress; z.stretch = z.data.stretch }return } if (B >= G[G.length - x.ENTRIES]) { if (H == t.setup) { z.mix = z.data.mix + (G[G.length + x.PREV_MIX] - z.data.mix) * D; z.softness = z.data.softness + (G[G.length + x.PREV_SOFTNESS] - z.data.softness) * D; if (I == l.mixOut) { z.bendDirection = z.data.bendDirection; z.compress = z.data.compress; z.stretch = z.data.stretch } else { z.bendDirection = G[G.length + x.PREV_BEND_DIRECTION]; z.compress = G[G.length + x.PREV_COMPRESS] != 0; z.stretch = G[G.length + x.PREV_STRETCH] != 0 } } else { z.mix += (G[G.length + x.PREV_MIX] - z.mix) * D; z.softness += (G[G.length + x.PREV_SOFTNESS] - z.softness) * D; if (I == l.mixIn) { z.bendDirection = G[G.length + x.PREV_BEND_DIRECTION]; z.compress = G[G.length + x.PREV_COMPRESS] != 0; z.stretch = G[G.length + x.PREV_STRETCH] != 0 } } return } var A = s.binarySearch(G, B, x.ENTRIES); var J = G[A + x.PREV_MIX]; var K = G[A + x.PREV_SOFTNESS]; var F = G[A]; var E = this.getCurvePercent(A / x.ENTRIES - 1, 1 - (B - F) / (G[A + x.PREV_TIME] - F)); if (H == t.setup) { z.mix = z.data.mix + (J + (G[A + x.MIX] - J) * E - z.data.mix) * D; z.softness = z.data.softness + (K + (G[A + x.SOFTNESS] - K) * E - z.data.softness) * D; if (I == l.mixOut) { z.bendDirection = z.data.bendDirection; z.compress = z.data.compress; z.stretch = z.data.stretch } else { z.bendDirection = G[A + x.PREV_BEND_DIRECTION]; z.compress = G[A + x.PREV_COMPRESS] != 0; z.stretch = G[A + x.PREV_STRETCH] != 0 } } else { z.mix += (J + (G[A + x.MIX] - J) * E - z.mix) * D; z.softness += (K + (G[A + x.SOFTNESS] - K) * E - z.softness) * D; if (I == l.mixIn) { z.bendDirection = G[A + x.PREV_BEND_DIRECTION]; z.compress = G[A + x.PREV_COMPRESS] != 0; z.stretch = G[A + x.PREV_STRETCH] != 0 } } }; x.ENTRIES = 6; x.PREV_TIME = -6; x.PREV_MIX = -5; x.PREV_SOFTNESS = -4; x.PREV_BEND_DIRECTION = -3; x.PREV_COMPRESS = -2; x.PREV_STRETCH = -1; x.MIX = 1; x.SOFTNESS = 2; x.BEND_DIRECTION = 3; x.COMPRESS = 4; x.STRETCH = 5; return x }(u)); a.IkConstraintTimeline = k; var m = (function (x) { __extends(w, x); function w(y) { var z = x.call(this, y) || this; z.frames = a.Utils.newFloatArray(y * w.ENTRIES); return z } w.prototype.getPropertyId = function () { return (g.transformConstraint << 24) + this.transformConstraintIndex }; w.prototype.setFrame = function (D, C, y, A, z, B) { D *= w.ENTRIES; this.frames[D] = C; this.frames[D + w.ROTATE] = y; this.frames[D + w.TRANSLATE] = A; this.frames[D + w.SCALE] = z; this.frames[D + w.SHEAR] = B }; w.prototype.apply = function (A, M, C, N, B, H, K) { var E = this.frames; var y = A.transformConstraints[this.transformConstraintIndex]; if (!y.active) { return } if (C < E[0]) { var O = y.data; switch (H) { case t.setup: y.rotateMix = O.rotateMix; y.translateMix = O.translateMix; y.scaleMix = O.scaleMix; y.shearMix = O.shearMix; return; case t.first: y.rotateMix += (O.rotateMix - y.rotateMix) * B; y.translateMix += (O.translateMix - y.translateMix) * B; y.scaleMix += (O.scaleMix - y.scaleMix) * B; y.shearMix += (O.shearMix - y.shearMix) * B }return } var J = 0, F = 0, P = 0, L = 0; if (C >= E[E.length - w.ENTRIES]) { var I = E.length; J = E[I + w.PREV_ROTATE]; F = E[I + w.PREV_TRANSLATE]; P = E[I + w.PREV_SCALE]; L = E[I + w.PREV_SHEAR] } else { var G = s.binarySearch(E, C, w.ENTRIES); J = E[G + w.PREV_ROTATE]; F = E[G + w.PREV_TRANSLATE]; P = E[G + w.PREV_SCALE]; L = E[G + w.PREV_SHEAR]; var D = E[G]; var z = this.getCurvePercent(G / w.ENTRIES - 1, 1 - (C - D) / (E[G + w.PREV_TIME] - D)); J += (E[G + w.ROTATE] - J) * z; F += (E[G + w.TRANSLATE] - F) * z; P += (E[G + w.SCALE] - P) * z; L += (E[G + w.SHEAR] - L) * z } if (H == t.setup) { var O = y.data; y.rotateMix = O.rotateMix + (J - O.rotateMix) * B; y.translateMix = O.translateMix + (F - O.translateMix) * B; y.scaleMix = O.scaleMix + (P - O.scaleMix) * B; y.shearMix = O.shearMix + (L - O.shearMix) * B } else { y.rotateMix += (J - y.rotateMix) * B; y.translateMix += (F - y.translateMix) * B; y.scaleMix += (P - y.scaleMix) * B; y.shearMix += (L - y.shearMix) * B } }; w.ENTRIES = 5; w.PREV_TIME = -5; w.PREV_ROTATE = -4; w.PREV_TRANSLATE = -3; w.PREV_SCALE = -2; w.PREV_SHEAR = -1; w.ROTATE = 1; w.TRANSLATE = 2; w.SCALE = 3; w.SHEAR = 4; return w }(u)); a.TransformConstraintTimeline = m; var p = (function (w) { __extends(x, w); function x(y) { var z = w.call(this, y) || this; z.frames = a.Utils.newFloatArray(y * x.ENTRIES); return z } x.prototype.getPropertyId = function () { return (g.pathConstraintPosition << 24) + this.pathConstraintIndex }; x.prototype.setFrame = function (A, z, y) { A *= x.ENTRIES; this.frames[A] = z; this.frames[A + x.VALUE] = y }; x.prototype.apply = function (C, y, B, K, D, I, J) { var H = this.frames; var z = C.pathConstraints[this.pathConstraintIndex]; if (!z.active) { return } if (B < H[0]) { switch (I) { case t.setup: z.position = z.data.position; return; case t.first: z.position += (z.data.position - z.position) * D }return } var E = 0; if (B >= H[H.length - x.ENTRIES]) { E = H[H.length + x.PREV_VALUE] } else { var A = s.binarySearch(H, B, x.ENTRIES); E = H[A + x.PREV_VALUE]; var G = H[A]; var F = this.getCurvePercent(A / x.ENTRIES - 1, 1 - (B - G) / (H[A + x.PREV_TIME] - G)); E += (H[A + x.VALUE] - E) * F } if (I == t.setup) { z.position = z.data.position + (E - z.data.position) * D } else { z.position += (E - z.position) * D } }; x.ENTRIES = 2; x.PREV_TIME = -2; x.PREV_VALUE = -1; x.VALUE = 1; return x }(u)); a.PathConstraintPositionTimeline = p; var h = (function (x) { __extends(w, x); function w(y) { return x.call(this, y) || this } w.prototype.getPropertyId = function () { return (g.pathConstraintSpacing << 24) + this.pathConstraintIndex }; w.prototype.apply = function (C, y, B, K, D, H, J) { var G = this.frames; var z = C.pathConstraints[this.pathConstraintIndex]; if (!z.active) { return } if (B < G[0]) { switch (H) { case t.setup: z.spacing = z.data.spacing; return; case t.first: z.spacing += (z.data.spacing - z.spacing) * D }return } var I = 0; if (B >= G[G.length - w.ENTRIES]) { I = G[G.length + w.PREV_VALUE] } else { var A = s.binarySearch(G, B, w.ENTRIES); I = G[A + w.PREV_VALUE]; var F = G[A]; var E = this.getCurvePercent(A / w.ENTRIES - 1, 1 - (B - F) / (G[A + w.PREV_TIME] - F)); I += (G[A + w.VALUE] - I) * E } if (H == t.setup) { z.spacing = z.data.spacing + (I - z.data.spacing) * D } else { z.spacing += (I - z.spacing) * D } }; return w }(p)); a.PathConstraintSpacingTimeline = h; var f = (function (w) { __extends(x, w); function x(y) { var z = w.call(this, y) || this; z.frames = a.Utils.newFloatArray(y * x.ENTRIES); return z } x.prototype.getPropertyId = function () { return (g.pathConstraintMix << 24) + this.pathConstraintIndex }; x.prototype.setFrame = function (B, A, y, z) { B *= x.ENTRIES; this.frames[B] = A; this.frames[B + x.ROTATE] = y; this.frames[B + x.TRANSLATE] = z }; x.prototype.apply = function (D, y, C, L, E, J, K) { var I = this.frames; var z = D.pathConstraints[this.pathConstraintIndex]; if (!z.active) { return } if (C < I[0]) { switch (J) { case t.setup: z.rotateMix = z.data.rotateMix; z.translateMix = z.data.translateMix; return; case t.first: z.rotateMix += (z.data.rotateMix - z.rotateMix) * E; z.translateMix += (z.data.translateMix - z.translateMix) * E }return } var F = 0, B = 0; if (C >= I[I.length - x.ENTRIES]) { F = I[I.length + x.PREV_ROTATE]; B = I[I.length + x.PREV_TRANSLATE] } else { var A = s.binarySearch(I, C, x.ENTRIES); F = I[A + x.PREV_ROTATE]; B = I[A + x.PREV_TRANSLATE]; var H = I[A]; var G = this.getCurvePercent(A / x.ENTRIES - 1, 1 - (C - H) / (I[A + x.PREV_TIME] - H)); F += (I[A + x.ROTATE] - F) * G; B += (I[A + x.TRANSLATE] - B) * G } if (J == t.setup) { z.rotateMix = z.data.rotateMix + (F - z.data.rotateMix) * E; z.translateMix = z.data.translateMix + (B - z.data.translateMix) * E } else { z.rotateMix += (F - z.rotateMix) * E; z.translateMix += (B - z.translateMix) * E } }; x.ENTRIES = 3; x.PREV_TIME = -3; x.PREV_ROTATE = -2; x.PREV_TRANSLATE = -1; x.ROTATE = 1; x.TRANSLATE = 2; return x }(u)); a.PathConstraintMixTimeline = f })(spine || (spine = {})); var spine; (function (d) { var a = (function () { function g(h) { this.tracks = new Array(); this.timeScale = 1; this.unkeyedState = 0; this.events = new Array(); this.listeners = new Array(); this.queue = new e(this); this.propertyIDs = new d.IntSet(); this.animationsChanged = false; this.trackEntryPool = new d.Pool(function () { return new f() }); this.data = h } g.prototype.update = function (q) { q *= this.timeScale; var o = this.tracks; for (var k = 0, h = o.length; k < h; k++) { var m = o[k]; if (m == null) { continue } m.animationLast = m.nextAnimationLast; m.trackLast = m.nextTrackLast; var r = q * m.timeScale; if (m.delay > 0) { m.delay -= r; if (m.delay > 0) { continue } r = -m.delay; m.delay = 0 } var l = m.next; if (l != null) { var j = m.trackLast - l.delay; if (j >= 0) { l.delay = 0; l.trackTime += m.timeScale == 0 ? 0 : (j / m.timeScale + q) * l.timeScale; m.trackTime += r; this.setCurrent(k, l, true); while (l.mixingFrom != null) { l.mixTime += q; l = l.mixingFrom } continue } } else { if (m.trackLast >= m.trackEnd && m.mixingFrom == null) { o[k] = null; this.queue.end(m); this.disposeNext(m); continue } } if (m.mixingFrom != null && this.updateMixingFrom(m, q)) { var p = m.mixingFrom; m.mixingFrom = null; if (p != null) { p.mixingTo = null } while (p != null) { this.queue.end(p); p = p.mixingFrom } } m.trackTime += r } this.queue.drain() }; g.prototype.updateMixingFrom = function (k, j) { var i = k.mixingFrom; if (i == null) { return true } var h = this.updateMixingFrom(i, j); i.animationLast = i.nextAnimationLast; i.trackLast = i.nextTrackLast; if (k.mixTime > 0 && k.mixTime >= k.mixDuration) { if (i.totalAlpha == 0 || k.mixDuration == 0) { k.mixingFrom = i.mixingFrom; if (i.mixingFrom != null) { i.mixingFrom.mixingTo = k } k.interruptAlpha = i.interruptAlpha; this.queue.end(i) } return h } i.trackTime += j * i.timeScale; k.mixTime += j; return false }; g.prototype.apply = function (m) { if (m == null) { throw new Error("skeleton cannot be null.") } if (this.animationsChanged) { this._animationsChanged() } var j = this.events; var D = this.tracks; var h = false; for (var z = 0, k = D.length; z < k; z++) { var y = D[z]; if (y == null || y.delay > 0) { continue } h = true; var B = z == 0 ? d.MixBlend.first : y.mixBlend; var s = y.alpha; if (y.mixingFrom != null) { s *= this.applyMixingFrom(y, m, B) } else { if (y.trackTime >= y.trackEnd && y.next == null) { s = 0 } } var E = y.animationLast, A = y.getAnimationTime(); var u = y.animation.timelines.length; var v = y.animation.timelines; if ((z == 0 && s == 1) || B == d.MixBlend.add) { for (var t = 0; t < u; t++) { d.Utils.webkit602BugfixHelper(s, B); var p = v[t]; if (p instanceof d.AttachmentTimeline) { this.applyAttachmentTimeline(p, m, A, B, true) } else { p.apply(m, E, A, j, s, B, d.MixDirection.mixIn) } } } else { var I = y.timelineMode; var q = y.timelinesRotation.length == 0; if (q) { d.Utils.setArraySize(y.timelinesRotation, u << 1, null) } var F = y.timelinesRotation; for (var t = 0; t < u; t++) { var G = v[t]; var H = I[t] == g.SUBSEQUENT ? B : d.MixBlend.setup; if (G instanceof d.RotateTimeline) { this.applyRotateTimeline(G, m, A, s, H, F, t << 1, q) } else { if (G instanceof d.AttachmentTimeline) { this.applyAttachmentTimeline(G, m, A, B, true) } else { d.Utils.webkit602BugfixHelper(s, B); G.apply(m, E, A, j, s, H, d.MixDirection.mixIn) } } } } this.queueEvents(y, A); j.length = 0; y.nextAnimationLast = A; y.nextTrackLast = y.trackTime } var o = this.unkeyedState + g.SETUP; var r = m.slots; for (var C = 0, x = m.slots.length; C < x; C++) { var l = r[C]; if (l.attachmentState == o) { var w = l.data.attachmentName; l.attachment = (w == null ? null : m.getAttachment(l.data.index, w)) } } this.unkeyedState += 2; this.queue.drain(); return h }; g.prototype.applyMixingFrom = function (k, l, x) { var v = k.mixingFrom; if (v.mixingFrom != null) { this.applyMixingFrom(v, l, x) } var q = 0; if (k.mixDuration == 0) { q = 1; if (x == d.MixBlend.first) { x = d.MixBlend.setup } } else { q = k.mixTime / k.mixDuration; if (q > 1) { q = 1 } if (x != d.MixBlend.first) { x = v.mixBlend } } var j = q < v.eventThreshold ? this.events : null; var D = q < v.attachmentThreshold, A = q < v.drawOrderThreshold; var z = v.animationLast, w = v.getAnimationTime(); var r = v.animation.timelines.length; var s = v.animation.timelines; var m = v.alpha * k.interruptAlpha, t = m * (1 - q); if (x == d.MixBlend.add) { for (var y = 0; y < r; y++) { s[y].apply(l, z, w, j, t, x, d.MixDirection.mixOut) } } else { var F = v.timelineMode; var h = v.timelineHoldMix; var p = v.timelinesRotation.length == 0; if (p) { d.Utils.setArraySize(v.timelinesRotation, r << 1, null) } var C = v.timelinesRotation; v.totalAlpha = 0; for (var y = 0; y < r; y++) { var o = s[y]; var B = d.MixDirection.mixOut; var E = void 0; var n = 0; switch (F[y]) { case g.SUBSEQUENT: if (!A && o instanceof d.DrawOrderTimeline) { continue } E = x; n = t; break; case g.FIRST: E = d.MixBlend.setup; n = t; break; case g.HOLD: E = d.MixBlend.setup; n = m; break; default: E = d.MixBlend.setup; var u = h[y]; n = m * Math.max(0, 1 - u.mixTime / u.mixDuration); break }v.totalAlpha += n; if (o instanceof d.RotateTimeline) { this.applyRotateTimeline(o, l, w, n, E, C, y << 1, p) } else { if (o instanceof d.AttachmentTimeline) { this.applyAttachmentTimeline(o, l, w, E, D) } else { d.Utils.webkit602BugfixHelper(n, x); if (A && o instanceof d.DrawOrderTimeline && E == d.MixBlend.setup) { B = d.MixDirection.mixIn } o.apply(l, z, w, j, n, E, B) } } } } if (k.mixDuration > 0) { this.queueEvents(v, w) } this.events.length = 0; v.nextAnimationLast = w; v.nextTrackLast = v.trackTime; return q }; g.prototype.applyAttachmentTimeline = function (j, l, k, i, h) { var o = l.slots[j.slotIndex]; if (!o.bone.active) { return } var m = j.frames; if (k < m[0]) { if (i == d.MixBlend.setup || i == d.MixBlend.first) { this.setAttachment(l, o, o.data.attachmentName, h) } } else { var n; if (k >= m[m.length - 1]) { n = m.length - 1 } else { n = d.Animation.binarySearch(m, k) - 1 } this.setAttachment(l, o, j.attachmentNames[n], h) } if (o.attachmentState <= this.unkeyedState) { o.attachmentState = this.unkeyedState + g.SETUP } }; g.prototype.setAttachment = function (j, k, i, h) { k.attachment = i == null ? null : j.getAttachment(k.data.index, i); if (h) { k.attachmentState = this.unkeyedState + g.CURRENT } }; g.prototype.applyRotateTimeline = function (m, k, p, l, y, D, A, o) { if (o) { D[A] = 0 } if (l == 1) { m.apply(k, 0, p, null, 1, y, d.MixDirection.mixIn); return } var q = m; var t = q.frames; var n = k.bones[q.boneIndex]; if (!n.active) { return } var B = 0, z = 0; if (p < t[0]) { switch (y) { case d.MixBlend.setup: n.rotation = n.data.rotation; default: return; case d.MixBlend.first: B = n.rotation; z = n.data.rotation } } else { B = y == d.MixBlend.setup ? n.data.rotation : n.rotation; if (p >= t[t.length - d.RotateTimeline.ENTRIES]) { z = n.data.rotation + t[t.length + d.RotateTimeline.PREV_ROTATION] } else { var v = d.Animation.binarySearch(t, p, d.RotateTimeline.ENTRIES); var C = t[v + d.RotateTimeline.PREV_ROTATION]; var r = t[v]; var h = q.getCurvePercent((v >> 1) - 1, 1 - (p - r) / (t[v + d.RotateTimeline.PREV_TIME] - r)); z = t[v + d.RotateTimeline.ROTATION] - C; z -= (16384 - ((16384.499999999996 - z / 360) | 0)) * 360; z = C + z * h + n.data.rotation; z -= (16384 - ((16384.499999999996 - z / 360) | 0)) * 360 } } var E = 0, u = z - B; u -= (16384 - ((16384.499999999996 - u / 360) | 0)) * 360; if (u == 0) { E = D[A] } else { var s = 0, j = 0; if (o) { s = 0; j = u } else { s = D[A]; j = D[A + 1] } var x = u > 0, w = s >= 0; if (d.MathUtils.signum(j) != d.MathUtils.signum(u) && Math.abs(j) <= 90) { if (Math.abs(s) > 180) { s += 360 * d.MathUtils.signum(s) } w = x } E = u + s - s % 360; if (w != x) { E += 360 * d.MathUtils.signum(s) } D[A] = E } D[A + 1] = u; B += E * l; n.rotation = B - (16384 - ((16384.499999999996 - B / 360) | 0)) * 360 }; g.prototype.queueEvents = function (t, s) { var k = t.animationStart, j = t.animationEnd; var o = j - k; var m = t.trackLast % o; var u = this.events; var p = 0, l = u.length; for (; p < l; p++) { var r = u[p]; if (r.time < m) { break } if (r.time > j) { continue } this.queue.event(t, r) } var h = false; if (t.loop) { h = o == 0 || m > t.trackTime % o } else { h = s >= j && t.animationLast < j } if (h) { this.queue.complete(t) } for (; p < l; p++) { var q = u[p]; if (q.time < k) { continue } this.queue.event(t, u[p]) } }; g.prototype.clearTracks = function () { var j = this.queue.drainDisabled; this.queue.drainDisabled = true; for (var h = 0, k = this.tracks.length; h < k; h++) { this.clearTrack(h) } this.tracks.length = 0; this.queue.drainDisabled = j; this.queue.drain() }; g.prototype.clearTrack = function (k) { if (k >= this.tracks.length) { return } var i = this.tracks[k]; if (i == null) { return } this.queue.end(i); this.disposeNext(i); var h = i; while (true) { var j = h.mixingFrom; if (j == null) { break } this.queue.end(j); h.mixingFrom = null; h.mixingTo = null; h = j } this.tracks[i.trackIndex] = null; this.queue.drain() }; g.prototype.setCurrent = function (h, i, j) { var k = this.expandToIndex(h); this.tracks[h] = i; if (k != null) { if (j) { this.queue.interrupt(k) } i.mixingFrom = k; k.mixingTo = i; i.mixTime = 0; if (k.mixingFrom != null && k.mixDuration > 0) { i.interruptAlpha *= Math.min(1, k.mixTime / k.mixDuration) } k.timelinesRotation.length = 0 } this.queue.start(i) }; g.prototype.setAnimation = function (k, i, h) { var j = this.data.skeletonData.findAnimation(i); if (j == null) { throw new Error("Animation not found: " + i) } return this.setAnimationWith(k, j, h) }; g.prototype.setAnimationWith = function (m, j, h) { if (j == null) { throw new Error("animation cannot be null.") } var l = true; var k = this.expandToIndex(m); if (k != null) { if (k.nextTrackLast == -1) { this.tracks[m] = k.mixingFrom; this.queue.interrupt(k); this.queue.end(k); this.disposeNext(k); k = k.mixingFrom; l = false } else { this.disposeNext(k) } } var i = this.trackEntry(m, j, h, k); this.setCurrent(m, i, l); this.queue.drain(); return i }; g.prototype.addAnimation = function (l, j, h, i) { var k = this.data.skeletonData.findAnimation(j); if (k == null) { throw new Error("Animation not found: " + j) } return this.addAnimationWith(l, k, h, i) }; g.prototype.addAnimationWith = function (n, l, h, i) { if (l == null) { throw new Error("animation cannot be null.") } var k = this.expandToIndex(n); if (k != null) { while (k.next != null) { k = k.next } } var j = this.trackEntry(n, l, h, k); if (k == null) { this.setCurrent(n, j, true); this.queue.drain() } else { k.next = j; if (i <= 0) { var m = k.animationEnd - k.animationStart; if (m != 0) { if (k.loop) { i += m * (1 + ((k.trackTime / m) | 0)) } else { i += Math.max(m, k.trackTime) } i -= this.data.getMix(k.animation, l) } else { i = k.trackTime } } } j.delay = i; return j }; g.prototype.setEmptyAnimation = function (j, h) { var i = this.setAnimationWith(j, g.emptyAnimation, false); i.mixDuration = h; i.trackEnd = h; return i }; g.prototype.addEmptyAnimation = function (k, h, i) { if (i <= 0) { i -= h } var j = this.addAnimationWith(k, g.emptyAnimation, false, i); j.mixDuration = h; j.trackEnd = h; return j }; g.prototype.setEmptyAnimations = function (h) { var k = this.queue.drainDisabled; this.queue.drainDisabled = true; for (var j = 0, m = this.tracks.length; j < m; j++) { var l = this.tracks[j]; if (l != null) { this.setEmptyAnimation(l.trackIndex, h) } } this.queue.drainDisabled = k; this.queue.drain() }; g.prototype.expandToIndex = function (h) { if (h < this.tracks.length) { return this.tracks[h] } d.Utils.ensureArrayCapacity(this.tracks, h + 1, null); this.tracks.length = h + 1; return null }; g.prototype.trackEntry = function (l, k, h, j) { var i = this.trackEntryPool.obtain(); i.trackIndex = l; i.animation = k; i.loop = h; i.holdPrevious = false; i.eventThreshold = 0; i.attachmentThreshold = 0; i.drawOrderThreshold = 0; i.animationStart = 0; i.animationEnd = k.duration; i.animationLast = -1; i.nextAnimationLast = -1; i.delay = 0; i.trackTime = 0; i.trackLast = -1; i.nextTrackLast = -1; i.trackEnd = Number.MAX_VALUE; i.timeScale = 1; i.alpha = 1; i.interruptAlpha = 1; i.mixTime = 0; i.mixDuration = j == null ? 0 : this.data.getMix(j.animation, k); i.mixBlend = d.MixBlend.replace; return i }; g.prototype.disposeNext = function (i) { var h = i.next; while (h != null) { this.queue.dispose(h); h = h.next } i.next = null }; g.prototype._animationsChanged = function () { this.animationsChanged = false; this.propertyIDs.clear(); for (var h = 0, k = this.tracks.length; h < k; h++) { var j = this.tracks[h]; if (j == null) { continue } while (j.mixingFrom != null) { j = j.mixingFrom } do { if (j.mixingFrom == null || j.mixBlend != d.MixBlend.add) { this.computeHold(j) } j = j.mixingTo } while (j != null) } }; g.prototype.computeHold = function (r) { var q = r.mixingTo; var m = r.animation.timelines; var n = r.animation.timelines.length; var h = d.Utils.setArraySize(r.timelineMode, n); r.timelineHoldMix.length = 0; var o = d.Utils.setArraySize(r.timelineHoldMix, n); var p = this.propertyIDs; if (q != null && q.holdPrevious) { for (var k = 0; k < n; k++) { p.add(m[k].getPropertyId()); h[k] = g.HOLD } return } outer: for (var k = 0; k < n; k++) { var s = m[k]; var j = s.getPropertyId(); if (!p.add(j)) { h[k] = g.SUBSEQUENT } else { if (q == null || s instanceof d.AttachmentTimeline || s instanceof d.DrawOrderTimeline || s instanceof d.EventTimeline || !q.animation.hasTimeline(j)) { h[k] = g.FIRST } else { for (var l = q.mixingTo; l != null; l = l.mixingTo) { if (l.animation.hasTimeline(j)) { continue } if (r.mixDuration > 0) { h[k] = g.HOLD_MIX; o[k] = l; continue outer } break } h[k] = g.HOLD } } } }; g.prototype.getCurrent = function (h) { if (h >= this.tracks.length) { return null } return this.tracks[h] }; g.prototype.addListener = function (h) { if (h == null) { throw new Error("listener cannot be null.") } this.listeners.push(h) }; g.prototype.removeListener = function (i) { var h = this.listeners.indexOf(i); if (h >= 0) { this.listeners.splice(h, 1) } }; g.prototype.clearListeners = function () { this.listeners.length = 0 }; g.prototype.clearListenerNotifications = function () { this.queue.clear() }; g.emptyAnimation = new d.Animation("<empty>", [], 0); g.SUBSEQUENT = 0; g.FIRST = 1; g.HOLD = 2; g.HOLD_MIX = 3; g.SETUP = 1; g.CURRENT = 2; return g }()); d.AnimationState = a; var f = (function () { function g() { this.mixBlend = d.MixBlend.replace; this.timelineMode = new Array(); this.timelineHoldMix = new Array(); this.timelinesRotation = new Array() } g.prototype.reset = function () { this.next = null; this.mixingFrom = null; this.mixingTo = null; this.animation = null; this.listener = null; this.timelineMode.length = 0; this.timelineHoldMix.length = 0; this.timelinesRotation.length = 0 }; g.prototype.getAnimationTime = function () { if (this.loop) { var h = this.animationEnd - this.animationStart; if (h == 0) { return this.animationStart } return (this.trackTime % h) + this.animationStart } return Math.min(this.trackTime + this.animationStart, this.animationEnd) }; g.prototype.setAnimationLast = function (h) { this.animationLast = h; this.nextAnimationLast = h }; g.prototype.isComplete = function () { return this.trackTime >= this.animationEnd - this.animationStart }; g.prototype.resetRotationDirections = function () { this.timelinesRotation.length = 0 }; return g }()); d.TrackEntry = f; var e = (function () { function g(h) { this.objects = []; this.drainDisabled = false; this.animState = h } g.prototype.start = function (h) { this.objects.push(b.start); this.objects.push(h); this.animState.animationsChanged = true }; g.prototype.interrupt = function (h) { this.objects.push(b.interrupt); this.objects.push(h) }; g.prototype.end = function (h) { this.objects.push(b.end); this.objects.push(h); this.animState.animationsChanged = true }; g.prototype.dispose = function (h) { this.objects.push(b.dispose); this.objects.push(h) }; g.prototype.complete = function (h) { this.objects.push(b.complete); this.objects.push(h) }; g.prototype.event = function (i, h) { this.objects.push(b.event); this.objects.push(i); this.objects.push(h) }; g.prototype.drain = function () { if (this.drainDisabled) { return } this.drainDisabled = true; var n = this.objects; var l = this.animState.listeners; for (var h = 0; h < n.length; h += 2) { var k = n[h]; var m = n[h + 1]; switch (k) { case b.start: if (m.listener != null && m.listener.start) { m.listener.start(m) } for (var j = 0; j < l.length; j++) { if (l[j].start) { l[j].start(m) } } break; case b.interrupt: if (m.listener != null && m.listener.interrupt) { m.listener.interrupt(m) } for (var j = 0; j < l.length; j++) { if (l[j].interrupt) { l[j].interrupt(m) } } break; case b.end: if (m.listener != null && m.listener.end) { m.listener.end(m) } for (var j = 0; j < l.length; j++) { if (l[j].end) { l[j].end(m) } } case b.dispose: if (m.listener != null && m.listener.dispose) { m.listener.dispose(m) } for (var j = 0; j < l.length; j++) { if (l[j].dispose) { l[j].dispose(m) } } this.animState.trackEntryPool.free(m); break; case b.complete: if (m.listener != null && m.listener.complete) { m.listener.complete(m) } for (var j = 0; j < l.length; j++) { if (l[j].complete) { l[j].complete(m) } } break; case b.event: var o = n[h++ + 2]; if (m.listener != null && m.listener.event) { m.listener.event(m, o) } for (var j = 0; j < l.length; j++) { if (l[j].event) { l[j].event(m, o) } } break } } this.clear(); this.drainDisabled = false }; g.prototype.clear = function () { this.objects.length = 0 }; return g }()); d.EventQueue = e; var b; (function (g) { g[g.start = 0] = "start"; g[g.interrupt = 1] = "interrupt"; g[g.end = 2] = "end"; g[g.dispose = 3] = "dispose"; g[g.complete = 4] = "complete"; g[g.event = 5] = "event" })(b = d.EventType || (d.EventType = {})); var c = (function () { function g() { } g.prototype.start = function (h) { }; g.prototype.interrupt = function (h) { }; g.prototype.end = function (h) { }; g.prototype.dispose = function (h) { }; g.prototype.complete = function (h) { }; g.prototype.event = function (i, h) { }; return g }()); d.AnimationStateAdapter = c })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(d) { this.animationToMixTime = {}; this.defaultMix = 0; if (d == null) { throw new Error("skeletonData cannot be null.") } this.skeletonData = d } c.prototype.setMix = function (e, d, f) { var h = this.skeletonData.findAnimation(e); if (h == null) { throw new Error("Animation not found: " + e) } var g = this.skeletonData.findAnimation(d); if (g == null) { throw new Error("Animation not found: " + d) } this.setMixWith(h, g, f) }; c.prototype.setMixWith = function (g, f, e) { if (g == null) { throw new Error("from cannot be null.") } if (f == null) { throw new Error("to cannot be null.") } var d = g.name + "." + f.name; this.animationToMixTime[d] = e }; c.prototype.getMix = function (g, f) { var d = g.name + "." + f.name; var e = this.animationToMixTime[d]; return e === undefined ? this.defaultMix : e }; return c }()); b.AnimationStateData = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(d, e) { if (e === void 0) { e = "" } this.assets = {}; this.errors = {}; this.toLoad = 0; this.loaded = 0; this.rawDataUris = {}; this.textureLoader = d; this.pathPrefix = e } c.prototype.downloadText = function (e, g, d) { var f = new XMLHttpRequest(); f.overrideMimeType("text/html"); if (this.rawDataUris[e]) { e = this.rawDataUris[e] } f.open("GET", e, true); f.onload = function () { if (f.status == 200) { g(f.responseText) } else { d(f.status, f.responseText) } }; f.onerror = function () { d(f.status, f.responseText) }; f.send() }; c.prototype.downloadBinary = function (e, g, d) { var f = new XMLHttpRequest(); if (this.rawDataUris[e]) { e = this.rawDataUris[e] } f.open("GET", e, true); f.responseType = "arraybuffer"; f.onload = function () { if (f.status == 200) { g(new Uint8Array(f.response)) } else { d(f.status, f.responseText) } }; f.onerror = function () { d(f.status, f.responseText) }; f.send() }; c.prototype.setRawDataURI = function (e, d) { this.rawDataUris[this.pathPrefix + e] = d }; c.prototype.loadBinary = function (e, f, d) { var g = this; if (f === void 0) { f = null } if (d === void 0) { d = null } e = this.pathPrefix + e; this.toLoad++; this.downloadBinary(e, function (h) { g.assets[e] = h; if (f) { f(e, h) } g.toLoad--; g.loaded++ }, function (i, h) { g.errors[e] = "Couldn't load binary " + e + ": status " + status + ", " + h; if (d) { d(e, "Couldn't load binary " + e + ": status " + status + ", " + h) } g.toLoad--; g.loaded++ }) }; c.prototype.loadText = function (e, f, d) { var g = this; if (f === void 0) { f = null } if (d === void 0) { d = null } e = this.pathPrefix + e; this.toLoad++; this.downloadText(e, function (h) { g.assets[e] = h; if (f) { f(e, h) } g.toLoad--; g.loaded++ }, function (i, h) { g.errors[e] = "Couldn't load text " + e + ": status " + status + ", " + h; if (d) { d(e, "Couldn't load text " + e + ": status " + status + ", " + h) } g.toLoad--; g.loaded++ }) }; c.prototype.loadTexture = function (f, h, e) { var i = this; if (h === void 0) { h = null } if (e === void 0) { e = null } f = this.pathPrefix + f; var g = f; this.toLoad++; var d = new Image(); d.crossOrigin = "anonymous"; d.onload = function (k) { var j = i.textureLoader(d); i.assets[g] = j; i.toLoad--; i.loaded++; if (h) { h(f, d) } }; d.onerror = function (j) { i.errors[f] = "Couldn't load image " + f; i.toLoad--; i.loaded++; if (e) { e(f, "Couldn't load image " + f) } }; if (this.rawDataUris[f]) { f = this.rawDataUris[f] } d.src = f }; c.prototype.loadTextureAtlas = function (f, g, d) { var h = this; if (g === void 0) { g = null } if (d === void 0) { d = null } var e = f.lastIndexOf("/") >= 0 ? f.substring(0, f.lastIndexOf("/")) : ""; f = this.pathPrefix + f; this.toLoad++; this.downloadText(f, function (k) { var r = { count: 0 }; var n = new Array(); try { var i = new b.TextureAtlas(k, function (t) { n.push(e == "" ? t : e + "/" + t); var s = document.createElement("img"); s.width = 16; s.height = 16; return new b.FakeTexture(s) }) } catch (o) { var p = o; h.errors[f] = "Couldn't load texture atlas " + f + ": " + p.message; if (d) { d(f, "Couldn't load texture atlas " + f + ": " + p.message) } h.toLoad--; h.loaded++; return } var j = function (s) { var t = false; h.loadTexture(s, function (u, y) { r.count++; if (r.count == n.length) { if (!t) { try { var v = new b.TextureAtlas(k, function (z) { return h.get(e == "" ? z : e + "/" + z) }); h.assets[f] = v; if (g) { g(f, v) } h.toLoad--; h.loaded++ } catch (x) { var w = x; h.errors[f] = "Couldn't load texture atlas " + f + ": " + w.message; if (d) { d(f, "Couldn't load texture atlas " + f + ": " + w.message) } h.toLoad--; h.loaded++ } } else { h.errors[f] = "Couldn't load texture atlas page " + u + "} of atlas " + f; if (d) { d(f, "Couldn't load texture atlas page " + u + " of atlas " + f) } h.toLoad--; h.loaded++ } } }, function (u, v) { t = true; r.count++; if (r.count == n.length) { h.errors[f] = "Couldn't load texture atlas page " + u + "} of atlas " + f; if (d) { d(f, "Couldn't load texture atlas page " + u + " of atlas " + f) } h.toLoad--; h.loaded++ } }) }; for (var l = 0, q = n; l < q.length; l++) { var m = q[l]; j(m) } }, function (j, i) { h.errors[f] = "Couldn't load texture atlas " + f + ": status " + status + ", " + i; if (d) { d(f, "Couldn't load texture atlas " + f + ": status " + status + ", " + i) } h.toLoad--; h.loaded++ }) }; c.prototype.get = function (d) { d = this.pathPrefix + d; return this.assets[d] }; c.prototype.remove = function (e) { e = this.pathPrefix + e; var d = this.assets[e]; if (d.dispose) { d.dispose() } this.assets[e] = null }; c.prototype.removeAll = function () { for (var d in this.assets) { var e = this.assets[d]; if (e.dispose) { e.dispose() } } this.assets = {} }; c.prototype.isLoadingComplete = function () { return this.toLoad == 0 }; c.prototype.getToLoad = function () { return this.toLoad }; c.prototype.getLoaded = function () { return this.loaded }; c.prototype.dispose = function () { this.removeAll() }; c.prototype.hasErrors = function () { return Object.keys(this.errors).length > 0 }; c.prototype.getErrors = function () { return this.errors }; return c }()); b.AssetManager = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(d) { this.atlas = d } c.prototype.newRegionAttachment = function (g, d, f) { var e = this.atlas.findRegion(f); if (e == null) { throw new Error("Region not found in atlas: " + f + " (region attachment: " + d + ")") } e.renderObject = e; var h = new b.RegionAttachment(d); h.setRegion(e); return h }; c.prototype.newMeshAttachment = function (g, d, f) { var e = this.atlas.findRegion(f); if (e == null) { throw new Error("Region not found in atlas: " + f + " (mesh attachment: " + d + ")") } e.renderObject = e; var h = new b.MeshAttachment(d); h.region = e; return h }; c.prototype.newBoundingBoxAttachment = function (e, d) { return new b.BoundingBoxAttachment(d) }; c.prototype.newPathAttachment = function (e, d) { return new b.PathAttachment(d) }; c.prototype.newPointAttachment = function (e, d) { return new b.PointAttachment(d) }; c.prototype.newClippingAttachment = function (e, d) { return new b.ClippingAttachment(d) }; return c }()); b.AtlasAttachmentLoader = a })(spine || (spine = {})); var spine; (function (b) { var a; (function (c) { c[c.Normal = 0] = "Normal"; c[c.Additive = 1] = "Additive"; c[c.Multiply = 2] = "Multiply"; c[c.Screen = 3] = "Screen" })(a = b.BlendMode || (b.BlendMode = {})) })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, f, d) { this.children = new Array(); this.x = 0; this.y = 0; this.rotation = 0; this.scaleX = 0; this.scaleY = 0; this.shearX = 0; this.shearY = 0; this.ax = 0; this.ay = 0; this.arotation = 0; this.ascaleX = 0; this.ascaleY = 0; this.ashearX = 0; this.ashearY = 0; this.appliedValid = false; this.a = 0; this.b = 0; this.c = 0; this.d = 0; this.worldY = 0; this.worldX = 0; this.sorted = false; this.active = false; if (e == null) { throw new Error("data cannot be null.") } if (f == null) { throw new Error("skeleton cannot be null.") } this.data = e; this.skeleton = f; this.parent = d; this.setToSetupPose() } c.prototype.isActive = function () { return this.active }; c.prototype.update = function () { this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY) }; c.prototype.updateWorldTransform = function () { this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY) }; c.prototype.updateWorldTransformWith = function (u, q, F, I, H, K, J) { this.ax = u; this.ay = q; this.arotation = F; this.ascaleX = I; this.ascaleY = H; this.ashearX = K; this.ashearY = J; this.appliedValid = true; var p = this.parent; if (p == null) { var i = this.skeleton; var m = F + 90 + J; var B = i.scaleX; var A = i.scaleY; this.a = b.MathUtils.cosDeg(F + K) * I * B; this.b = b.MathUtils.cosDeg(m) * H * B; this.c = b.MathUtils.sinDeg(F + K) * I * A; this.d = b.MathUtils.sinDeg(m) * H * A; this.worldX = u * B + i.x; this.worldY = q * A + i.y; return } var g = p.a, f = p.b, e = p.c, L = p.d; this.worldX = g * u + f * q + p.worldX; this.worldY = e * u + L * q + p.worldY; switch (this.data.transformMode) { case b.TransformMode.Normal: var m = F + 90 + J; var G = b.MathUtils.cosDeg(F + K) * I; var E = b.MathUtils.cosDeg(m) * H; var D = b.MathUtils.sinDeg(F + K) * I; var C = b.MathUtils.sinDeg(m) * H; this.a = g * G + f * D; this.b = g * E + f * C; this.c = e * G + L * D; this.d = e * E + L * C; return; case b.TransformMode.OnlyTranslation: var m = F + 90 + J; this.a = b.MathUtils.cosDeg(F + K) * I; this.b = b.MathUtils.cosDeg(m) * H; this.c = b.MathUtils.sinDeg(F + K) * I; this.d = b.MathUtils.sinDeg(m) * H; break; case b.TransformMode.NoRotationOrReflection: var w = g * g + e * e; var j = 0; if (w > 0.0001) { w = Math.abs(g * L - f * e) / w; g /= this.skeleton.scaleX; e /= this.skeleton.scaleY; f = e * w; L = g * w; j = Math.atan2(e, g) * b.MathUtils.radDeg } else { g = 0; e = 0; j = 90 - Math.atan2(L, f) * b.MathUtils.radDeg } var l = F + K - j; var k = F + J - j + 90; var G = b.MathUtils.cosDeg(l) * I; var E = b.MathUtils.cosDeg(k) * H; var D = b.MathUtils.sinDeg(l) * I; var C = b.MathUtils.sinDeg(k) * H; this.a = g * G - f * D; this.b = g * E - f * C; this.c = e * G + L * D; this.d = e * E + L * C; break; case b.TransformMode.NoScale: case b.TransformMode.NoScaleOrReflection: var h = b.MathUtils.cosDeg(F); var d = b.MathUtils.sinDeg(F); var v = (g * h + f * d) / this.skeleton.scaleX; var o = (e * h + L * d) / this.skeleton.scaleY; var w = Math.sqrt(v * v + o * o); if (w > 0.00001) { w = 1 / w } v *= w; o *= w; w = Math.sqrt(v * v + o * o); if (this.data.transformMode == b.TransformMode.NoScale && (g * L - f * e < 0) != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)) { w = -w } var z = Math.PI / 2 + Math.atan2(o, v); var t = Math.cos(z) * w; var n = Math.sin(z) * w; var G = b.MathUtils.cosDeg(K) * I; var E = b.MathUtils.cosDeg(90 + J) * H; var D = b.MathUtils.sinDeg(K) * I; var C = b.MathUtils.sinDeg(90 + J) * H; this.a = v * G + t * D; this.b = v * E + t * C; this.c = o * G + n * D; this.d = o * E + n * C; break }this.a *= this.skeleton.scaleX; this.b *= this.skeleton.scaleX; this.c *= this.skeleton.scaleY; this.d *= this.skeleton.scaleY }; c.prototype.setToSetupPose = function () { var d = this.data; this.x = d.x; this.y = d.y; this.rotation = d.rotation; this.scaleX = d.scaleX; this.scaleY = d.scaleY; this.shearX = d.shearX; this.shearY = d.shearY }; c.prototype.getWorldRotationX = function () { return Math.atan2(this.c, this.a) * b.MathUtils.radDeg }; c.prototype.getWorldRotationY = function () { return Math.atan2(this.d, this.b) * b.MathUtils.radDeg }; c.prototype.getWorldScaleX = function () { return Math.sqrt(this.a * this.a + this.c * this.c) }; c.prototype.getWorldScaleY = function () { return Math.sqrt(this.b * this.b + this.d * this.d) }; c.prototype.updateAppliedTransform = function () { this.appliedValid = true; var p = this.parent; if (p == null) { this.ax = this.worldX; this.ay = this.worldY; this.arotation = Math.atan2(this.c, this.a) * b.MathUtils.radDeg; this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c); this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d); this.ashearX = 0; this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * b.MathUtils.radDeg; return } var q = p.a, o = p.b, n = p.c, m = p.d; var k = 1 / (q * m - o * n); var t = this.worldX - p.worldX, r = this.worldY - p.worldY; this.ax = (t * m * k - r * o * k); this.ay = (r * q * k - t * n * k); var j = k * m; var g = k * q; var i = k * o; var h = k * n; var f = j * this.a - i * this.c; var e = j * this.b - i * this.d; var d = g * this.c - h * this.a; var s = g * this.d - h * this.b; this.ashearX = 0; this.ascaleX = Math.sqrt(f * f + d * d); if (this.ascaleX > 0.0001) { var l = f * s - e * d; this.ascaleY = l / this.ascaleX; this.ashearY = Math.atan2(f * e + d * s, l) * b.MathUtils.radDeg; this.arotation = Math.atan2(d, f) * b.MathUtils.radDeg } else { this.ascaleX = 0; this.ascaleY = Math.sqrt(e * e + s * s); this.ashearY = 0; this.arotation = 90 - Math.atan2(s, e) * b.MathUtils.radDeg } }; c.prototype.worldToLocal = function (i) { var g = this.a, f = this.b, l = this.c, j = this.d; var h = 1 / (g * j - f * l); var e = i.x - this.worldX, k = i.y - this.worldY; i.x = (e * j * h - k * f * h); i.y = (k * g * h - e * l * h); return i }; c.prototype.localToWorld = function (e) { var d = e.x, f = e.y; e.x = d * this.a + f * this.b + this.worldX; e.y = d * this.c + f * this.d + this.worldY; return e }; c.prototype.worldToLocalRotation = function (d) { var e = b.MathUtils.sinDeg(d), f = b.MathUtils.cosDeg(d); return Math.atan2(this.a * e - this.c * f, this.d * f - this.b * e) * b.MathUtils.radDeg + this.rotation - this.shearX }; c.prototype.localToWorldRotation = function (f) { f -= this.rotation - this.shearX; var d = b.MathUtils.sinDeg(f), e = b.MathUtils.cosDeg(f); return Math.atan2(e * this.c + d * this.d, e * this.a + d * this.b) * b.MathUtils.radDeg }; c.prototype.rotateWorld = function (j) { var f = this.a, e = this.b, k = this.c, i = this.d; var h = b.MathUtils.cosDeg(j), g = b.MathUtils.sinDeg(j); this.a = h * f - g * k; this.b = h * e - g * i; this.c = g * f + h * k; this.d = g * e + h * i; this.appliedValid = false }; return c }()); b.Bone = a })(spine || (spine = {})); var spine; (function (b) { var c = (function () { function d(f, e, g) { this.x = 0; this.y = 0; this.rotation = 0; this.scaleX = 1; this.scaleY = 1; this.shearX = 0; this.shearY = 0; this.transformMode = a.Normal; this.skinRequired = false; this.color = new b.Color(); if (f < 0) { throw new Error("index must be >= 0.") } if (e == null) { throw new Error("name cannot be null.") } this.index = f; this.name = e; this.parent = g } return d }()); b.BoneData = c; var a; (function (d) { d[d.Normal = 0] = "Normal"; d[d.OnlyTranslation = 1] = "OnlyTranslation"; d[d.NoRotationOrReflection = 2] = "NoRotationOrReflection"; d[d.NoScale = 3] = "NoScale"; d[d.NoScaleOrReflection = 4] = "NoScaleOrReflection" })(a = b.TransformMode || (b.TransformMode = {})) })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, d, f) { this.name = e; this.order = d; this.skinRequired = f } return c }()); b.ConstraintData = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, d) { if (d == null) { throw new Error("data cannot be null.") } this.time = e; this.data = d } return c }()); b.Event = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(d) { this.name = d } return c }()); b.EventData = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, f) { this.bendDirection = 0; this.compress = false; this.stretch = false; this.mix = 1; this.softness = 0; this.active = false; if (e == null) { throw new Error("data cannot be null.") } if (f == null) { throw new Error("skeleton cannot be null.") } this.data = e; this.mix = e.mix; this.softness = e.softness; this.bendDirection = e.bendDirection; this.compress = e.compress; this.stretch = e.stretch; this.bones = new Array(); for (var d = 0; d < e.bones.length; d++) { this.bones.push(f.findBone(e.bones[d].name)) } this.target = f.findBone(e.target.name) } c.prototype.isActive = function () { return this.active }; c.prototype.apply = function () { this.update() }; c.prototype.update = function () { var e = this.target; var d = this.bones; switch (d.length) { case 1: this.apply1(d[0], e.worldX, e.worldY, this.compress, this.stretch, this.data.uniform, this.mix); break; case 2: this.apply2(d[0], d[1], e.worldX, e.worldY, this.bendDirection, this.stretch, this.softness, this.mix); break } }; c.prototype.apply1 = function (k, o, n, v, z, w, j) { if (!k.appliedValid) { k.updateAppliedTransform() } var u = k.parent; var h = u.a, g = u.b, e = u.c, G = u.d; var B = -k.ashearX - k.arotation, F = 0, E = 0; switch (k.data.transformMode) { case b.TransformMode.OnlyTranslation: F = o - k.worldX; E = n - k.worldY; break; case b.TransformMode.NoRotationOrReflection: var q = Math.abs(h * G - g * e) / (h * h + e * e); var i = h / k.skeleton.scaleX; var f = e / k.skeleton.scaleY; g = -f * q * k.skeleton.scaleX; G = i * q * k.skeleton.scaleY; B += Math.atan2(f, i) * b.MathUtils.radDeg; default: var m = o - u.worldX, l = n - u.worldY; var A = h * G - g * e; F = (m * G - l * g) / A - k.ax; E = (l * h - m * e) / A - k.ay }B += Math.atan2(E, F) * b.MathUtils.radDeg; if (k.ascaleX < 0) { B += 180 } if (B > 180) { B -= 360 } else { if (B < -180) { B += 360 } } var t = k.ascaleX, r = k.ascaleY; if (v || z) { switch (k.data.transformMode) { case b.TransformMode.NoScale: case b.TransformMode.NoScaleOrReflection: F = o - k.worldX; E = n - k.worldY }var D = k.data.length * t, C = Math.sqrt(F * F + E * E); if ((v && C < D) || (z && C > D) && D > 0.0001) { var q = (C / D - 1) * j + 1; t *= q; if (w) { r *= q } } } k.updateWorldTransformWith(k.ax, k.ay, k.arotation + B * j, t, r, k.ashearX, k.ashearY) }; c.prototype.apply2 = function (B, l, ar, ao, aq, S, ak, ah) { if (ah == 0) { l.updateWorldTransform(); return } if (!B.appliedValid) { B.updateAppliedTransform() } if (!l.appliedValid) { l.updateAppliedTransform() } var s = B.ax, o = B.ay, A = B.ascaleX, t = A, w = B.ascaleY, X = l.ascaleX; var i = 0, f = 0, am = 0; if (A < 0) { A = -A; i = 180; am = -1 } else { i = 0; am = 1 } if (w < 0) { w = -w; am = -am } if (X < 0) { X = -X; f = 180 } else { f = 0 } var N = l.ax, K = 0, O = 0, M = 0, at = B.a, ap = B.b, an = B.c, al = B.d; var aa = Math.abs(A - w) <= 0.0001; if (!aa) { K = 0; O = at * N + B.worldX; M = an * N + B.worldY } else { K = l.ay; O = at * N + ap * K + B.worldX; M = an * N + al * K + B.worldY } var C = B.parent; at = C.a; ap = C.b; an = C.c; al = C.d; var T = 1 / (at * al - ap * an), W = O - C.worldX, V = M - C.worldY; var j = (W * al - V * ap) * T - s, g = (V * at - W * an) * T - o; var z = Math.sqrt(j * j + g * g), v = l.data.length * X, af, ae; if (z < 0.0001) { this.apply1(B, ar, ao, false, S, false, ah); l.updateWorldTransformWith(N, K, 0, l.ascaleX, l.ascaleY, l.ashearX, l.ashearY); return } W = ar - C.worldX; V = ao - C.worldY; var aj = (W * al - V * ap) * T - s, ai = (V * at - W * an) * T - o; var F = aj * aj + ai * ai; if (ak != 0) { ak *= A * (X + 1) / 2; var e = Math.sqrt(F), J = e - z - v * A + ak; if (J > 0) { var ad = Math.min(1, J / (ak * 2)) - 1; ad = (J - ak * (1 - ad * ad)) / e; aj -= ad * aj; ai -= ad * ai; F = aj * aj + ai * ai } } outer: if (aa) { v *= A; var h = (F - z * z - v * v) / (2 * z * v); if (h < -1) { h = -1 } else { if (h > 1) { h = 1; if (S) { t *= (Math.sqrt(F) / (z + v) - 1) * ah + 1 } } } ae = Math.acos(h) * aq; at = z + v * h; ap = v * Math.sin(ae); af = Math.atan2(ai * at - aj * ap, aj * at + ai * ap) } else { at = A * v; ap = w * v; var G = at * at, au = ap * ap, k = Math.atan2(ai, aj); an = au * z * z + G * F - G * au; var n = -2 * au * z, m = au - G; al = n * n - 4 * m * an; if (al >= 0) { var ac = Math.sqrt(al); if (n < 0) { ac = -ac } ac = -(n + ac) / 2; var E = ac / m, D = an / ac; var ab = Math.abs(E) < Math.abs(D) ? E : D; if (ab * ab <= F) { V = Math.sqrt(F - ab * ab) * aq; af = k - Math.atan2(V, ab); ae = Math.atan2(V / w, (ab - z) / A); break outer } } var U = b.MathUtils.PI, Z = z - at, H = Z * Z, Y = 0; var ag = 0, L = z + at, P = L * L, I = 0; an = -at * z / (G - au); if (an >= -1 && an <= 1) { an = Math.acos(an); W = at * Math.cos(an) + z; V = ap * Math.sin(an); al = W * W + V * V; if (al < H) { U = an; H = al; Z = W; Y = V } if (al > P) { ag = an; P = al; L = W; I = V } } if (F <= (H + P) / 2) { af = k - Math.atan2(Y * aq, Z); ae = U * aq } else { af = k - Math.atan2(I * aq, L); ae = ag * aq } } var Q = Math.atan2(K, N) * am; var R = B.arotation; af = (af - Q) * b.MathUtils.radDeg + i - R; if (af > 180) { af -= 360 } else { if (af < -180) { af += 360 } } B.updateWorldTransformWith(s, o, R + af * ah, t, B.ascaleY, 0, 0); R = l.arotation; ae = ((ae + Q) * b.MathUtils.radDeg - l.ashearX) * am + f - R; if (ae > 180) { ae -= 360 } else { if (ae < -180) { ae += 360 } } l.updateWorldTransformWith(N, K, R + ae * ah, l.ascaleX, l.ascaleY, l.ashearX, l.ashearY) }; return c }()); b.IkConstraint = a })(spine || (spine = {})); var spine; (function (b) { var a = (function (d) { __extends(c, d); function c(e) { var f = d.call(this, e, 0, false) || this; f.bones = new Array(); f.bendDirection = 1; f.compress = false; f.stretch = false; f.uniform = false; f.mix = 1; f.softness = 0; return f } return c }(b.ConstraintData)); b.IkConstraintData = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, f) { this.position = 0; this.spacing = 0; this.rotateMix = 0; this.translateMix = 0; this.spaces = new Array(); this.positions = new Array(); this.world = new Array(); this.curves = new Array(); this.lengths = new Array(); this.segments = new Array(); this.active = false; if (e == null) { throw new Error("data cannot be null.") } if (f == null) { throw new Error("skeleton cannot be null.") } this.data = e; this.bones = new Array(); for (var d = 0, g = e.bones.length; d < g; d++) { this.bones.push(f.findBone(e.bones[d].name)) } this.target = f.findSlot(e.target.name); this.position = e.position; this.spacing = e.spacing; this.rotateMix = e.rotateMix; this.translateMix = e.translateMix } c.prototype.isActive = function () { return this.active }; c.prototype.apply = function () { this.update() }; c.prototype.update = function () { var F = this.target.getAttachment(); if (!(F instanceof b.PathAttachment)) { return } var R = this.rotateMix, T = this.translateMix; var j = T > 0, V = R > 0; if (!j && !V) { return } var Y = this.data; var e = Y.spacingMode == b.SpacingMode.Percent; var H = Y.rotateMode; var G = H == b.RotateMode.Tangent, I = H == b.RotateMode.ChainScale; var D = this.bones.length, J = G ? D : D + 1; var P = this.bones; var S = b.Utils.setArraySize(this.spaces, J), f = null; var g = this.spacing; if (I || !e) { if (I) { f = b.Utils.setArraySize(this.lengths, D) } var h = Y.spacingMode == b.SpacingMode.Length; for (var U = 0, Q = J - 1; U < Q;) { var E = P[U]; var W = E.data.length; if (W < c.epsilon) { if (I) { f[U] = 0 } S[++U] = 0 } else { if (e) { if (I) { var L = W * E.a, K = W * E.c; var C = Math.sqrt(L * L + K * K); f[U] = C } S[++U] = g } else { var L = W * E.a, K = W * E.c; var B = Math.sqrt(L * L + K * K); if (I) { f[U] = B } S[++U] = (h ? W + g : g) * B / W } } } } else { for (var U = 1; U < J; U++) { S[U] = g } } var w = this.computeWorldPositions(F, J, G, Y.positionMode == b.PositionMode.Percent, e); var u = w[0], q = w[1], o = Y.offsetRotation; var t = false; if (o == 0) { t = H == b.RotateMode.Chain } else { t = false; var O = this.target.bone; o *= O.a * O.d - O.b * O.c > 0 ? b.MathUtils.degRad : -b.MathUtils.degRad } for (var U = 0, O = 3; U < D; U++, O += 3) { var E = P[U]; E.worldX += (u - E.worldX) * T; E.worldY += (q - E.worldY) * T; var L = w[O], K = w[O + 1], m = L - u, k = K - q; if (I) { var A = f[U]; if (A != 0) { var M = (Math.sqrt(m * m + k * k) / A - 1) * R + 1; E.a *= M; E.c *= M } } u = L; q = K; if (V) { var ab = E.a, aa = E.b, Z = E.c, X = E.d, N = 0, l = 0, v = 0; if (G) { N = w[O - 1] } else { if (S[U + 1] == 0) { N = w[O + 2] } else { N = Math.atan2(k, m) } } N -= Math.atan2(Z, ab); if (t) { l = Math.cos(N); v = Math.sin(N); var z = E.data.length; u += (z * (l * ab - v * Z) - m) * R; q += (z * (v * ab + l * Z) - k) * R } else { N += o } if (N > b.MathUtils.PI) { N -= b.MathUtils.PI2 } else { if (N < -b.MathUtils.PI) { N += b.MathUtils.PI2 } } N *= R; l = Math.cos(N); v = Math.sin(N); E.a = l * ab - v * Z; E.b = l * aa - v * X; E.c = v * ab + l * Z; E.d = v * aa + l * X } E.appliedValid = false } }; c.prototype.computeWorldPositions = function (N, H, D, g, e) { var d = this.target; var J = this.position; var U = this.spaces, K = b.Utils.setArraySize(this.positions, H * 3 + 2), y = null; var L = N.closed; var aa = N.worldVerticesLength, v = aa / 6, G = c.NONE; if (!N.constantSpeed) { var f = N.lengths; v -= L ? 1 : 2; var Z = f[v]; if (g) { J *= Z } if (e) { for (var V = 1; V < H; V++) { U[V] *= Z } } y = b.Utils.setArraySize(this.world, 8); for (var V = 0, P = 0, k = 0; V < H; V++, P += 3) { var W = U[V]; J += W; var O = J; if (L) { O %= Z; if (O < 0) { O += Z } k = 0 } else { if (O < 0) { if (G != c.BEFORE) { G = c.BEFORE; N.computeWorldVertices(d, 2, 4, y, 0, 2) } this.addBeforePosition(O, y, 0, K, P); continue } else { if (O > Z) { if (G != c.AFTER) { G = c.AFTER; N.computeWorldVertices(d, aa - 6, 4, y, 0, 2) } this.addAfterPosition(O - Z, y, 0, K, P); continue } } } for (; ; k++) { var s = f[k]; if (O > s) { continue } if (k == 0) { O /= s } else { var E = f[k - 1]; O = (O - E) / (s - E) } break } if (k != G) { G = k; if (L && k == v) { N.computeWorldVertices(d, aa - 4, 4, y, 0, 2); N.computeWorldVertices(d, 0, 4, y, 4, 2) } else { N.computeWorldVertices(d, k * 6 + 2, 8, y, 0, 2) } } this.addCurvePosition(O, y[0], y[1], y[2], y[3], y[4], y[5], y[6], y[7], K, P, D || (V > 0 && W == 0)) } return K } if (L) { aa += 2; y = b.Utils.setArraySize(this.world, aa); N.computeWorldVertices(d, 2, aa - 4, y, 0, 2); N.computeWorldVertices(d, 0, 2, y, aa - 4, 2); y[aa - 2] = y[0]; y[aa - 1] = y[1] } else { v--; aa -= 4; y = b.Utils.setArraySize(this.world, aa); N.computeWorldVertices(d, 2, aa, y, 0, 2) } var h = b.Utils.setArraySize(this.curves, v); var M = 0; var u = y[0], ac = y[1], S = 0, A = 0, Q = 0, z = 0, t = 0, ab = 0; var m = 0, l = 0, C = 0, B = 0, Y = 0, X = 0, T = 0, R = 0; for (var V = 0, I = 2; V < v; V++, I += 6) { S = y[I]; A = y[I + 1]; Q = y[I + 2]; z = y[I + 3]; t = y[I + 4]; ab = y[I + 5]; m = (u - S * 2 + Q) * 0.1875; l = (ac - A * 2 + z) * 0.1875; C = ((S - Q) * 3 - u + t) * 0.09375; B = ((A - z) * 3 - ac + ab) * 0.09375; Y = m * 2 + C; X = l * 2 + B; T = (S - u) * 0.75 + m + C * 0.16666667; R = (A - ac) * 0.75 + l + B * 0.16666667; M += Math.sqrt(T * T + R * R); T += Y; R += X; Y += C; X += B; M += Math.sqrt(T * T + R * R); T += Y; R += X; M += Math.sqrt(T * T + R * R); T += Y + C; R += X + B; M += Math.sqrt(T * T + R * R); h[V] = M; u = t; ac = ab } if (g) { J *= M } else { J *= M / N.lengths[v - 1] } if (e) { for (var V = 1; V < H; V++) { U[V] *= M } } var n = this.segments; var x = 0; for (var V = 0, P = 0, k = 0, j = 0; V < H; V++, P += 3) { var W = U[V]; J += W; var O = J; if (L) { O %= M; if (O < 0) { O += M } k = 0 } else { if (O < 0) { this.addBeforePosition(O, y, 0, K, P); continue } else { if (O > M) { this.addAfterPosition(O - M, y, aa - 4, K, P); continue } } } for (; ; k++) { var r = h[k]; if (O > r) { continue } if (k == 0) { O /= r } else { var E = h[k - 1]; O = (O - E) / (r - E) } break } if (k != G) { G = k; var F = k * 6; u = y[F]; ac = y[F + 1]; S = y[F + 2]; A = y[F + 3]; Q = y[F + 4]; z = y[F + 5]; t = y[F + 6]; ab = y[F + 7]; m = (u - S * 2 + Q) * 0.03; l = (ac - A * 2 + z) * 0.03; C = ((S - Q) * 3 - u + t) * 0.006; B = ((A - z) * 3 - ac + ab) * 0.006; Y = m * 2 + C; X = l * 2 + B; T = (S - u) * 0.3 + m + C * 0.16666667; R = (A - ac) * 0.3 + l + B * 0.16666667; x = Math.sqrt(T * T + R * R); n[0] = x; for (F = 1; F < 8; F++) { T += Y; R += X; Y += C; X += B; x += Math.sqrt(T * T + R * R); n[F] = x } T += Y; R += X; x += Math.sqrt(T * T + R * R); n[8] = x; T += Y + C; R += X + B; x += Math.sqrt(T * T + R * R); n[9] = x; j = 0 } O *= x; for (; ; j++) { var q = n[j]; if (O > q) { continue } if (j == 0) { O /= q } else { var E = n[j - 1]; O = j + (O - E) / (q - E) } break } this.addCurvePosition(O * 0.1, u, ac, S, A, Q, z, t, ab, K, P, D || (V > 0 && W == 0)) } return K }; c.prototype.addBeforePosition = function (e, l, j, h, g) { var f = l[j], k = l[j + 1], n = l[j + 2] - f, m = l[j + 3] - k, d = Math.atan2(m, n); h[g] = f + e * Math.cos(d); h[g + 1] = k + e * Math.sin(d); h[g + 2] = d }; c.prototype.addAfterPosition = function (e, l, j, h, g) { var f = l[j + 2], k = l[j + 3], n = f - l[j], m = k - l[j + 1], d = Math.atan2(m, n); h[g] = f + e * Math.cos(d); h[g + 1] = k + e * Math.sin(d); h[g + 2] = d }; c.prototype.addCurvePosition = function (t, B, h, s, D, r, C, A, g, z, v, w) { if (t == 0 || isNaN(t)) { z[v] = B; z[v + 1] = h; z[v + 2] = Math.atan2(D - h, s - B); return } var d = t * t, i = d * t, n = 1 - t, j = n * n, e = j * n; var k = n * t, f = k * 3, q = n * f, E = f * t; var m = B * e + s * q + r * E + A * i, l = h * e + D * q + C * E + g * i; z[v] = m; z[v + 1] = l; if (w) { if (t < 0.001) { z[v + 2] = Math.atan2(D - h, s - B) } else { z[v + 2] = Math.atan2(l - (h * j + D * k * 2 + C * d), m - (B * j + s * k * 2 + r * d)) } } }; c.NONE = -1; c.BEFORE = -2; c.AFTER = -3; c.epsilon = 0.00001; return c }()); b.PathConstraint = a })(spine || (spine = {})); var spine; (function (c) { var e = (function (f) { __extends(g, f); function g(h) { var i = f.call(this, h, 0, false) || this; i.bones = new Array(); return i } return g }(c.ConstraintData)); c.PathConstraintData = e; var a; (function (f) { f[f.Fixed = 0] = "Fixed"; f[f.Percent = 1] = "Percent" })(a = c.PositionMode || (c.PositionMode = {})); var d; (function (f) { f[f.Length = 0] = "Length"; f[f.Fixed = 1] = "Fixed"; f[f.Percent = 2] = "Percent" })(d = c.SpacingMode || (c.SpacingMode = {})); var b; (function (f) { f[f.Tangent = 0] = "Tangent"; f[f.Chain = 1] = "Chain"; f[f.ChainScale = 2] = "ChainScale" })(b = c.RotateMode || (c.RotateMode = {})) })(spine || (spine = {})); var spine; (function (c) { var a = (function () { function d(e) { this.toLoad = new Array(); this.assets = {}; this.clientId = e } d.prototype.loaded = function () { var f = 0; for (var e in this.assets) { f++ } return f }; return d }()); var b = (function () { function d(e) { if (e === void 0) { e = "" } this.clientAssets = {}; this.queuedAssets = {}; this.rawAssets = {}; this.errors = {}; this.pathPrefix = e } d.prototype.queueAsset = function (e, f, h) { var g = this.clientAssets[e]; if (g === null || g === undefined) { g = new a(e); this.clientAssets[e] = g } if (f !== null) { g.textureLoader = f } g.toLoad.push(h); if (this.queuedAssets[h] === h) { return false } else { this.queuedAssets[h] = h; return true } }; d.prototype.loadText = function (e, g) { var h = this; g = this.pathPrefix + g; if (!this.queueAsset(e, null, g)) { return } var f = new XMLHttpRequest(); f.overrideMimeType("text/html"); f.onreadystatechange = function () { if (f.readyState == XMLHttpRequest.DONE) { if (f.status >= 200 && f.status < 300) { h.rawAssets[g] = f.responseText } else { h.errors[g] = "Couldn't load text " + g + ": status " + f.status + ", " + f.responseText } } }; f.open("GET", g, true); f.send() }; d.prototype.loadJson = function (e, g) { var h = this; g = this.pathPrefix + g; if (!this.queueAsset(e, null, g)) { return } var f = new XMLHttpRequest(); f.overrideMimeType("text/html"); f.onreadystatechange = function () { if (f.readyState == XMLHttpRequest.DONE) { if (f.status >= 200 && f.status < 300) { h.rawAssets[g] = JSON.parse(f.responseText) } else { h.errors[g] = "Couldn't load text " + g + ": status " + f.status + ", " + f.responseText } } }; f.open("GET", g, true); f.send() }; d.prototype.loadTexture = function (e, g, h) { var i = this; h = this.pathPrefix + h; if (!this.queueAsset(e, g, h)) { return } var f = new Image(); f.crossOrigin = "anonymous"; f.onload = function (j) { i.rawAssets[h] = f }; f.onerror = function (j) { i.errors[h] = "Couldn't load image " + h }; f.src = h }; d.prototype.get = function (e, g) { g = this.pathPrefix + g; var f = this.clientAssets[e]; if (f === null || f === undefined) { return true } return f.assets[g] }; d.prototype.updateClientAssets = function (j) { for (var e = 0; e < j.toLoad.length; e++) { var h = j.toLoad[e]; var g = j.assets[h]; if (g === null || g === undefined) { var f = this.rawAssets[h]; if (f === null || f === undefined) { continue } if (f instanceof HTMLImageElement) { j.assets[h] = j.textureLoader(f) } else { j.assets[h] = f } } } }; d.prototype.isLoadingComplete = function (e) { var f = this.clientAssets[e]; if (f === null || f === undefined) { return true } this.updateClientAssets(f); return f.toLoad.length == f.loaded() }; d.prototype.dispose = function () { }; d.prototype.hasErrors = function () { return Object.keys(this.errors).length > 0 }; d.prototype.getErrors = function () { return this.errors }; return d }()); c.SharedAssetManager = b })(spine || (spine = {})); var spine; (function (a) { var b = (function () { function c(h) { this._updateCache = new Array(); this.updateCacheReset = new Array(); this.time = 0; this.scaleX = 1; this.scaleY = 1; this.x = 0; this.y = 0; if (h == null) { throw new Error("data cannot be null.") } this.data = h; this.bones = new Array(); for (var j = 0; j < h.bones.length; j++) { var f = h.bones[j]; var n = void 0; if (f.parent == null) { n = new a.Bone(f, this, null) } else { var e = this.bones[f.parent.index]; n = new a.Bone(f, this, e); e.children.push(n) } this.bones.push(n) } this.slots = new Array(); this.drawOrder = new Array(); for (var j = 0; j < h.slots.length; j++) { var l = h.slots[j]; var n = this.bones[l.boneData.index]; var m = new a.Slot(l, n); this.slots.push(m); this.drawOrder.push(m) } this.ikConstraints = new Array(); for (var j = 0; j < h.ikConstraints.length; j++) { var d = h.ikConstraints[j]; this.ikConstraints.push(new a.IkConstraint(d, this)) } this.transformConstraints = new Array(); for (var j = 0; j < h.transformConstraints.length; j++) { var k = h.transformConstraints[j]; this.transformConstraints.push(new a.TransformConstraint(k, this)) } this.pathConstraints = new Array(); for (var j = 0; j < h.pathConstraints.length; j++) { var g = h.pathConstraints[j]; this.pathConstraints.push(new a.PathConstraint(g, this)) } this.color = new a.Color(1, 1, 1, 1); this.updateCache() } c.prototype.updateCache = function () { var r = this._updateCache; r.length = 0; this.updateCacheReset.length = 0; var l = this.bones; for (var p = 0, j = l.length; p < j; p++) { var s = l[p]; s.sorted = s.data.skinRequired; s.active = !s.sorted } if (this.skin != null) { var k = this.skin.bones; for (var p = 0, j = this.skin.bones.length; p < j; p++) { var s = this.bones[k[p].index]; do { s.sorted = false; s.active = true; s = s.parent } while (s != null) } } var t = this.ikConstraints; var o = this.transformConstraints; var e = this.pathConstraints; var d = t.length, m = o.length, h = e.length; var g = d + m + h; outer: for (var p = 0; p < g; p++) { for (var q = 0; q < d; q++) { var f = t[q]; if (f.data.order == p) { this.sortIkConstraint(f); continue outer } } for (var q = 0; q < m; q++) { var f = o[q]; if (f.data.order == p) { this.sortTransformConstraint(f); continue outer } } for (var q = 0; q < h; q++) { var f = e[q]; if (f.data.order == p) { this.sortPathConstraint(f); continue outer } } } for (var p = 0, j = l.length; p < j; p++) { this.sortBone(l[p]) } }; c.prototype.sortIkConstraint = function (g) { g.active = g.target.isActive() && (!g.data.skinRequired || (this.skin != null && a.Utils.contains(this.skin.constraints, g.data, true))); if (!g.active) { return } var f = g.target; this.sortBone(f); var e = g.bones; var d = e[0]; this.sortBone(d); if (e.length > 1) { var h = e[e.length - 1]; if (!(this._updateCache.indexOf(h) > -1)) { this.updateCacheReset.push(h) } } this._updateCache.push(g); this.sortReset(d.children); e[e.length - 1].sorted = true }; c.prototype.sortPathConstraint = function (d) { d.active = d.target.bone.isActive() && (!d.data.skinRequired || (this.skin != null && a.Utils.contains(this.skin.constraints, d.data, true))); if (!d.active) { return } var m = d.target; var l = m.data.index; var e = m.bone; if (this.skin != null) { this.sortPathConstraintAttachment(this.skin, l, e) } if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) { this.sortPathConstraintAttachment(this.data.defaultSkin, l, e) } for (var h = 0, f = this.data.skins.length; h < f; h++) { this.sortPathConstraintAttachment(this.data.skins[h], l, e) } var k = m.getAttachment(); if (k instanceof a.PathAttachment) { this.sortPathConstraintAttachmentWith(k, e) } var g = d.bones; var j = g.length; for (var h = 0; h < j; h++) { this.sortBone(g[h]) } this._updateCache.push(d); for (var h = 0; h < j; h++) { this.sortReset(g[h].children) } for (var h = 0; h < j; h++) { g[h].sorted = true } }; c.prototype.sortTransformConstraint = function (h) { h.active = h.target.isActive() && (!h.data.skinRequired || (this.skin != null && a.Utils.contains(this.skin.constraints, h.data, true))); if (!h.active) { return } this.sortBone(h.target); var g = h.bones; var f = g.length; if (h.data.local) { for (var d = 0; d < f; d++) { var j = g[d]; this.sortBone(j.parent); if (!(this._updateCache.indexOf(j) > -1)) { this.updateCacheReset.push(j) } } } else { for (var d = 0; d < f; d++) { this.sortBone(g[d]) } } this._updateCache.push(h); for (var e = 0; e < f; e++) { this.sortReset(g[e].children) } for (var e = 0; e < f; e++) { g[e].sorted = true } }; c.prototype.sortPathConstraintAttachment = function (h, e, g) { var d = h.attachments[e]; if (!d) { return } for (var f in d) { this.sortPathConstraintAttachmentWith(d[f], g) } }; c.prototype.sortPathConstraintAttachmentWith = function (k, h) { if (!(k instanceof a.PathAttachment)) { return } var j = k.bones; if (j == null) { this.sortBone(h) } else { var d = this.bones; var f = 0; while (f < j.length) { var g = j[f++]; for (var l = f + g; f < l; f++) { var e = j[f]; this.sortBone(d[e]) } } } }; c.prototype.sortBone = function (e) { if (e.sorted) { return } var d = e.parent; if (d != null) { this.sortBone(d) } e.sorted = true; this._updateCache.push(e) }; c.prototype.sortReset = function (d) { for (var e = 0, g = d.length; e < g; e++) { var f = d[e]; if (!f.active) { continue } if (f.sorted) { this.sortReset(f.children) } f.sorted = false } }; c.prototype.updateWorldTransform = function () { var d = this.updateCacheReset; for (var e = 0, h = d.length; e < h; e++) { var g = d[e]; g.ax = g.x; g.ay = g.y; g.arotation = g.rotation; g.ascaleX = g.scaleX; g.ascaleY = g.scaleY; g.ashearX = g.shearX; g.ashearY = g.shearY; g.appliedValid = true } var f = this._updateCache; for (var e = 0, h = f.length; e < h; e++) { f[e].update() } }; c.prototype.setToSetupPose = function () { this.setBonesToSetupPose(); this.setSlotsToSetupPose() }; c.prototype.setBonesToSetupPose = function () { var d = this.bones; for (var g = 0, l = d.length; g < l; g++) { d[g].setToSetupPose() } var h = this.ikConstraints; for (var g = 0, l = h.length; g < l; g++) { var k = h[g]; k.mix = k.data.mix; k.softness = k.data.softness; k.bendDirection = k.data.bendDirection; k.compress = k.data.compress; k.stretch = k.data.stretch } var e = this.transformConstraints; for (var g = 0, l = e.length; g < l; g++) { var k = e[g]; var j = k.data; k.rotateMix = j.rotateMix; k.translateMix = j.translateMix; k.scaleMix = j.scaleMix; k.shearMix = j.shearMix } var f = this.pathConstraints; for (var g = 0, l = f.length; g < l; g++) { var k = f[g]; var j = k.data; k.position = j.position; k.spacing = j.spacing; k.rotateMix = j.rotateMix; k.translateMix = j.translateMix } }; c.prototype.setSlotsToSetupPose = function () { var e = this.slots; a.Utils.arrayCopy(e, 0, this.drawOrder, 0, e.length); for (var d = 0, f = e.length; d < f; d++) { e[d].setToSetupPose() } }; c.prototype.getRootBone = function () { if (this.bones.length == 0) { return null } return this.bones[0] }; c.prototype.findBone = function (f) { if (f == null) { throw new Error("boneName cannot be null.") } var d = this.bones; for (var e = 0, h = d.length; e < h; e++) { var g = d[e]; if (g.data.name == f) { return g } } return null }; c.prototype.findBoneIndex = function (f) { if (f == null) { throw new Error("boneName cannot be null.") } var d = this.bones; for (var e = 0, g = d.length; e < g; e++) { if (d[e].data.name == f) { return e } } return -1 }; c.prototype.findSlot = function (d) { if (d == null) { throw new Error("slotName cannot be null.") } var f = this.slots; for (var e = 0, h = f.length; e < h; e++) { var g = f[e]; if (g.data.name == d) { return g } } return null }; c.prototype.findSlotIndex = function (d) { if (d == null) { throw new Error("slotName cannot be null.") } var f = this.slots; for (var e = 0, g = f.length; e < g; e++) { if (f[e].data.name == d) { return e } } return -1 }; c.prototype.setSkinByName = function (d) { var e = this.data.findSkin(d); if (e == null) { throw new Error("Skin not found: " + d) } this.setSkin(e) }; c.prototype.setSkin = function (g) { if (g == this.skin) { return } if (g != null) { if (this.skin != null) { g.attachAll(this, this.skin) } else { var f = this.slots; for (var e = 0, k = f.length; e < k; e++) { var j = f[e]; var d = j.data.attachmentName; if (d != null) { var h = g.getAttachment(e, d); if (h != null) { j.setAttachment(h) } } } } } this.skin = g; this.updateCache() }; c.prototype.getAttachmentByName = function (e, d) { return this.getAttachment(this.data.findSlotIndex(e), d) }; c.prototype.getAttachment = function (e, d) { if (d == null) { throw new Error("attachmentName cannot be null.") } if (this.skin != null) { var f = this.skin.getAttachment(e, d); if (f != null) { return f } } if (this.data.defaultSkin != null) { return this.data.defaultSkin.getAttachment(e, d) } return null }; c.prototype.setAttachment = function (e, d) { if (e == null) { throw new Error("slotName cannot be null.") } var g = this.slots; for (var f = 0, k = g.length; f < k; f++) { var j = g[f]; if (j.data.name == e) { var h = null; if (d != null) { h = this.getAttachment(f, d); if (h == null) { throw new Error("Attachment not found: " + d + ", for slot: " + e) } } j.setAttachment(h); return } } throw new Error("Slot not found: " + e) }; c.prototype.findIkConstraint = function (e) { if (e == null) { throw new Error("constraintName cannot be null.") } var g = this.ikConstraints; for (var f = 0, h = g.length; f < h; f++) { var d = g[f]; if (d.data.name == e) { return d } } return null }; c.prototype.findTransformConstraint = function (d) { if (d == null) { throw new Error("constraintName cannot be null.") } var e = this.transformConstraints; for (var f = 0, h = e.length; f < h; f++) { var g = e[f]; if (g.data.name == d) { return g } } return null }; c.prototype.findPathConstraint = function (d) { if (d == null) { throw new Error("constraintName cannot be null.") } var f = this.pathConstraints; for (var e = 0, h = f.length; e < h; e++) { var g = f[e]; if (g.data.name == d) { return g } } return null }; c.prototype.getBounds = function (h, p, t) { if (t === void 0) { t = new Array(2) } if (h == null) { throw new Error("offset cannot be null.") } if (p == null) { throw new Error("size cannot be null.") } var w = this.drawOrder; var z = Number.POSITIVE_INFINITY, u = Number.POSITIVE_INFINITY, v = Number.NEGATIVE_INFINITY, s = Number.NEGATIVE_INFINITY; for (var r = 0, q = w.length; r < q; r++) { var g = w[r]; if (!g.bone.active) { continue } var f = 0; var j = null; var m = g.getAttachment(); if (m instanceof a.RegionAttachment) { f = 8; j = a.Utils.setArraySize(t, f, 0); m.computeWorldVertices(g.bone, j, 0, 2) } else { if (m instanceof a.MeshAttachment) { var d = m; f = d.worldVerticesLength; j = a.Utils.setArraySize(t, f, 0); d.computeWorldVertices(g, 0, f, j, 0, 2) } } if (j != null) { for (var o = 0, e = j.length; o < e; o += 2) { var l = j[o], k = j[o + 1]; z = Math.min(z, l); u = Math.min(u, k); v = Math.max(v, l); s = Math.max(s, k) } } } h.set(z, u); p.set(v - z, s - u) }; c.prototype.update = function (d) { this.time += d }; return c }()); a.Skeleton = b })(spine || (spine = {})); var spine; (function (c) { var e = (function () { function f(g) { this.scale = 1; this.linkedMeshes = new Array(); this.attachmentLoader = g } f.prototype.readSkeletonData = function (g) { var A = this.scale; var k = new c.SkeletonData(); k.name = ""; var q = new d(g); k.hash = q.readString(); k.version = q.readString(); if ("3.8.75" == k.version) { throw new Error("Unsupported skeleton data, please export with a newer version of Spine.") } k.x = q.readFloat(); k.y = q.readFloat(); k.width = q.readFloat(); k.height = q.readFloat(); var s = q.readBoolean(); if (s) { k.fps = q.readFloat(); k.imagesPath = q.readString(); k.audioPath = q.readString() } var t = 0; t = q.readInt(true); for (var x = 0; x < t; x++) { q.strings.push(q.readString()) } t = q.readInt(true); for (var x = 0; x < t; x++) { var v = q.readString(); var m = x == 0 ? null : k.bones[q.readInt(true)]; var z = new c.BoneData(x, v, m); z.rotation = q.readFloat(); z.x = q.readFloat() * A; z.y = q.readFloat() * A; z.scaleX = q.readFloat(); z.scaleY = q.readFloat(); z.shearX = q.readFloat(); z.shearY = q.readFloat(); z.length = q.readFloat() * A; z.transformMode = f.TransformModeValues[q.readInt(true)]; z.skinRequired = q.readBoolean(); if (s) { c.Color.rgba8888ToColor(z.color, q.readInt32()) } k.bones.push(z) } t = q.readInt(true); for (var x = 0; x < t; x++) { var p = q.readString(); var o = k.bones[q.readInt(true)]; var z = new c.SlotData(x, p, o); c.Color.rgba8888ToColor(z.color, q.readInt32()); var w = q.readInt32(); if (w != -1) { c.Color.rgb888ToColor(z.darkColor = new c.Color(), w) } z.attachmentName = q.readStringRef(); z.blendMode = f.BlendModeValues[q.readInt(true)]; k.slots.push(z) } t = q.readInt(true); for (var x = 0, j = void 0; x < t; x++) { var z = new c.IkConstraintData(q.readString()); z.order = q.readInt(true); z.skinRequired = q.readBoolean(); j = q.readInt(true); for (var r = 0; r < j; r++) { z.bones.push(k.bones[q.readInt(true)]) } z.target = k.bones[q.readInt(true)]; z.mix = q.readFloat(); z.softness = q.readFloat() * A; z.bendDirection = q.readByte(); z.compress = q.readBoolean(); z.stretch = q.readBoolean(); z.uniform = q.readBoolean(); k.ikConstraints.push(z) } t = q.readInt(true); for (var x = 0, j = void 0; x < t; x++) { var z = new c.TransformConstraintData(q.readString()); z.order = q.readInt(true); z.skinRequired = q.readBoolean(); j = q.readInt(true); for (var r = 0; r < j; r++) { z.bones.push(k.bones[q.readInt(true)]) } z.target = k.bones[q.readInt(true)]; z.local = q.readBoolean(); z.relative = q.readBoolean(); z.offsetRotation = q.readFloat(); z.offsetX = q.readFloat() * A; z.offsetY = q.readFloat() * A; z.offsetScaleX = q.readFloat(); z.offsetScaleY = q.readFloat(); z.offsetShearY = q.readFloat(); z.rotateMix = q.readFloat(); z.translateMix = q.readFloat(); z.scaleMix = q.readFloat(); z.shearMix = q.readFloat(); k.transformConstraints.push(z) } t = q.readInt(true); for (var x = 0, j = void 0; x < t; x++) { var z = new c.PathConstraintData(q.readString()); z.order = q.readInt(true); z.skinRequired = q.readBoolean(); j = q.readInt(true); for (var r = 0; r < j; r++) { z.bones.push(k.bones[q.readInt(true)]) } z.target = k.slots[q.readInt(true)]; z.positionMode = f.PositionModeValues[q.readInt(true)]; z.spacingMode = f.SpacingModeValues[q.readInt(true)]; z.rotateMode = f.RotateModeValues[q.readInt(true)]; z.offsetRotation = q.readFloat(); z.position = q.readFloat(); if (z.positionMode == c.PositionMode.Fixed) { z.position *= A } z.spacing = q.readFloat(); if (z.spacingMode == c.SpacingMode.Length || z.spacingMode == c.SpacingMode.Fixed) { z.spacing *= A } z.rotateMix = q.readFloat(); z.translateMix = q.readFloat(); k.pathConstraints.push(z) } var y = this.readSkin(q, k, true, s); if (y != null) { k.defaultSkin = y; k.skins.push(y) } var x = k.skins.length; c.Utils.setArraySize(k.skins, t = x + q.readInt(true)); for (; x < t; x++) { k.skins[x] = this.readSkin(q, k, false, s) } t = this.linkedMeshes.length; for (var x = 0; x < t; x++) { var h = this.linkedMeshes[x]; var u = h.skin == null ? k.defaultSkin : k.findSkin(h.skin); if (u == null) { throw new Error("Skin not found: " + h.skin) } var l = u.getAttachment(h.slotIndex, h.parent); if (l == null) { throw new Error("Parent mesh not found: " + h.parent) } h.mesh.deformAttachment = h.inheritDeform ? l : h.mesh; h.mesh.setParentMesh(l); h.mesh.updateUVs() } this.linkedMeshes.length = 0; t = q.readInt(true); for (var x = 0; x < t; x++) { var z = new c.EventData(q.readStringRef()); z.intValue = q.readInt(false); z.floatValue = q.readFloat(); z.stringValue = q.readString(); z.audioPath = q.readString(); if (z.audioPath != null) { z.volume = q.readFloat(); z.balance = q.readFloat() } k.events.push(z) } t = q.readInt(true); for (var x = 0; x < t; x++) { k.animations.push(this.readAnimation(q, q.readString(), k)) } return k }; f.prototype.readSkin = function (q, g, r, j) { var u = null; var p = 0; if (r) { p = q.readInt(true); if (p == 0) { return null } u = new c.Skin("default") } else { u = new c.Skin(q.readStringRef()); u.bones.length = q.readInt(true); for (var k = 0, h = u.bones.length; k < h; k++) { u.bones[k] = g.bones[q.readInt(true)] } for (var k = 0, h = q.readInt(true); k < h; k++) { u.constraints.push(g.ikConstraints[q.readInt(true)]) } for (var k = 0, h = q.readInt(true); k < h; k++) { u.constraints.push(g.transformConstraints[q.readInt(true)]) } for (var k = 0, h = q.readInt(true); k < h; k++) { u.constraints.push(g.pathConstraints[q.readInt(true)]) } p = q.readInt(true) } for (var k = 0; k < p; k++) { var o = q.readInt(true); for (var s = 0, t = q.readInt(true); s < t; s++) { var m = q.readStringRef(); var l = this.readAttachment(q, g, u, o, m, j); if (l != null) { u.setAttachment(o, m, l) } } } return u }; f.prototype.readAttachment = function (l, R, u, V, N, C) { var E = this.scale; var r = l.readStringRef(); if (r == null) { r = N } var I = l.readByte(); var W = f.AttachmentTypeValues[I]; switch (W) { case c.AttachmentType.Region: var O = l.readStringRef(); var D = l.readFloat(); var L = l.readFloat(); var K = l.readFloat(); var H = l.readFloat(); var G = l.readFloat(); var g = l.readFloat(); var k = l.readFloat(); var A = l.readInt32(); if (O == null) { O = r } var U = this.attachmentLoader.newRegionAttachment(u, r, O); if (U == null) { return null } U.path = O; U.x = L * E; U.y = K * E; U.scaleX = H; U.scaleY = G; U.rotation = D; U.width = g * E; U.height = k * E; c.Color.rgba8888ToColor(U.color, A); U.updateOffset(); return U; case c.AttachmentType.BoundingBox: var T = l.readInt(true); var m = this.readVertices(l, T); var A = C ? l.readInt32() : 0; var p = this.attachmentLoader.newBoundingBoxAttachment(u, r); if (p == null) { return null } p.worldVerticesLength = T << 1; p.vertices = m.vertices; p.bones = m.bones; if (C) { c.Color.rgba8888ToColor(p.color, A) } return p; case c.AttachmentType.Mesh: var O = l.readStringRef(); var A = l.readInt32(); var T = l.readInt(true); var M = this.readFloatArray(l, T << 1, 1); var o = this.readShortArray(l); var m = this.readVertices(l, T); var j = l.readInt(true); var s = null; var g = 0, k = 0; if (C) { s = this.readShortArray(l); g = l.readFloat(); k = l.readFloat() } if (O == null) { O = r } var v = this.attachmentLoader.newMeshAttachment(u, r, O); if (v == null) { return null } v.path = O; c.Color.rgba8888ToColor(v.color, A); v.bones = m.bones; v.vertices = m.vertices; v.worldVerticesLength = T << 1; v.triangles = o; v.regionUVs = M; v.updateUVs(); v.hullLength = j << 1; if (C) { v.edges = s; v.width = g * E; v.height = k * E } return v; case c.AttachmentType.LinkedMesh: var O = l.readStringRef(); var A = l.readInt32(); var z = l.readStringRef(); var t = l.readStringRef(); var w = l.readBoolean(); var g = 0, k = 0; if (C) { g = l.readFloat(); k = l.readFloat() } if (O == null) { O = r } var v = this.attachmentLoader.newMeshAttachment(u, r, O); if (v == null) { return null } v.path = O; c.Color.rgba8888ToColor(v.color, A); if (C) { v.width = g * E; v.height = k * E } this.linkedMeshes.push(new a(v, z, V, t, w)); return v; case c.AttachmentType.Path: var q = l.readBoolean(); var P = l.readBoolean(); var T = l.readInt(true); var m = this.readVertices(l, T); var h = c.Utils.newArray(T / 3, 0); for (var S = 0, Q = h.length; S < Q; S++) { h[S] = l.readFloat() * E } var A = C ? l.readInt32() : 0; var O = this.attachmentLoader.newPathAttachment(u, r); if (O == null) { return null } O.closed = q; O.constantSpeed = P; O.worldVerticesLength = T << 1; O.vertices = m.vertices; O.bones = m.bones; O.lengths = h; if (C) { c.Color.rgba8888ToColor(O.color, A) } return O; case c.AttachmentType.Point: var D = l.readFloat(); var L = l.readFloat(); var K = l.readFloat(); var A = C ? l.readInt32() : 0; var F = this.attachmentLoader.newPointAttachment(u, r); if (F == null) { return null } F.x = L * E; F.y = K * E; F.rotation = D; if (C) { c.Color.rgba8888ToColor(F.color, A) } return F; case c.AttachmentType.Clipping: var B = l.readInt(true); var T = l.readInt(true); var m = this.readVertices(l, T); var A = C ? l.readInt32() : 0; var J = this.attachmentLoader.newClippingAttachment(u, r); if (J == null) { return null } J.endSlot = R.slots[B]; J.worldVerticesLength = T << 1; J.vertices = m.vertices; J.bones = m.bones; if (C) { c.Color.rgba8888ToColor(J.color, A) } return J }return null }; f.prototype.readVertices = function (o, g) { var p = g << 1; var m = new b(); var j = this.scale; if (!o.readBoolean()) { m.vertices = this.readFloatArray(o, p, j); return m } var n = new Array(); var h = new Array(); for (var k = 0; k < g; k++) { var l = o.readInt(true); h.push(l); for (var q = 0; q < l; q++) { h.push(o.readInt(true)); n.push(o.readFloat() * j); n.push(o.readFloat() * j); n.push(o.readFloat()) } } m.vertices = c.Utils.toFloatArray(n); m.bones = h; return m }; f.prototype.readFloatArray = function (g, l, j) { var k = new Array(l); if (j == 1) { for (var h = 0; h < l; h++) { k[h] = g.readFloat() } } else { for (var h = 0; h < l; h++) { k[h] = g.readFloat() * j } } return k }; f.prototype.readShortArray = function (g) { var k = g.readInt(true); var j = new Array(k); for (var h = 0; h < k; h++) { j[h] = g.readShort() } return j }; f.prototype.readAnimation = function (g, r, T) { var M = new Array(); var H = this.scale; var D = 0; var X = new c.Color(); var W = new c.Color(); for (var V = 0, S = g.readInt(true); V < S; V++) { var aa = g.readInt(true); for (var I = 0, Z = g.readInt(true); I < Z; I++) { var N = g.readByte(); var s = g.readInt(true); switch (N) { case f.SLOT_ATTACHMENT: var o = new c.AttachmentTimeline(s); o.slotIndex = aa; for (var k = 0; k < s; k++) { o.setFrame(k, g.readFloat(), g.readStringRef()) } M.push(o); D = Math.max(D, o.frames[s - 1]); break; case f.SLOT_COLOR: var o = new c.ColorTimeline(s); o.slotIndex = aa; for (var k = 0; k < s; k++) { var R = g.readFloat(); c.Color.rgba8888ToColor(X, g.readInt32()); o.setFrame(k, R, X.r, X.g, X.b, X.a); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[(s - 1) * c.ColorTimeline.ENTRIES]); break; case f.SLOT_TWO_COLOR: var o = new c.TwoColorTimeline(s); o.slotIndex = aa; for (var k = 0; k < s; k++) { var R = g.readFloat(); c.Color.rgba8888ToColor(X, g.readInt32()); c.Color.rgb888ToColor(W, g.readInt32()); o.setFrame(k, R, X.r, X.g, X.b, X.a, W.r, W.g, W.b); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[(s - 1) * c.TwoColorTimeline.ENTRIES]); break } } } for (var V = 0, S = g.readInt(true); V < S; V++) { var q = g.readInt(true); for (var I = 0, Z = g.readInt(true); I < Z; I++) { var N = g.readByte(); var s = g.readInt(true); switch (N) { case f.BONE_ROTATE: var o = new c.RotateTimeline(s); o.boneIndex = q; for (var k = 0; k < s; k++) { o.setFrame(k, g.readFloat(), g.readFloat()); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[(s - 1) * c.RotateTimeline.ENTRIES]); break; case f.BONE_TRANSLATE: case f.BONE_SCALE: case f.BONE_SHEAR: var o = void 0; var A = 1; if (N == f.BONE_SCALE) { o = new c.ScaleTimeline(s) } else { if (N == f.BONE_SHEAR) { o = new c.ShearTimeline(s) } else { o = new c.TranslateTimeline(s); A = H } } o.boneIndex = q; for (var k = 0; k < s; k++) { o.setFrame(k, g.readFloat(), g.readFloat() * A, g.readFloat() * A); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[(s - 1) * c.TranslateTimeline.ENTRIES]); break } } } for (var V = 0, S = g.readInt(true); V < S; V++) { var G = g.readInt(true); var s = g.readInt(true); var o = new c.IkConstraintTimeline(s); o.ikConstraintIndex = G; for (var k = 0; k < s; k++) { o.setFrame(k, g.readFloat(), g.readFloat(), g.readFloat() * H, g.readByte(), g.readBoolean(), g.readBoolean()); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[(s - 1) * c.IkConstraintTimeline.ENTRIES]) } for (var V = 0, S = g.readInt(true); V < S; V++) { var G = g.readInt(true); var s = g.readInt(true); var o = new c.TransformConstraintTimeline(s); o.transformConstraintIndex = G; for (var k = 0; k < s; k++) { o.setFrame(k, g.readFloat(), g.readFloat(), g.readFloat(), g.readFloat(), g.readFloat()); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[(s - 1) * c.TransformConstraintTimeline.ENTRIES]) } for (var V = 0, S = g.readInt(true); V < S; V++) { var G = g.readInt(true); var Y = T.pathConstraints[G]; for (var I = 0, Z = g.readInt(true); I < Z; I++) { var N = g.readByte(); var s = g.readInt(true); switch (N) { case f.PATH_POSITION: case f.PATH_SPACING: var o = void 0; var A = 1; if (N == f.PATH_SPACING) { o = new c.PathConstraintSpacingTimeline(s); if (Y.spacingMode == c.SpacingMode.Length || Y.spacingMode == c.SpacingMode.Fixed) { A = H } } else { o = new c.PathConstraintPositionTimeline(s); if (Y.positionMode == c.PositionMode.Fixed) { A = H } } o.pathConstraintIndex = G; for (var k = 0; k < s; k++) { o.setFrame(k, g.readFloat(), g.readFloat() * A); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[(s - 1) * c.PathConstraintPositionTimeline.ENTRIES]); break; case f.PATH_MIX: var o = new c.PathConstraintMixTimeline(s); o.pathConstraintIndex = G; for (var k = 0; k < s; k++) { o.setFrame(k, g.readFloat(), g.readFloat(), g.readFloat()); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[(s - 1) * c.PathConstraintMixTimeline.ENTRIES]); break } } } for (var V = 0, S = g.readInt(true); V < S; V++) { var x = T.skins[g.readInt(true)]; for (var I = 0, Z = g.readInt(true); I < Z; I++) { var aa = g.readInt(true); for (var z = 0, p = g.readInt(true); z < p; z++) { var y = x.getAttachment(aa, g.readStringRef()); var Q = y.bones != null; var j = y.vertices; var E = Q ? j.length / 3 * 2 : j.length; var s = g.readInt(true); var o = new c.DeformTimeline(s); o.slotIndex = aa; o.attachment = y; for (var k = 0; k < s; k++) { var R = g.readFloat(); var K = void 0; var u = g.readInt(true); if (u == 0) { K = Q ? c.Utils.newFloatArray(E) : j } else { K = c.Utils.newFloatArray(E); var B = g.readInt(true); u += B; if (H == 1) { for (var O = B; O < u; O++) { K[O] = g.readFloat() } } else { for (var O = B; O < u; O++) { K[O] = g.readFloat() * H } } if (!Q) { for (var O = 0, t = K.length; O < t; O++) { K[O] += j[O] } } } o.setFrame(k, R, K); if (k < s - 1) { this.readCurve(g, k, o) } } M.push(o); D = Math.max(D, o.frames[s - 1]) } } } var F = g.readInt(true); if (F > 0) { var o = new c.DrawOrderTimeline(F); var m = T.slots.length; for (var V = 0; V < F; V++) { var R = g.readFloat(); var P = g.readInt(true); var J = c.Utils.newArray(m, 0); for (var I = m - 1; I >= 0; I--) { J[I] = -1 } var h = c.Utils.newArray(m - P, 0); var l = 0, C = 0; for (var I = 0; I < P; I++) { var aa = g.readInt(true); while (l != aa) { h[C++] = l++ } J[l + g.readInt(true)] = l++ } while (l < m) { h[C++] = l++ } for (var I = m - 1; I >= 0; I--) { if (J[I] == -1) { J[I] = h[--C] } } o.setFrame(V, R, J) } M.push(o); D = Math.max(D, o.frames[F - 1]) } var U = g.readInt(true); if (U > 0) { var o = new c.EventTimeline(U); for (var V = 0; V < U; V++) { var R = g.readFloat(); var w = T.events[g.readInt(true)]; var L = new c.Event(R, w); L.intValue = g.readInt(false); L.floatValue = g.readFloat(); L.stringValue = g.readBoolean() ? g.readString() : w.stringValue; if (L.data.audioPath != null) { L.volume = g.readFloat(); L.balance = g.readFloat() } o.setFrame(V, L) } M.push(o); D = Math.max(D, o.frames[U - 1]) } return new c.Animation(r, M, D) }; f.prototype.readCurve = function (g, i, h) { switch (g.readByte()) { case f.CURVE_STEPPED: h.setStepped(i); break; case f.CURVE_BEZIER: this.setCurve(h, i, g.readFloat(), g.readFloat(), g.readFloat(), g.readFloat()); break } }; f.prototype.setCurve = function (k, l, h, j, g, i) { k.setCurve(l, h, j, g, i) }; f.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6]; f.TransformModeValues = [c.TransformMode.Normal, c.TransformMode.OnlyTranslation, c.TransformMode.NoRotationOrReflection, c.TransformMode.NoScale, c.TransformMode.NoScaleOrReflection]; f.PositionModeValues = [c.PositionMode.Fixed, c.PositionMode.Percent]; f.SpacingModeValues = [c.SpacingMode.Length, c.SpacingMode.Fixed, c.SpacingMode.Percent]; f.RotateModeValues = [c.RotateMode.Tangent, c.RotateMode.Chain, c.RotateMode.ChainScale]; f.BlendModeValues = [c.BlendMode.Normal, c.BlendMode.Additive, c.BlendMode.Multiply, c.BlendMode.Screen]; f.BONE_ROTATE = 0; f.BONE_TRANSLATE = 1; f.BONE_SCALE = 2; f.BONE_SHEAR = 3; f.SLOT_ATTACHMENT = 0; f.SLOT_COLOR = 1; f.SLOT_TWO_COLOR = 2; f.PATH_POSITION = 0; f.PATH_SPACING = 1; f.PATH_MIX = 2; f.CURVE_LINEAR = 0; f.CURVE_STEPPED = 1; f.CURVE_BEZIER = 2; return f }()); c.SkeletonBinary = e; var d = (function () { function f(j, g, i, h) { if (g === void 0) { g = new Array() } if (i === void 0) { i = 0 } if (h === void 0) { h = new DataView(j.buffer) } this.strings = g; this.index = i; this.buffer = h } f.prototype.readByte = function () { return this.buffer.getInt8(this.index++) }; f.prototype.readShort = function () { var g = this.buffer.getInt16(this.index); this.index += 2; return g }; f.prototype.readInt32 = function () { var g = this.buffer.getInt32(this.index); this.index += 4; return g }; f.prototype.readInt = function (i) { var h = this.readByte(); var g = h & 127; if ((h & 128) != 0) { h = this.readByte(); g |= (h & 127) << 7; if ((h & 128) != 0) { h = this.readByte(); g |= (h & 127) << 14; if ((h & 128) != 0) { h = this.readByte(); g |= (h & 127) << 21; if ((h & 128) != 0) { h = this.readByte(); g |= (h & 127) << 28 } } } } return i ? g : ((g >>> 1) ^ -(g & 1)) }; f.prototype.readStringRef = function () { var g = this.readInt(true); return g == 0 ? null : this.strings[g - 1] }; f.prototype.readString = function () { var l = this.readInt(true); switch (l) { case 0: return null; case 1: return "" }l--; var k = ""; var h = 0; for (var j = 0; j < l;) { var g = this.readByte(); switch (g >> 4) { case 12: case 13: k += String.fromCharCode(((g & 31) << 6 | this.readByte() & 63)); j += 2; break; case 14: k += String.fromCharCode(((g & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63)); j += 3; break; default: k += String.fromCharCode(g); j++ } } return k }; f.prototype.readFloat = function () { var g = this.buffer.getFloat32(this.index); this.index += 4; return g }; f.prototype.readBoolean = function () { return this.readByte() != 0 }; return f }()); var a = (function () { function f(k, j, h, i, g) { this.mesh = k; this.skin = j; this.slotIndex = h; this.parent = i; this.inheritDeform = g } return f }()); var b = (function () { function f(g, h) { if (g === void 0) { g = null } if (h === void 0) { h = null } this.bones = g; this.vertices = h } return f }()) })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c() { this.minX = 0; this.minY = 0; this.maxX = 0; this.maxY = 0; this.boundingBoxes = new Array(); this.polygons = new Array(); this.polygonPool = new b.Pool(function () { return b.Utils.newFloatArray(16) }) } c.prototype.update = function (e, m) { if (e == null) { throw new Error("skeleton cannot be null.") } var d = this.boundingBoxes; var o = this.polygons; var k = this.polygonPool; var l = e.slots; var j = l.length; d.length = 0; k.freeAll(o); o.length = 0; for (var g = 0; g < j; g++) { var p = l[g]; if (!p.bone.active) { continue } var h = p.getAttachment(); if (h instanceof b.BoundingBoxAttachment) { var f = h; d.push(f); var n = k.obtain(); if (n.length != f.worldVerticesLength) { n = b.Utils.newFloatArray(f.worldVerticesLength) } o.push(n); f.computeWorldVertices(p, 0, f.worldVerticesLength, n, 0, 2) } } if (m) { this.aabbCompute() } else { this.minX = Number.POSITIVE_INFINITY; this.minY = Number.POSITIVE_INFINITY; this.maxX = Number.NEGATIVE_INFINITY; this.maxY = Number.NEGATIVE_INFINITY } }; c.prototype.aabbCompute = function () { var h = Number.POSITIVE_INFINITY, g = Number.POSITIVE_INFINITY, e = Number.NEGATIVE_INFINITY, d = Number.NEGATIVE_INFINITY; var p = this.polygons; for (var j = 0, f = p.length; j < f; j++) { var o = p[j]; var k = o; for (var q = 0, r = o.length; q < r; q += 2) { var m = k[q]; var l = k[q + 1]; h = Math.min(h, m); g = Math.min(g, l); e = Math.max(e, m); d = Math.max(d, l) } } this.minX = h; this.minY = g; this.maxX = e; this.maxY = d }; c.prototype.aabbContainsPoint = function (d, e) { return d >= this.minX && d <= this.maxX && e >= this.minY && e <= this.maxY }; c.prototype.aabbIntersectsSegment = function (g, o, f, l) { var j = this.minX; var i = this.minY; var e = this.maxX; var d = this.maxY; if ((g <= j && f <= j) || (o <= i && l <= i) || (g >= e && f >= e) || (o >= d && l >= d)) { return false } var h = (l - o) / (f - g); var k = h * (j - g) + o; if (k > i && k < d) { return true } k = h * (e - g) + o; if (k > i && k < d) { return true } var n = (i - o) / h + g; if (n > j && n < e) { return true } n = (d - o) / h + g; if (n > j && n < e) { return true } return false }; c.prototype.aabbIntersectsSkeleton = function (d) { return this.minX < d.maxX && this.maxX > d.minX && this.minY < d.maxY && this.maxY > d.minY }; c.prototype.containsPoint = function (d, h) { var e = this.polygons; for (var f = 0, g = e.length; f < g; f++) { if (this.containsPointPolygon(e[f], d, h)) { return this.boundingBoxes[f] } } return null }; c.prototype.containsPointPolygon = function (k, l, j) { var i = k; var n = k.length; var f = n - 2; var g = false; for (var m = 0; m < n; m += 2) { var d = i[m + 1]; var h = i[f + 1]; if ((d < j && h >= j) || (h < j && d >= j)) { var e = i[m]; if (e + (j - d) / (h - d) * (i[f] - e) < l) { g = !g } } f = m } return g }; c.prototype.intersectsSegment = function (f, j, e, h) { var d = this.polygons; for (var g = 0, k = d.length; g < k; g++) { if (this.intersectsSegmentPolygon(d[g], f, j, e, h)) { return this.boundingBoxes[g] } } return null }; c.prototype.intersectsSegmentPolygon = function (q, z, i, v, h) { var m = q; var e = q.length; var w = z - v, g = i - h; var l = z * h - i * v; var u = m[e - 2], f = m[e - 1]; for (var r = 0; r < e; r += 2) { var t = m[r], d = m[r + 1]; var k = u * d - f * t; var p = u - t, s = f - d; var j = w * s - g * p; var o = (l * p - w * k) / j; if (((o >= u && o <= t) || (o >= t && o <= u)) && ((o >= z && o <= v) || (o >= v && o <= z))) { var n = (l * s - g * k) / j; if (((n >= f && n <= d) || (n >= d && n <= f)) && ((n >= i && n <= h) || (n >= h && n <= i))) { return true } } u = t; f = d } return false }; c.prototype.getPolygon = function (e) { if (e == null) { throw new Error("boundingBox cannot be null.") } var d = this.boundingBoxes.indexOf(e); return d == -1 ? null : this.polygons[d] }; c.prototype.getWidth = function () { return this.maxX - this.minX }; c.prototype.getHeight = function () { return this.maxY - this.minY }; return c }()); b.SkeletonBounds = a })(spine || (spine = {})); var spine; (function (a) { var b = (function () { function c() { this.triangulator = new a.Triangulator(); this.clippingPolygon = new Array(); this.clipOutput = new Array(); this.clippedVertices = new Array(); this.clippedTriangles = new Array(); this.scratch = new Array() } c.prototype.clipStart = function (m, f) { if (this.clipAttachment != null) { return 0 } this.clipAttachment = f; var d = f.worldVerticesLength; var j = a.Utils.setArraySize(this.clippingPolygon, d); f.computeWorldVertices(m, 0, d, j, 0, 2); var e = this.clippingPolygon; c.makeClockwise(e); var h = this.clippingPolygons = this.triangulator.decompose(e, this.triangulator.triangulate(e)); for (var g = 0, k = h.length; g < k; g++) { var l = h[g]; c.makeClockwise(l); l.push(l[0]); l.push(l[1]) } return h.length }; c.prototype.clipEndWithSlot = function (d) { if (this.clipAttachment != null && this.clipAttachment.endSlot == d.data) { this.clipEnd() } }; c.prototype.clipEnd = function () { if (this.clipAttachment == null) { return } this.clipAttachment = null; this.clippingPolygons = null; this.clippedVertices.length = 0; this.clippedTriangles.length = 0; this.clippingPolygon.length = 0 }; c.prototype.isClipping = function () { return this.clipAttachment != null }; c.prototype.clipTriangles = function (g, Y, k, B, K, A, C, U) { var f = this.clipOutput, u = this.clippedVertices; var e = this.clippedTriangles; var ae = this.clippingPolygons; var z = this.clippingPolygons.length; var j = U ? 12 : 8; var E = 0; u.length = 0; e.length = 0; outer: for (var R = 0; R < B; R += 3) { var n = k[R] << 1; var w = g[n], af = g[n + 1]; var r = K[n], ab = K[n + 1]; n = k[R + 1] << 1; var v = g[n], ad = g[n + 1]; var q = K[n], Z = K[n + 1]; n = k[R + 2] << 1; var t = g[n], ac = g[n + 1]; var o = K[n], V = K[n + 1]; for (var N = 0; N < z; N++) { var L = u.length; if (this.clip(w, af, v, ad, t, ac, ae[N], f)) { var h = f.length; if (h == 0) { continue } var Q = ad - ac, P = t - v, O = w - t, M = ac - af; var S = 1 / (Q * O + P * (af - ac)); var X = h >> 1; var D = this.clipOutput; var J = a.Utils.setArraySize(u, L + X * j); for (var F = 0; F < h; F += 2) { var I = D[F], H = D[F + 1]; J[L] = I; J[L + 1] = H; J[L + 2] = A.r; J[L + 3] = A.g; J[L + 4] = A.b; J[L + 5] = A.a; var m = I - t, l = H - ac; var aa = (Q * m + P * l) * S; var W = (M * m + O * l) * S; var T = 1 - aa - W; J[L + 6] = r * aa + q * W + o * T; J[L + 7] = ab * aa + Z * W + V * T; if (U) { J[L + 8] = C.r; J[L + 9] = C.g; J[L + 10] = C.b; J[L + 11] = C.a } L += j } L = e.length; var G = a.Utils.setArraySize(e, L + 3 * (X - 2)); X--; for (var F = 1; F < X; F++) { G[L] = E; G[L + 1] = (E + F); G[L + 2] = (E + F + 1); L += 3 } E += X + 1 } else { var J = a.Utils.setArraySize(u, L + 3 * j); J[L] = w; J[L + 1] = af; J[L + 2] = A.r; J[L + 3] = A.g; J[L + 4] = A.b; J[L + 5] = A.a; if (!U) { J[L + 6] = r; J[L + 7] = ab; J[L + 8] = v; J[L + 9] = ad; J[L + 10] = A.r; J[L + 11] = A.g; J[L + 12] = A.b; J[L + 13] = A.a; J[L + 14] = q; J[L + 15] = Z; J[L + 16] = t; J[L + 17] = ac; J[L + 18] = A.r; J[L + 19] = A.g; J[L + 20] = A.b; J[L + 21] = A.a; J[L + 22] = o; J[L + 23] = V } else { J[L + 6] = r; J[L + 7] = ab; J[L + 8] = C.r; J[L + 9] = C.g; J[L + 10] = C.b; J[L + 11] = C.a; J[L + 12] = v; J[L + 13] = ad; J[L + 14] = A.r; J[L + 15] = A.g; J[L + 16] = A.b; J[L + 17] = A.a; J[L + 18] = q; J[L + 19] = Z; J[L + 20] = C.r; J[L + 21] = C.g; J[L + 22] = C.b; J[L + 23] = C.a; J[L + 24] = t; J[L + 25] = ac; J[L + 26] = A.r; J[L + 27] = A.g; J[L + 28] = A.b; J[L + 29] = A.a; J[L + 30] = o; J[L + 31] = V; J[L + 32] = C.r; J[L + 33] = C.g; J[L + 34] = C.b; J[L + 35] = C.a } L = e.length; var G = a.Utils.setArraySize(e, L + 3); G[L] = E; G[L + 1] = (E + 1); G[L + 2] = (E + 2); E += 3; continue outer } } } }; c.prototype.clip = function (J, h, I, g, H, f, m, p) { var u = p; var d = false; var t = null; if (m.length % 4 >= 2) { t = p; p = this.scratch } else { t = this.scratch } t.length = 0; t.push(J); t.push(h); t.push(I); t.push(g); t.push(H); t.push(f); t.push(J); t.push(h); p.length = 0; var o = m; var L = m.length - 4; for (var G = 0; ; G += 2) { var C = o[G], B = o[G + 1]; var j = o[G + 2], r = o[G + 3]; var O = C - j, N = B - r; var q = t; var e = t.length - 2, x = p.length; for (var v = 0; v < e; v += 2) { var E = q[v], D = q[v + 1]; var K = q[v + 2], k = q[v + 3]; var l = O * (k - r) - N * (K - j) > 0; if (O * (D - r) - N * (E - j) > 0) { if (l) { p.push(K); p.push(k); continue } var A = k - D, y = K - E; var w = A * (j - C) - y * (r - B); if (Math.abs(w) > 0.000001) { var F = (y * (B - D) - A * (C - E)) / w; p.push(C + (j - C) * F); p.push(B + (r - B) * F) } else { p.push(C); p.push(B) } } else { if (l) { var A = k - D, y = K - E; var w = A * (j - C) - y * (r - B); if (Math.abs(w) > 0.000001) { var F = (y * (B - D) - A * (C - E)) / w; p.push(C + (j - C) * F); p.push(B + (r - B) * F) } else { p.push(C); p.push(B) } p.push(K); p.push(k) } } d = true } if (x == p.length) { u.length = 0; return true } p.push(p[0]); p.push(p[1]); if (G == L) { break } var M = p; p = t; p.length = 0; t = M } if (u != p) { u.length = 0; for (var G = 0, z = p.length - 2; G < z; G++) { u[G] = p[G] } } else { u.length = u.length - 2 } return d }; c.makeClockwise = function (r) { var l = r; var s = r.length; var g = l[s - 2] * l[1] - l[0] * l[s - 1], e = 0, d = 0, p = 0, m = 0; for (var j = 0, h = s - 3; j < h; j += 2) { e = l[j]; d = l[j + 1]; p = l[j + 2]; m = l[j + 3]; g += e * m - p * d } if (g < 0) { return } for (var j = 0, f = s - 2, h = s >> 1; j < h; j += 2) { var q = l[j], o = l[j + 1]; var k = f - j; l[j] = l[k]; l[j + 1] = l[k + 1]; l[k] = q; l[k + 1] = o } }; return c }()); a.SkeletonClipping = b })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c() { this.bones = new Array(); this.slots = new Array(); this.skins = new Array(); this.events = new Array(); this.animations = new Array(); this.ikConstraints = new Array(); this.transformConstraints = new Array(); this.pathConstraints = new Array(); this.fps = 0 } c.prototype.findBone = function (f) { if (f == null) { throw new Error("boneName cannot be null.") } var d = this.bones; for (var e = 0, h = d.length; e < h; e++) { var g = d[e]; if (g.name == f) { return g } } return null }; c.prototype.findBoneIndex = function (f) { if (f == null) { throw new Error("boneName cannot be null.") } var d = this.bones; for (var e = 0, g = d.length; e < g; e++) { if (d[e].name == f) { return e } } return -1 }; c.prototype.findSlot = function (d) { if (d == null) { throw new Error("slotName cannot be null.") } var f = this.slots; for (var e = 0, h = f.length; e < h; e++) { var g = f[e]; if (g.name == d) { return g } } return null }; c.prototype.findSlotIndex = function (d) { if (d == null) { throw new Error("slotName cannot be null.") } var f = this.slots; for (var e = 0, g = f.length; e < g; e++) { if (f[e].name == d) { return e } } return -1 }; c.prototype.findSkin = function (d) { if (d == null) { throw new Error("skinName cannot be null.") } var g = this.skins; for (var e = 0, h = g.length; e < h; e++) { var f = g[e]; if (f.name == d) { return f } } return null }; c.prototype.findEvent = function (f) { if (f == null) { throw new Error("eventDataName cannot be null.") } var e = this.events; for (var d = 0, h = e.length; d < h; d++) { var g = e[d]; if (g.name == f) { return g } } return null }; c.prototype.findAnimation = function (e) { if (e == null) { throw new Error("animationName cannot be null.") } var h = this.animations; for (var d = 0, g = h.length; d < g; d++) { var f = h[d]; if (f.name == e) { return f } } return null }; c.prototype.findIkConstraint = function (d) { if (d == null) { throw new Error("constraintName cannot be null.") } var f = this.ikConstraints; for (var e = 0, h = f.length; e < h; e++) { var g = f[e]; if (g.name == d) { return g } } return null }; c.prototype.findTransformConstraint = function (d) { if (d == null) { throw new Error("constraintName cannot be null.") } var e = this.transformConstraints; for (var f = 0, h = e.length; f < h; f++) { var g = e[f]; if (g.name == d) { return g } } return null }; c.prototype.findPathConstraint = function (d) { if (d == null) { throw new Error("constraintName cannot be null.") } var f = this.pathConstraints; for (var e = 0, h = f.length; e < h; e++) { var g = f[e]; if (g.name == d) { return g } } return null }; c.prototype.findPathConstraintIndex = function (f) { if (f == null) { throw new Error("pathConstraintName cannot be null.") } var e = this.pathConstraints; for (var d = 0, g = e.length; d < g; d++) { if (e[d].name == f) { return d } } return -1 }; return c }()); b.SkeletonData = a })(spine || (spine = {})); var spine; (function (c) { var b = (function () { function d(e) { this.scale = 1; this.linkedMeshes = new Array(); this.attachmentLoader = e } d.prototype.readSkeletonData = function (L) { var O = this.scale; var m = new c.SkeletonData(); var E = typeof (L) === "string" ? JSON.parse(L) : L; var k = E.skeleton; if (k != null) { m.hash = k.hash; m.version = k.spine; if ("3.8.75" == m.version) { throw new Error("Unsupported skeleton data, please export with a newer version of Spine.") } m.x = k.x; m.y = k.y; m.width = k.width; m.height = k.height; m.fps = k.fps; m.imagesPath = k.images } if (E.bones) { for (var J = 0; J < E.bones.length; J++) { var M = E.bones[J]; var q = null; var F = this.getValue(M, "parent", null); if (F != null) { q = m.findBone(F); if (q == null) { throw new Error("Parent bone not found: " + F) } } var N = new c.BoneData(m.bones.length, M.name, q); N.length = this.getValue(M, "length", 0) * O; N.x = this.getValue(M, "x", 0) * O; N.y = this.getValue(M, "y", 0) * O; N.rotation = this.getValue(M, "rotation", 0); N.scaleX = this.getValue(M, "scaleX", 1); N.scaleY = this.getValue(M, "scaleY", 1); N.shearX = this.getValue(M, "shearX", 0); N.shearY = this.getValue(M, "shearY", 0); N.transformMode = d.transformModeFromString(this.getValue(M, "transform", "normal")); N.skinRequired = this.getValue(M, "skin", false); m.bones.push(N) } } if (E.slots) { for (var J = 0; J < E.slots.length; J++) { var K = E.slots[J]; var u = K.name; var t = K.bone; var s = m.findBone(t); if (s == null) { throw new Error("Slot bone not found: " + t) } var N = new c.SlotData(m.slots.length, u, s); var H = this.getValue(K, "color", null); if (H != null) { N.color.setFromString(H) } var g = this.getValue(K, "dark", null); if (g != null) { N.darkColor = new c.Color(1, 1, 1, 1); N.darkColor.setFromString(g) } N.attachmentName = this.getValue(K, "attachment", null); N.blendMode = d.blendModeFromString(this.getValue(K, "blend", "normal")); m.slots.push(N) } } if (E.ik) { for (var J = 0; J < E.ik.length; J++) { var y = E.ik[J]; var N = new c.IkConstraintData(y.name); N.order = this.getValue(y, "order", 0); N.skinRequired = this.getValue(y, "skin", false); for (var I = 0; I < y.bones.length; I++) { var t = y.bones[I]; var r = m.findBone(t); if (r == null) { throw new Error("IK bone not found: " + t) } N.bones.push(r) } var B = y.target; N.target = m.findBone(B); if (N.target == null) { throw new Error("IK target bone not found: " + B) } N.mix = this.getValue(y, "mix", 1); N.softness = this.getValue(y, "softness", 0) * O; N.bendDirection = this.getValue(y, "bendPositive", true) ? 1 : -1; N.compress = this.getValue(y, "compress", false); N.stretch = this.getValue(y, "stretch", false); N.uniform = this.getValue(y, "uniform", false); m.ikConstraints.push(N) } } if (E.transform) { for (var J = 0; J < E.transform.length; J++) { var y = E.transform[J]; var N = new c.TransformConstraintData(y.name); N.order = this.getValue(y, "order", 0); N.skinRequired = this.getValue(y, "skin", false); for (var I = 0; I < y.bones.length; I++) { var t = y.bones[I]; var r = m.findBone(t); if (r == null) { throw new Error("Transform constraint bone not found: " + t) } N.bones.push(r) } var B = y.target; N.target = m.findBone(B); if (N.target == null) { throw new Error("Transform constraint target bone not found: " + B) } N.local = this.getValue(y, "local", false); N.relative = this.getValue(y, "relative", false); N.offsetRotation = this.getValue(y, "rotation", 0); N.offsetX = this.getValue(y, "x", 0) * O; N.offsetY = this.getValue(y, "y", 0) * O; N.offsetScaleX = this.getValue(y, "scaleX", 0); N.offsetScaleY = this.getValue(y, "scaleY", 0); N.offsetShearY = this.getValue(y, "shearY", 0); N.rotateMix = this.getValue(y, "rotateMix", 1); N.translateMix = this.getValue(y, "translateMix", 1); N.scaleMix = this.getValue(y, "scaleMix", 1); N.shearMix = this.getValue(y, "shearMix", 1); m.transformConstraints.push(N) } } if (E.path) { for (var J = 0; J < E.path.length; J++) { var y = E.path[J]; var N = new c.PathConstraintData(y.name); N.order = this.getValue(y, "order", 0); N.skinRequired = this.getValue(y, "skin", false); for (var I = 0; I < y.bones.length; I++) { var t = y.bones[I]; var r = m.findBone(t); if (r == null) { throw new Error("Transform constraint bone not found: " + t) } N.bones.push(r) } var B = y.target; N.target = m.findSlot(B); if (N.target == null) { throw new Error("Path target slot not found: " + B) } N.positionMode = d.positionModeFromString(this.getValue(y, "positionMode", "percent")); N.spacingMode = d.spacingModeFromString(this.getValue(y, "spacingMode", "length")); N.rotateMode = d.rotateModeFromString(this.getValue(y, "rotateMode", "tangent")); N.offsetRotation = this.getValue(y, "rotation", 0); N.position = this.getValue(y, "position", 0); if (N.positionMode == c.PositionMode.Fixed) { N.position *= O } N.spacing = this.getValue(y, "spacing", 0); if (N.spacingMode == c.SpacingMode.Length || N.spacingMode == c.SpacingMode.Fixed) { N.spacing *= O } N.rotateMix = this.getValue(y, "rotateMix", 1); N.translateMix = this.getValue(y, "translateMix", 1); m.pathConstraints.push(N) } } if (E.skins) { for (var J = 0; J < E.skins.length; J++) { var C = E.skins[J]; var G = new c.Skin(C.name); if (C.bones) { for (var z = 0; z < C.bones.length; z++) { var r = m.findBone(C.bones[z]); if (r == null) { throw new Error("Skin bone not found: " + C.bones[J]) } G.bones.push(r) } } if (C.ik) { for (var z = 0; z < C.ik.length; z++) { var e = m.findIkConstraint(C.ik[z]); if (e == null) { throw new Error("Skin IK constraint not found: " + C.ik[J]) } G.constraints.push(e) } } if (C.transform) { for (var z = 0; z < C.transform.length; z++) { var e = m.findTransformConstraint(C.transform[z]); if (e == null) { throw new Error("Skin transform constraint not found: " + C.transform[J]) } G.constraints.push(e) } } if (C.path) { for (var z = 0; z < C.path.length; z++) { var e = m.findPathConstraint(C.path[z]); if (e == null) { throw new Error("Skin path constraint not found: " + C.path[J]) } G.constraints.push(e) } } for (var u in C.attachments) { var l = m.findSlot(u); if (l == null) { throw new Error("Slot not found: " + u) } var K = C.attachments[u]; for (var w in K) { var x = this.readAttachment(K[w], G, l.index, w, m); if (x != null) { G.setAttachment(l.index, w, x) } } } m.skins.push(G); if (G.name == "default") { m.defaultSkin = G } } } for (var J = 0, D = this.linkedMeshes.length; J < D; J++) { var f = this.linkedMeshes[J]; var G = f.skin == null ? m.defaultSkin : m.findSkin(f.skin); if (G == null) { throw new Error("Skin not found: " + f.skin) } var o = G.getAttachment(f.slotIndex, f.parent); if (o == null) { throw new Error("Parent mesh not found: " + f.parent) } f.mesh.deformAttachment = f.inheritDeform ? o : f.mesh; f.mesh.setParentMesh(o); f.mesh.updateUVs() } this.linkedMeshes.length = 0; if (E.events) { for (var p in E.events) { var A = E.events[p]; var N = new c.EventData(p); N.intValue = this.getValue(A, "int", 0); N.floatValue = this.getValue(A, "float", 0); N.stringValue = this.getValue(A, "string", ""); N.audioPath = this.getValue(A, "audio", null); if (N.audioPath != null) { N.volume = this.getValue(A, "volume", 1); N.balance = this.getValue(A, "balance", 0) } m.events.push(N) } } if (E.animations) { for (var v in E.animations) { var h = E.animations[v]; this.readAnimation(h, v, m) } } return m }; d.prototype.readAttachment = function (x, s, w, z, l) { var y = this.scale; z = this.getValue(x, "name", z); var j = this.getValue(x, "type", "region"); switch (j) { case "region": var q = this.getValue(x, "path", z); var h = this.attachmentLoader.newRegionAttachment(s, z, q); if (h == null) { return null } h.path = q; h.x = this.getValue(x, "x", 0) * y; h.y = this.getValue(x, "y", 0) * y; h.scaleX = this.getValue(x, "scaleX", 1); h.scaleY = this.getValue(x, "scaleY", 1); h.rotation = this.getValue(x, "rotation", 0); h.width = x.width * y; h.height = x.height * y; var t = this.getValue(x, "color", null); if (t != null) { h.color.setFromString(t) } h.updateOffset(); return h; case "boundingbox": var n = this.attachmentLoader.newBoundingBoxAttachment(s, z); if (n == null) { return null } this.readVertices(x, n, x.vertexCount << 1); var t = this.getValue(x, "color", null); if (t != null) { n.color.setFromString(t) } return n; case "mesh": case "linkedmesh": var q = this.getValue(x, "path", z); var e = this.attachmentLoader.newMeshAttachment(s, z, q); if (e == null) { return null } e.path = q; var t = this.getValue(x, "color", null); if (t != null) { e.color.setFromString(t) } e.width = this.getValue(x, "width", 0) * y; e.height = this.getValue(x, "height", 0) * y; var m = this.getValue(x, "parent", null); if (m != null) { this.linkedMeshes.push(new a(e, this.getValue(x, "skin", null), w, m, this.getValue(x, "deform", true))); return e } var o = x.uvs; this.readVertices(x, e, o.length); e.triangles = x.triangles; e.regionUVs = o; e.updateUVs(); e.edges = this.getValue(x, "edges", null); e.hullLength = this.getValue(x, "hull", 0) * 2; return e; case "path": var q = this.attachmentLoader.newPathAttachment(s, z); if (q == null) { return null } q.closed = this.getValue(x, "closed", false); q.constantSpeed = this.getValue(x, "constantSpeed", true); var p = x.vertexCount; this.readVertices(x, q, p << 1); var k = c.Utils.newArray(p / 3, 0); for (var u = 0; u < x.lengths.length; u++) { k[u] = x.lengths[u] * y } q.lengths = k; var t = this.getValue(x, "color", null); if (t != null) { q.color.setFromString(t) } return q; case "point": var r = this.attachmentLoader.newPointAttachment(s, z); if (r == null) { return null } r.x = this.getValue(x, "x", 0) * y; r.y = this.getValue(x, "y", 0) * y; r.rotation = this.getValue(x, "rotation", 0); var t = this.getValue(x, "color", null); if (t != null) { r.color.setFromString(t) } return r; case "clipping": var v = this.attachmentLoader.newClippingAttachment(s, z); if (v == null) { return null } var g = this.getValue(x, "end", null); if (g != null) { var f = l.findSlot(g); if (f == null) { throw new Error("Clipping end slot not found: " + g) } v.endSlot = f } var p = x.vertexCount; this.readVertices(x, v, p << 1); var t = this.getValue(x, "color", null); if (t != null) { v.color.setFromString(t) } return v }return null }; d.prototype.readVertices = function (e, m, q) { var h = this.scale; m.worldVerticesLength = q; var o = e.vertices; if (q == o.length) { var j = c.Utils.toFloatArray(o); if (h != 1) { for (var k = 0, f = o.length; k < f; k++) { j[k] *= h } } m.vertices = j; return } var p = new Array(); var g = new Array(); for (var k = 0, f = o.length; k < f;) { var l = o[k++]; g.push(l); for (var r = k + l * 4; k < r; k += 4) { g.push(o[k]); p.push(o[k + 1] * h); p.push(o[k + 2] * h); p.push(o[k + 3]) } } m.bones = g; m.vertices = c.Utils.toFloatArray(p) }; d.prototype.readAnimation = function (L, v, ab) { var P = this.scale; var U = new Array(); var I = 0; if (L.slots) { for (var ai in L.slots) { var K = L.slots[ai]; var aj = ab.findSlotIndex(ai); if (aj == -1) { throw new Error("Slot not found: " + ai) } for (var e in K) { var ac = K[e]; if (e == "attachment") { var r = new c.AttachmentTimeline(ac.length); r.slotIndex = aj; var k = 0; for (var ae = 0; ae < ac.length; ae++) { var af = ac[ae]; r.setFrame(k++, this.getValue(af, "time", 0), af.name) } U.push(r); I = Math.max(I, r.frames[r.getFrameCount() - 1]) } else { if (e == "color") { var r = new c.ColorTimeline(ac.length); r.slotIndex = aj; var k = 0; for (var ae = 0; ae < ac.length; ae++) { var af = ac[ae]; var M = new c.Color(); M.setFromString(af.color); r.setFrame(k, this.getValue(af, "time", 0), M.r, M.g, M.b, M.a); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[(r.getFrameCount() - 1) * c.ColorTimeline.ENTRIES]) } else { if (e == "twoColor") { var r = new c.TwoColorTimeline(ac.length); r.slotIndex = aj; var k = 0; for (var ae = 0; ae < ac.length; ae++) { var af = ac[ae]; var D = new c.Color(); var G = new c.Color(); D.setFromString(af.light); G.setFromString(af.dark); r.setFrame(k, this.getValue(af, "time", 0), D.r, D.g, D.b, D.a, G.r, G.g, G.b); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[(r.getFrameCount() - 1) * c.TwoColorTimeline.ENTRIES]) } else { throw new Error("Invalid timeline type for a slot: " + e + " (" + ai + ")") } } } } } } if (L.bones) { for (var t in L.bones) { var o = L.bones[t]; var s = ab.findBoneIndex(t); if (s == -1) { throw new Error("Bone not found: " + t) } for (var e in o) { var ac = o[e]; if (e === "rotate") { var r = new c.RotateTimeline(ac.length); r.boneIndex = s; var k = 0; for (var ae = 0; ae < ac.length; ae++) { var af = ac[ae]; r.setFrame(k, this.getValue(af, "time", 0), this.getValue(af, "angle", 0)); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[(r.getFrameCount() - 1) * c.RotateTimeline.ENTRIES]) } else { if (e === "translate" || e === "scale" || e === "shear") { var r = null; var E = 1, w = 0; if (e === "scale") { r = new c.ScaleTimeline(ac.length); w = 1 } else { if (e === "shear") { r = new c.ShearTimeline(ac.length) } else { r = new c.TranslateTimeline(ac.length); E = P } } r.boneIndex = s; var k = 0; for (var ae = 0; ae < ac.length; ae++) { var af = ac[ae]; var W = this.getValue(af, "x", w), V = this.getValue(af, "y", w); r.setFrame(k, this.getValue(af, "time", 0), W * E, V * E); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[(r.getFrameCount() - 1) * c.TranslateTimeline.ENTRIES]) } else { throw new Error("Invalid timeline type for a bone: " + e + " (" + t + ")") } } } } } if (L.ik) { for (var q in L.ik) { var S = L.ik[q]; var ah = ab.findIkConstraint(q); var r = new c.IkConstraintTimeline(S.length); r.ikConstraintIndex = ab.ikConstraints.indexOf(ah); var k = 0; for (var ae = 0; ae < S.length; ae++) { var af = S[ae]; r.setFrame(k, this.getValue(af, "time", 0), this.getValue(af, "mix", 1), this.getValue(af, "softness", 0) * P, this.getValue(af, "bendPositive", true) ? 1 : -1, this.getValue(af, "compress", false), this.getValue(af, "stretch", false)); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[(r.getFrameCount() - 1) * c.IkConstraintTimeline.ENTRIES]) } } if (L.transform) { for (var q in L.transform) { var S = L.transform[q]; var ah = ab.findTransformConstraint(q); var r = new c.TransformConstraintTimeline(S.length); r.transformConstraintIndex = ab.transformConstraints.indexOf(ah); var k = 0; for (var ae = 0; ae < S.length; ae++) { var af = S[ae]; r.setFrame(k, this.getValue(af, "time", 0), this.getValue(af, "rotateMix", 1), this.getValue(af, "translateMix", 1), this.getValue(af, "scaleMix", 1), this.getValue(af, "shearMix", 1)); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[(r.getFrameCount() - 1) * c.TransformConstraintTimeline.ENTRIES]) } } if (L.path) { for (var q in L.path) { var S = L.path[q]; var N = ab.findPathConstraintIndex(q); if (N == -1) { throw new Error("Path constraint not found: " + q) } var ag = ab.pathConstraints[N]; for (var e in S) { var ac = S[e]; if (e === "position" || e === "spacing") { var r = null; var E = 1; if (e === "spacing") { r = new c.PathConstraintSpacingTimeline(ac.length); if (ag.spacingMode == c.SpacingMode.Length || ag.spacingMode == c.SpacingMode.Fixed) { E = P } } else { r = new c.PathConstraintPositionTimeline(ac.length); if (ag.positionMode == c.PositionMode.Fixed) { E = P } } r.pathConstraintIndex = N; var k = 0; for (var ae = 0; ae < ac.length; ae++) { var af = ac[ae]; r.setFrame(k, this.getValue(af, "time", 0), this.getValue(af, e, 0) * E); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[(r.getFrameCount() - 1) * c.PathConstraintPositionTimeline.ENTRIES]) } else { if (e === "mix") { var r = new c.PathConstraintMixTimeline(ac.length); r.pathConstraintIndex = N; var k = 0; for (var ae = 0; ae < ac.length; ae++) { var af = ac[ae]; r.setFrame(k, this.getValue(af, "time", 0), this.getValue(af, "rotateMix", 1), this.getValue(af, "translateMix", 1)); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[(r.getFrameCount() - 1) * c.PathConstraintMixTimeline.ENTRIES]) } } } } } if (L.deform) { for (var u in L.deform) { var aa = L.deform[u]; var A = ab.findSkin(u); if (A == null) { throw new Error("Skin not found: " + u) } for (var ai in aa) { var K = aa[ai]; var aj = ab.findSlotIndex(ai); if (aj == -1) { throw new Error("Slot not found: " + K.name) } for (var e in K) { var ac = K[e]; var C = A.getAttachment(aj, e); if (C == null) { throw new Error("Deform attachment not found: " + ac.name) } var Y = C.bones != null; var g = C.vertices; var J = Y ? g.length / 3 * 2 : g.length; var r = new c.DeformTimeline(ac.length); r.slotIndex = aj; r.attachment = C; var k = 0; for (var ad = 0; ad < ac.length; ad++) { var af = ac[ad]; var R = void 0; var O = this.getValue(af, "vertices", null); if (O == null) { R = Y ? c.Utils.newFloatArray(J) : g } else { R = c.Utils.newFloatArray(J); var F = this.getValue(af, "offset", 0); c.Utils.arrayCopy(O, 0, R, F, O.length); if (P != 1) { for (var ae = F, Z = ae + O.length; ae < Z; ae++) { R[ae] *= P } } if (!Y) { for (var ae = 0; ae < J; ae++) { R[ae] += g[ae] } } } r.setFrame(k, this.getValue(af, "time", 0), R); this.readCurve(af, r, k); k++ } U.push(r); I = Math.max(I, r.frames[r.getFrameCount() - 1]) } } } } var X = L.drawOrder; if (X == null) { X = L.draworder } if (X != null) { var r = new c.DrawOrderTimeline(X.length); var p = ab.slots.length; var k = 0; for (var ad = 0; ad < X.length; ad++) { var ak = X[ad]; var Q = null; var B = this.getValue(ak, "offsets", null); if (B != null) { Q = c.Utils.newArray(p, -1); var f = c.Utils.newArray(p - B.length, 0); var m = 0, H = 0; for (var ae = 0; ae < B.length; ae++) { var l = B[ae]; var aj = ab.findSlotIndex(l.slot); if (aj == -1) { throw new Error("Slot not found: " + l.slot) } while (m != aj) { f[H++] = m++ } Q[m + l.offset] = m++ } while (m < p) { f[H++] = m++ } for (var ae = p - 1; ae >= 0; ae--) { if (Q[ae] == -1) { Q[ae] = f[--H] } } } r.setFrame(k++, this.getValue(ak, "time", 0), Q) } U.push(r); I = Math.max(I, r.frames[r.getFrameCount() - 1]) } if (L.events) { var r = new c.EventTimeline(L.events.length); var k = 0; for (var ae = 0; ae < L.events.length; ae++) { var h = L.events[ae]; var z = ab.findEvent(h.name); if (z == null) { throw new Error("Event not found: " + h.name) } var T = new c.Event(c.Utils.toSinglePrecision(this.getValue(h, "time", 0)), z); T.intValue = this.getValue(h, "int", z.intValue); T.floatValue = this.getValue(h, "float", z.floatValue); T.stringValue = this.getValue(h, "string", z.stringValue); if (T.data.audioPath != null) { T.volume = this.getValue(h, "volume", 1); T.balance = this.getValue(h, "balance", 0) } r.setFrame(k++, T) } U.push(r); I = Math.max(I, r.frames[r.getFrameCount() - 1]) } if (isNaN(I)) { throw new Error("Error while parsing animation, duration is NaN") } ab.animations.push(new c.Animation(v, U, I)) }; d.prototype.readCurve = function (f, e, h) { if (!f.hasOwnProperty("curve")) { return } if (f.curve == "stepped") { e.setStepped(h) } else { var g = f.curve; e.setCurve(h, g, this.getValue(f, "c2", 0), this.getValue(f, "c3", 1), this.getValue(f, "c4", 1)) } }; d.prototype.getValue = function (f, g, e) { return f[g] !== undefined ? f[g] : e }; d.blendModeFromString = function (e) { e = e.toLowerCase(); if (e == "normal") { return c.BlendMode.Normal } if (e == "additive") { return c.BlendMode.Additive } if (e == "multiply") { return c.BlendMode.Multiply } if (e == "screen") { return c.BlendMode.Screen } throw new Error("Unknown blend mode: " + e) }; d.positionModeFromString = function (e) { e = e.toLowerCase(); if (e == "fixed") { return c.PositionMode.Fixed } if (e == "percent") { return c.PositionMode.Percent } throw new Error("Unknown position mode: " + e) }; d.spacingModeFromString = function (e) { e = e.toLowerCase(); if (e == "length") { return c.SpacingMode.Length } if (e == "fixed") { return c.SpacingMode.Fixed } if (e == "percent") { return c.SpacingMode.Percent } throw new Error("Unknown position mode: " + e) }; d.rotateModeFromString = function (e) { e = e.toLowerCase(); if (e == "tangent") { return c.RotateMode.Tangent } if (e == "chain") { return c.RotateMode.Chain } if (e == "chainscale") { return c.RotateMode.ChainScale } throw new Error("Unknown rotate mode: " + e) }; d.transformModeFromString = function (e) { e = e.toLowerCase(); if (e == "normal") { return c.TransformMode.Normal } if (e == "onlytranslation") { return c.TransformMode.OnlyTranslation } if (e == "norotationorreflection") { return c.TransformMode.NoRotationOrReflection } if (e == "noscale") { return c.TransformMode.NoScale } if (e == "noscaleorreflection") { return c.TransformMode.NoScaleOrReflection } throw new Error("Unknown transform mode: " + e) }; return d }()); c.SkeletonJson = b; var a = (function () { function d(i, h, f, g, e) { this.mesh = i; this.skin = h; this.slotIndex = f; this.parent = g; this.inheritDeform = e } return d }()) })(spine || (spine = {})); var spine; (function (c) { var a = (function () { function d(e, f, g) { this.slotIndex = e; this.name = f; this.attachment = g } return d }()); c.SkinEntry = a; var b = (function () { function d(e) { this.attachments = new Array(); this.bones = Array(); this.constraints = new Array(); if (e == null) { throw new Error("name cannot be null.") } this.name = e } d.prototype.setAttachment = function (f, g, h) { if (h == null) { throw new Error("attachment cannot be null.") } var e = this.attachments; if (f >= e.length) { e.length = f + 1 } if (!e[f]) { e[f] = {} } e[f][g] = h }; d.prototype.addSkin = function (m) { for (var h = 0; h < m.bones.length; h++) { var k = m.bones[h]; var g = false; for (var f = 0; f < this.bones.length; f++) { if (this.bones[f] == k) { g = true; break } } if (!g) { this.bones.push(k) } } for (var h = 0; h < m.constraints.length; h++) { var l = m.constraints[h]; var g = false; for (var f = 0; f < this.constraints.length; f++) { if (this.constraints[f] == l) { g = true; break } } if (!g) { this.constraints.push(l) } } var e = m.getAttachments(); for (var h = 0; h < e.length; h++) { var n = e[h]; this.setAttachment(n.slotIndex, n.name, n.attachment) } }; d.prototype.copySkin = function (m) { for (var h = 0; h < m.bones.length; h++) { var k = m.bones[h]; var g = false; for (var f = 0; f < this.bones.length; f++) { if (this.bones[f] == k) { g = true; break } } if (!g) { this.bones.push(k) } } for (var h = 0; h < m.constraints.length; h++) { var l = m.constraints[h]; var g = false; for (var f = 0; f < this.constraints.length; f++) { if (this.constraints[f] == l) { g = true; break } } if (!g) { this.constraints.push(l) } } var e = m.getAttachments(); for (var h = 0; h < e.length; h++) { var n = e[h]; if (n.attachment == null) { continue } if (n.attachment instanceof c.MeshAttachment) { n.attachment = n.attachment.newLinkedMesh(); this.setAttachment(n.slotIndex, n.name, n.attachment) } else { n.attachment = n.attachment.copy(); this.setAttachment(n.slotIndex, n.name, n.attachment) } } }; d.prototype.getAttachment = function (e, f) { var g = this.attachments[e]; return g ? g[f] : null }; d.prototype.removeAttachment = function (e, f) { var g = this.attachments[e]; if (g) { g[f] = null } }; d.prototype.getAttachments = function () { var e = new Array(); for (var g = 0; g < this.attachments.length; g++) { var h = this.attachments[g]; if (h) { for (var f in h) { var j = h[f]; if (j) { e.push(new a(g, f, j)) } } } } return e }; d.prototype.getAttachmentsForSlot = function (g, f) { var h = this.attachments[g]; if (h) { for (var e in h) { var i = h[e]; if (i) { f.push(new a(g, e, i)) } } } }; d.prototype.clear = function () { this.attachments.length = 0; this.bones.length = 0; this.constraints.length = 0 }; d.prototype.attachAll = function (e, o) { var h = 0; for (var f = 0; f < e.slots.length; f++) { var m = e.slots[f]; var l = m.getAttachment(); if (l && h < o.attachments.length) { var k = o.attachments[h]; for (var n in k) { var j = k[n]; if (l == j) { var g = this.getAttachment(h, n); if (g != null) { m.setAttachment(g) } break } } } h++ } }; return d }()); c.Skin = b })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, d) { this.deform = new Array(); if (e == null) { throw new Error("data cannot be null.") } if (d == null) { throw new Error("bone cannot be null.") } this.data = e; this.bone = d; this.color = new b.Color(); this.darkColor = e.darkColor == null ? null : new b.Color(); this.setToSetupPose() } c.prototype.getSkeleton = function () { return this.bone.skeleton }; c.prototype.getAttachment = function () { return this.attachment }; c.prototype.setAttachment = function (d) { if (this.attachment == d) { return } this.attachment = d; this.attachmentTime = this.bone.skeleton.time; this.deform.length = 0 }; c.prototype.setAttachmentTime = function (d) { this.attachmentTime = this.bone.skeleton.time - d }; c.prototype.getAttachmentTime = function () { return this.bone.skeleton.time - this.attachmentTime }; c.prototype.setToSetupPose = function () { this.color.setFromColor(this.data.color); if (this.darkColor != null) { this.darkColor.setFromColor(this.data.darkColor) } if (this.data.attachmentName == null) { this.attachment = null } else { this.attachment = null; this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)) } }; return c }()); b.Slot = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, d, f) { this.color = new b.Color(1, 1, 1, 1); if (e < 0) { throw new Error("index must be >= 0.") } if (d == null) { throw new Error("name cannot be null.") } if (f == null) { throw new Error("boneData cannot be null.") } this.index = e; this.name = d; this.boneData = f } return c }()); b.SlotData = a })(spine || (spine = {})); var spine; (function (f) { var b = (function () { function g(h) { this._image = h } g.prototype.getImage = function () { return this._image }; g.filterFromString = function (h) { switch (h.toLowerCase()) { case "nearest": return a.Nearest; case "linear": return a.Linear; case "mipmap": return a.MipMap; case "mipmapnearestnearest": return a.MipMapNearestNearest; case "mipmaplinearnearest": return a.MipMapLinearNearest; case "mipmapnearestlinear": return a.MipMapNearestLinear; case "mipmaplinearlinear": return a.MipMapLinearLinear; default: throw new Error("Unknown texture filter " + h) } }; g.wrapFromString = function (h) { switch (h.toLowerCase()) { case "mirroredtepeat": return e.MirroredRepeat; case "clamptoedge": return e.ClampToEdge; case "repeat": return e.Repeat; default: throw new Error("Unknown texture wrap " + h) } }; return g }()); f.Texture = b; var a; (function (g) { g[g.Nearest = 9728] = "Nearest"; g[g.Linear = 9729] = "Linear"; g[g.MipMap = 9987] = "MipMap"; g[g.MipMapNearestNearest = 9984] = "MipMapNearestNearest"; g[g.MipMapLinearNearest = 9985] = "MipMapLinearNearest"; g[g.MipMapNearestLinear = 9986] = "MipMapNearestLinear"; g[g.MipMapLinearLinear = 9987] = "MipMapLinearLinear" })(a = f.TextureFilter || (f.TextureFilter = {})); var e; (function (g) { g[g.MirroredRepeat = 33648] = "MirroredRepeat"; g[g.ClampToEdge = 33071] = "ClampToEdge"; g[g.Repeat = 10497] = "Repeat" })(e = f.TextureWrap || (f.TextureWrap = {})); var c = (function () { function g() { this.u = 0; this.v = 0; this.u2 = 0; this.v2 = 0; this.width = 0; this.height = 0; this.rotate = false; this.offsetX = 0; this.offsetY = 0; this.originalWidth = 0; this.originalHeight = 0 } return g }()); f.TextureRegion = c; var d = (function (h) { __extends(g, h); function g() { return h !== null && h.apply(this, arguments) || this } g.prototype.setFilters = function (i, j) { }; g.prototype.setWraps = function (i, j) { }; g.prototype.dispose = function () { }; return g }(b)); f.FakeTexture = d })(spine || (spine = {})); var spine; (function (e) { var d = (function () { function f(h, g) { this.pages = new Array(); this.regions = new Array(); this.load(h, g) } f.prototype.load = function (m, g) { if (g == null) { throw new Error("textureLoader cannot be null.") } var i = new b(m); var p = new Array(4); var j = null; while (true) { var s = i.readLine(); if (s == null) { break } s = s.trim(); if (s.length == 0) { j = null } else { if (!j) { j = new c(); j.name = s; if (i.readTuple(p) == 2) { j.width = parseInt(p[0]); j.height = parseInt(p[1]); i.readTuple(p) } i.readTuple(p); j.minFilter = e.Texture.filterFromString(p[0]); j.magFilter = e.Texture.filterFromString(p[1]); var o = i.readValue(); j.uWrap = e.TextureWrap.ClampToEdge; j.vWrap = e.TextureWrap.ClampToEdge; if (o == "x") { j.uWrap = e.TextureWrap.Repeat } else { if (o == "y") { j.vWrap = e.TextureWrap.Repeat } else { if (o == "xy") { j.uWrap = j.vWrap = e.TextureWrap.Repeat } } } j.texture = g(s); j.texture.setFilters(j.minFilter, j.magFilter); j.texture.setWraps(j.uWrap, j.vWrap); j.width = j.texture.getImage().width; j.height = j.texture.getImage().height; this.pages.push(j) } else { var l = new a(); l.name = s; l.page = j; var r = i.readValue(); if (r.toLocaleLowerCase() == "true") { l.degrees = 90 } else { if (r.toLocaleLowerCase() == "false") { l.degrees = 0 } else { l.degrees = parseFloat(r) } } l.rotate = l.degrees == 90; i.readTuple(p); var n = parseInt(p[0]); var k = parseInt(p[1]); i.readTuple(p); var h = parseInt(p[0]); var q = parseInt(p[1]); l.u = n / j.width; l.v = k / j.height; if (l.rotate) { l.u2 = (n + q) / j.width; l.v2 = (k + h) / j.height } else { l.u2 = (n + h) / j.width; l.v2 = (k + q) / j.height } l.x = n; l.y = k; l.width = Math.abs(h); l.height = Math.abs(q); if (i.readTuple(p) == 4) { if (i.readTuple(p) == 4) { i.readTuple(p) } } l.originalWidth = parseInt(p[0]); l.originalHeight = parseInt(p[1]); i.readTuple(p); l.offsetX = parseInt(p[0]); l.offsetY = parseInt(p[1]); l.index = parseInt(i.readValue()); l.texture = j.texture; this.regions.push(l) } } } }; f.prototype.findRegion = function (g) { for (var h = 0; h < this.regions.length; h++) { if (this.regions[h].name == g) { return this.regions[h] } } return null }; f.prototype.dispose = function () { for (var g = 0; g < this.pages.length; g++) { this.pages[g].texture.dispose() } }; return f }()); e.TextureAtlas = d; var b = (function () { function f(g) { this.index = 0; this.lines = g.split(/\r\n|\r|\n/) } f.prototype.readLine = function () { if (this.index >= this.lines.length) { return null } return this.lines[this.index++] }; f.prototype.readValue = function () { var g = this.readLine(); var h = g.indexOf(":"); if (h == -1) { throw new Error("Invalid line: " + g) } return g.substring(h + 1).trim() }; f.prototype.readTuple = function (h) { var j = this.readLine(); var l = j.indexOf(":"); if (l == -1) { throw new Error("Invalid line: " + j) } var k = 0, m = l + 1; for (; k < 3; k++) { var g = j.indexOf(",", m); if (g == -1) { break } h[k] = j.substr(m, g - m).trim(); m = g + 1 } h[k] = j.substring(m).trim(); return k + 1 }; return f }()); var c = (function () { function f() { } return f }()); e.TextureAtlasPage = c; var a = (function (g) { __extends(f, g); function f() { return g !== null && g.apply(this, arguments) || this } return f }(e.TextureRegion)); e.TextureAtlasRegion = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, f) { this.rotateMix = 0; this.translateMix = 0; this.scaleMix = 0; this.shearMix = 0; this.temp = new b.Vector2(); this.active = false; if (e == null) { throw new Error("data cannot be null.") } if (f == null) { throw new Error("skeleton cannot be null.") } this.data = e; this.rotateMix = e.rotateMix; this.translateMix = e.translateMix; this.scaleMix = e.scaleMix; this.shearMix = e.shearMix; this.bones = new Array(); for (var d = 0; d < e.bones.length; d++) { this.bones.push(f.findBone(e.bones[d].name)) } this.target = f.findBone(e.target.name) } c.prototype.isActive = function () { return this.active }; c.prototype.apply = function () { this.update() }; c.prototype.update = function () { if (this.data.local) { if (this.data.relative) { this.applyRelativeLocal() } else { this.applyAbsoluteLocal() } } else { if (this.data.relative) { this.applyRelativeWorld() } else { this.applyAbsoluteWorld() } } }; c.prototype.applyAbsoluteWorld = function () { var t = this.rotateMix, J = this.translateMix, C = this.scaleMix, h = this.shearMix; var I = this.target; var p = I.a, o = I.b, m = I.c, l = I.d; var z = p * l - o * m > 0 ? b.MathUtils.degRad : -b.MathUtils.degRad; var x = this.data.offsetRotation * z; var q = this.data.offsetShearY * z; var B = this.bones; for (var y = 0, w = B.length; y < w; y++) { var j = B[y]; var k = false; if (t != 0) { var H = j.a, G = j.b, F = j.c, E = j.d; var v = Math.atan2(m, p) - Math.atan2(F, H) + x; if (v > b.MathUtils.PI) { v -= b.MathUtils.PI2 } else { if (v < -b.MathUtils.PI) { v += b.MathUtils.PI2 } } v *= t; var g = Math.cos(v), e = Math.sin(v); j.a = g * H - e * F; j.b = g * G - e * E; j.c = e * H + g * F; j.d = e * G + g * E; k = true } if (J != 0) { var D = this.temp; I.localToWorld(D.set(this.data.offsetX, this.data.offsetY)); j.worldX += (D.x - j.worldX) * J; j.worldY += (D.y - j.worldY) * J; k = true } if (C > 0) { var u = Math.sqrt(j.a * j.a + j.c * j.c); var f = Math.sqrt(p * p + m * m); if (u > 0.00001) { u = (u + (f - u + this.data.offsetScaleX) * C) / u } j.a *= u; j.c *= u; u = Math.sqrt(j.b * j.b + j.d * j.d); f = Math.sqrt(o * o + l * l); if (u > 0.00001) { u = (u + (f - u + this.data.offsetScaleY) * C) / u } j.b *= u; j.d *= u; k = true } if (h > 0) { var G = j.b, E = j.d; var A = Math.atan2(E, G); var v = Math.atan2(l, o) - Math.atan2(m, p) - (A - Math.atan2(j.c, j.a)); if (v > b.MathUtils.PI) { v -= b.MathUtils.PI2 } else { if (v < -b.MathUtils.PI) { v += b.MathUtils.PI2 } } v = A + (v + q) * h; var u = Math.sqrt(G * G + E * E); j.b = Math.cos(v) * u; j.d = Math.sin(v) * u; k = true } if (k) { j.appliedValid = false } } }; c.prototype.applyRelativeWorld = function () { var q = this.rotateMix, H = this.translateMix, A = this.scaleMix, g = this.shearMix; var G = this.target; var o = G.a, m = G.b, l = G.c, k = G.d; var y = o * k - m * l > 0 ? b.MathUtils.degRad : -b.MathUtils.degRad; var w = this.data.offsetRotation * y, p = this.data.offsetShearY * y; var z = this.bones; for (var x = 0, v = z.length; x < v; x++) { var h = z[x]; var j = false; if (q != 0) { var F = h.a, E = h.b, D = h.c, C = h.d; var u = Math.atan2(l, o) + w; if (u > b.MathUtils.PI) { u -= b.MathUtils.PI2 } else { if (u < -b.MathUtils.PI) { u += b.MathUtils.PI2 } } u *= q; var f = Math.cos(u), e = Math.sin(u); h.a = f * F - e * D; h.b = f * E - e * C; h.c = e * F + f * D; h.d = e * E + f * C; j = true } if (H != 0) { var B = this.temp; G.localToWorld(B.set(this.data.offsetX, this.data.offsetY)); h.worldX += B.x * H; h.worldY += B.y * H; j = true } if (A > 0) { var t = (Math.sqrt(o * o + l * l) - 1 + this.data.offsetScaleX) * A + 1; h.a *= t; h.c *= t; t = (Math.sqrt(m * m + k * k) - 1 + this.data.offsetScaleY) * A + 1; h.b *= t; h.d *= t; j = true } if (g > 0) { var u = Math.atan2(k, m) - Math.atan2(l, o); if (u > b.MathUtils.PI) { u -= b.MathUtils.PI2 } else { if (u < -b.MathUtils.PI) { u += b.MathUtils.PI2 } } var E = h.b, C = h.d; u = Math.atan2(C, E) + (u - b.MathUtils.PI / 2 + p) * g; var t = Math.sqrt(E * E + C * C); h.b = Math.cos(u) * t; h.d = Math.sin(u) * t; j = true } if (j) { h.appliedValid = false } } }; c.prototype.applyAbsoluteLocal = function () { var o = this.rotateMix, l = this.translateMix, e = this.scaleMix, k = this.shearMix; var m = this.target; if (!m.appliedValid) { m.updateAppliedTransform() } var g = this.bones; for (var j = 0, f = g.length; j < f; j++) { var u = g[j]; if (!u.appliedValid) { u.updateAppliedTransform() } var v = u.arotation; if (o != 0) { var d = m.arotation - v + this.data.offsetRotation; d -= (16384 - ((16384.499999999996 - d / 360) | 0)) * 360; v += d * o } var q = u.ax, p = u.ay; if (l != 0) { q += (m.ax - q + this.data.offsetX) * l; p += (m.ay - p + this.data.offsetY) * l } var t = u.ascaleX, s = u.ascaleY; if (e != 0) { if (t > 0.00001) { t = (t + (m.ascaleX - t + this.data.offsetScaleX) * e) / t } if (s > 0.00001) { s = (s + (m.ascaleY - s + this.data.offsetScaleY) * e) / s } } var h = u.ashearY; if (k != 0) { var d = m.ashearY - h + this.data.offsetShearY; d -= (16384 - ((16384.499999999996 - d / 360) | 0)) * 360; u.shearY += d * k } u.updateWorldTransformWith(q, p, v, t, s, u.ashearX, h) } }; c.prototype.applyRelativeLocal = function () { var m = this.rotateMix, k = this.translateMix, d = this.scaleMix, j = this.shearMix; var l = this.target; if (!l.appliedValid) { l.updateAppliedTransform() } var f = this.bones; for (var h = 0, e = f.length; h < e; h++) { var s = f[h]; if (!s.appliedValid) { s.updateAppliedTransform() } var t = s.arotation; if (m != 0) { t += (l.arotation + this.data.offsetRotation) * m } var p = s.ax, o = s.ay; if (k != 0) { p += (l.ax + this.data.offsetX) * k; o += (l.ay + this.data.offsetY) * k } var r = s.ascaleX, q = s.ascaleY; if (d != 0) { if (r > 0.00001) { r *= ((l.ascaleX - 1 + this.data.offsetScaleX) * d) + 1 } if (q > 0.00001) { q *= ((l.ascaleY - 1 + this.data.offsetScaleY) * d) + 1 } } var g = s.ashearY; if (j != 0) { g += (l.ashearY + this.data.offsetShearY) * j } s.updateWorldTransformWith(p, o, t, r, q, s.ashearX, g) } }; return c }()); b.TransformConstraint = a })(spine || (spine = {})); var spine; (function (a) { var b = (function (c) { __extends(d, c); function d(e) { var f = c.call(this, e, 0, false) || this; f.bones = new Array(); f.rotateMix = 0; f.translateMix = 0; f.scaleMix = 0; f.shearMix = 0; f.offsetRotation = 0; f.offsetX = 0; f.offsetY = 0; f.offsetScaleX = 0; f.offsetScaleY = 0; f.offsetShearY = 0; f.relative = false; f.local = false; return f } return d }(a.ConstraintData)); a.TransformConstraintData = b })(spine || (spine = {})); var spine; (function (a) { var b = (function () { function c() { this.convexPolygons = new Array(); this.convexPolygonsIndices = new Array(); this.indicesArray = new Array(); this.isConcaveArray = new Array(); this.triangles = new Array(); this.polygonPool = new a.Pool(function () { return new Array() }); this.polygonIndicesPool = new a.Pool(function () { return new Array() }) } c.prototype.triangulate = function (k) { var o = k; var s = k.length >> 1; var m = this.indicesArray; m.length = 0; for (var D = 0; D < s; D++) { m[D] = D } var E = this.isConcaveArray; E.length = 0; for (var D = 0, z = s; D < z; ++D) { E[D] = c.isConcave(D, s, o, m) } var A = this.triangles; A.length = 0; while (s > 3) { var j = s - 1, D = 0, y = 1; while (true) { outer: if (!E[D]) { var g = m[j] << 1, e = m[D] << 1, d = m[y] << 1; var h = o[g], f = o[g + 1]; var r = o[e], p = o[e + 1]; var C = o[d], B = o[d + 1]; for (var u = (y + 1) % s; u != j; u = (u + 1) % s) { if (!E[u]) { continue } var t = m[u] << 1; var x = o[t], w = o[t + 1]; if (c.positiveArea(C, B, h, f, x, w)) { if (c.positiveArea(h, f, r, p, x, w)) { if (c.positiveArea(r, p, C, B, x, w)) { break outer } } } } break } if (y == 0) { do { if (!E[D]) { break } D-- } while (D > 0); break } j = D; D = y; y = (y + 1) % s } A.push(m[(s + D - 1) % s]); A.push(m[D]); A.push(m[(D + 1) % s]); m.splice(D, 1); E.splice(D, 1); s--; var l = (s + D - 1) % s; var q = D == s ? 0 : D; E[l] = c.isConcave(l, s, o, m); E[q] = c.isConcave(q, s, o, m) } if (s == 3) { A.push(m[2]); A.push(m[0]); A.push(m[1]) } return A }; c.prototype.decompose = function (R, l) { var h = R; var x = this.convexPolygons; this.polygonPool.freeAll(x); x.length = 0; var Q = this.convexPolygonsIndices; this.polygonIndicesPool.freeAll(Q); Q.length = 0; var O = this.polygonIndicesPool.obtain(); O.length = 0; var w = this.polygonPool.obtain(); w.length = 0; var L = -1, E = 0; for (var P = 0, N = l.length; P < N; P += 3) { var K = l[P] << 1, I = l[P + 1] << 1, H = l[P + 2] << 1; var u = h[K], U = h[K + 1]; var t = h[I], T = h[I + 1]; var r = h[H], S = h[H + 1]; var y = false; if (L == K) { var M = w.length - 4; var p = c.winding(w[M], w[M + 1], w[M + 2], w[M + 3], r, S); var m = c.winding(r, S, w[0], w[1], w[2], w[3]); if (p == E && m == E) { w.push(r); w.push(S); O.push(H); y = true } } if (!y) { if (w.length > 0) { x.push(w); Q.push(O) } else { this.polygonPool.free(w); this.polygonIndicesPool.free(O) } w = this.polygonPool.obtain(); w.length = 0; w.push(u); w.push(U); w.push(t); w.push(T); w.push(r); w.push(S); O = this.polygonIndicesPool.obtain(); O.length = 0; O.push(K); O.push(I); O.push(H); E = c.winding(u, U, t, T, r, S); L = K } } if (w.length > 0) { x.push(w); Q.push(O) } for (var P = 0, N = x.length; P < N; P++) { O = Q[P]; if (O.length == 0) { continue } var v = O[0]; var k = O[O.length - 1]; w = x[P]; var M = w.length - 4; var A = w[M], z = w[M + 1]; var e = w[M + 2], d = w[M + 3]; var G = w[0], F = w[1]; var C = w[2], B = w[3]; var q = c.winding(A, z, e, d, G, F); for (var J = 0; J < N; J++) { if (J == P) { continue } var j = Q[J]; if (j.length != 3) { continue } var s = j[0]; var f = j[1]; var D = j[2]; var g = x[J]; var r = g[g.length - 2], S = g[g.length - 1]; if (s != v || f != k) { continue } var p = c.winding(A, z, e, d, r, S); var m = c.winding(r, S, G, F, C, B); if (p == q && m == q) { g.length = 0; j.length = 0; w.push(r); w.push(S); O.push(D); A = e; z = d; e = r; d = S; J = 0 } } } for (var P = x.length - 1; P >= 0; P--) { w = x[P]; if (w.length == 0) { x.splice(P, 1); this.polygonPool.free(w); O = Q[P]; Q.splice(P, 1); this.polygonIndicesPool.free(O) } } return x }; c.isConcave = function (e, g, d, j) { var h = j[(g + e - 1) % g] << 1; var i = j[e] << 1; var f = j[(e + 1) % g] << 1; return !this.positiveArea(d[h], d[h + 1], d[i], d[i + 1], d[f], d[f + 1]) }; c.positiveArea = function (e, d, g, f, i, h) { return e * (h - f) + g * (d - h) + i * (f - d) >= 0 }; c.winding = function (e, d, i, g, k, j) { var h = i - e, f = g - d; return k * f - j * h + h * d - e * f >= 0 ? 1 : -1 }; return c }()); a.Triangulator = b })(spine || (spine = {})); var spine; (function (m) { var g = (function () { function n() { this.array = new Array() } n.prototype.add = function (p) { var o = this.contains(p); this.array[p | 0] = p | 0; return !o }; n.prototype.contains = function (o) { return this.array[o | 0] != undefined }; n.prototype.remove = function (o) { this.array[o | 0] = undefined }; n.prototype.clear = function () { this.array.length = 0 }; return n }()); m.IntSet = g; var b = (function () { function n(s, q, o, p) { if (s === void 0) { s = 0 } if (q === void 0) { q = 0 } if (o === void 0) { o = 0 } if (p === void 0) { p = 0 } this.r = s; this.g = q; this.b = o; this.a = p } n.prototype.set = function (s, q, o, p) { this.r = s; this.g = q; this.b = o; this.a = p; this.clamp(); return this }; n.prototype.setFromColor = function (o) { this.r = o.r; this.g = o.g; this.b = o.b; this.a = o.a; return this }; n.prototype.setFromString = function (o) { o = o.charAt(0) == "#" ? o.substr(1) : o; this.r = parseInt(o.substr(0, 2), 16) / 255; this.g = parseInt(o.substr(2, 2), 16) / 255; this.b = parseInt(o.substr(4, 2), 16) / 255; this.a = (o.length != 8 ? 255 : parseInt(o.substr(6, 2), 16)) / 255; return this }; n.prototype.add = function (s, q, o, p) { this.r += s; this.g += q; this.b += o; this.a += p; this.clamp(); return this }; n.prototype.clamp = function () { if (this.r < 0) { this.r = 0 } else { if (this.r > 1) { this.r = 1 } } if (this.g < 0) { this.g = 0 } else { if (this.g > 1) { this.g = 1 } } if (this.b < 0) { this.b = 0 } else { if (this.b > 1) { this.b = 1 } } if (this.a < 0) { this.a = 0 } else { if (this.a > 1) { this.a = 1 } } return this }; n.rgba8888ToColor = function (o, p) { o.r = ((p & 4278190080) >>> 24) / 255; o.g = ((p & 16711680) >>> 16) / 255; o.b = ((p & 65280) >>> 8) / 255; o.a = ((p & 255)) / 255 }; n.rgb888ToColor = function (o, p) { o.r = ((p & 16711680) >>> 16) / 255; o.g = ((p & 65280) >>> 8) / 255; o.b = ((p & 255)) / 255 }; n.WHITE = new n(1, 1, 1, 1); n.RED = new n(1, 0, 0, 1); n.GREEN = new n(0, 1, 0, 1); n.BLUE = new n(0, 0, 1, 1); n.MAGENTA = new n(1, 0, 1, 1); return n }()); m.Color = b; var f = (function () { function n() { } n.clamp = function (q, p, o) { if (q < p) { return p } if (q > o) { return o } return q }; n.cosDeg = function (o) { return Math.cos(o * n.degRad) }; n.sinDeg = function (o) { return Math.sin(o * n.degRad) }; n.signum = function (o) { return o > 0 ? 1 : o < 0 ? -1 : 0 }; n.toInt = function (o) { return o > 0 ? Math.floor(o) : Math.ceil(o) }; n.cbrt = function (o) { var p = Math.pow(Math.abs(o), 1 / 3); return o < 0 ? -p : p }; n.randomTriangular = function (p, o) { return n.randomTriangularWith(p, o, (p + o) * 0.5) }; n.randomTriangularWith = function (q, o, s) { var p = Math.random(); var r = o - q; if (p <= (s - q) / r) { return q + Math.sqrt(p * r * (s - q)) } return o - Math.sqrt((1 - p) * r * (o - s)) }; n.PI = 3.1415927; n.PI2 = n.PI * 2; n.radiansToDegrees = 180 / n.PI; n.radDeg = n.radiansToDegrees; n.degreesToRadians = n.PI / 180; n.degRad = n.degreesToRadians; return n }()); m.MathUtils = f; var a = (function () { function n() { } n.prototype.apply = function (q, p, o) { return q + (p - q) * this.applyInternal(o) }; return n }()); m.Interpolation = a; var i = (function (o) { __extends(n, o); function n(p) { var q = o.call(this) || this; q.power = 2; q.power = p; return q } n.prototype.applyInternal = function (p) { if (p <= 0.5) { return Math.pow(p * 2, this.power) / 2 } return Math.pow((p - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1 }; return n }(a)); m.Pow = i; var e = (function (n) { __extends(o, n); function o(p) { return n.call(this, p) || this } o.prototype.applyInternal = function (p) { return Math.pow(p - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1 }; return o }(i)); m.PowOut = e; var h = (function () { function n() { } n.arrayCopy = function (t, s, q, u, o) { for (var r = s, p = u; r < s + o; r++, p++) { q[p] = t[r] } }; n.setArraySize = function (s, p, r) { if (r === void 0) { r = 0 } var q = s.length; if (q == p) { return s } s.length = p; if (q < p) { for (var o = q; o < p; o++) { s[o] = r } } return s }; n.ensureArrayCapacity = function (q, o, p) { if (p === void 0) { p = 0 } if (q.length >= o) { return q } return n.setArraySize(q, o, p) }; n.newArray = function (q, o) { var r = new Array(q); for (var p = 0; p < q; p++) { r[p] = o } return r }; n.newFloatArray = function (p) { if (n.SUPPORTS_TYPED_ARRAYS) { return new Float32Array(p) } else { var q = new Array(p); for (var o = 0; o < q.length; o++) { q[o] = 0 } return q } }; n.newShortArray = function (p) { if (n.SUPPORTS_TYPED_ARRAYS) { return new Int16Array(p) } else { var q = new Array(p); for (var o = 0; o < q.length; o++) { q[o] = 0 } return q } }; n.toFloatArray = function (o) { return n.SUPPORTS_TYPED_ARRAYS ? new Float32Array(o) : o }; n.toSinglePrecision = function (o) { return n.SUPPORTS_TYPED_ARRAYS ? Math.fround(o) : o }; n.webkit602BugfixHelper = function (p, o) { }; n.contains = function (r, q, o) { if (o === void 0) { o = true } for (var p = 0; p < r.length; p++) { if (r[p] == q) { return true } } return false }; n.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== "undefined"; return n }()); m.Utils = h; var j = (function () { function n() { } n.logBones = function (q) { for (var o = 0; o < q.bones.length; o++) { var p = q.bones[o]; console.log(p.data.name + ", " + p.a + ", " + p.b + ", " + p.c + ", " + p.d + ", " + p.worldX + ", " + p.worldY) } }; return n }()); m.DebugUtils = j; var l = (function () { function n(o) { this.items = new Array(); this.instantiator = o } n.prototype.obtain = function () { return this.items.length > 0 ? this.items.pop() : this.instantiator() }; n.prototype.free = function (o) { if (o.reset) { o.reset() } this.items.push(o) }; n.prototype.freeAll = function (o) { for (var p = 0; p < o.length; p++) { this.free(o[p]) } }; n.prototype.clear = function () { this.items.length = 0 }; return n }()); m.Pool = l; var k = (function () { function n(o, p) { if (o === void 0) { o = 0 } if (p === void 0) { p = 0 } this.x = o; this.y = p } n.prototype.set = function (o, p) { this.x = o; this.y = p; return this }; n.prototype.length = function () { var o = this.x; var p = this.y; return Math.sqrt(o * o + p * p) }; n.prototype.normalize = function () { var o = this.length(); if (o != 0) { this.x /= o; this.y /= o } return this }; return n }()); m.Vector2 = k; var d = (function () { function n() { this.maxDelta = 0.064; this.framesPerSecond = 0; this.delta = 0; this.totalTime = 0; this.lastTime = Date.now() / 1000; this.frameCount = 0; this.frameTime = 0 } n.prototype.update = function () { var o = Date.now() / 1000; this.delta = o - this.lastTime; this.frameTime += this.delta; this.totalTime += this.delta; if (this.delta > this.maxDelta) { this.delta = this.maxDelta } this.lastTime = o; this.frameCount++; if (this.frameTime > 1) { this.framesPerSecond = this.frameCount / this.frameTime; this.frameTime = 0; this.frameCount = 0 } }; return n }()); m.TimeKeeper = d; var c = (function () { function n(o) { if (o === void 0) { o = 32 } this.addedValues = 0; this.lastValue = 0; this.mean = 0; this.dirty = true; this.values = new Array(o) } n.prototype.hasEnoughData = function () { return this.addedValues >= this.values.length }; n.prototype.addValue = function (o) { if (this.addedValues < this.values.length) { this.addedValues++ } this.values[this.lastValue++] = o; if (this.lastValue > this.values.length - 1) { this.lastValue = 0 } this.dirty = true }; n.prototype.getMean = function () { if (this.hasEnoughData()) { if (this.dirty) { var o = 0; for (var p = 0; p < this.values.length; p++) { o += this.values[p] } this.mean = o / this.values.length; this.dirty = false } return this.mean } else { return 0 } }; return n }()); m.WindowedMean = c })(spine || (spine = {})); (function () { if (!Math.fround) { Math.fround = (function (a) { return function (b) { return a[0] = b, a[0] } })(new Float32Array(1)) } })(); var spine; (function (c) { var b = (function () { function d(e) { if (e == null) { throw new Error("name cannot be null.") } this.name = e } return d }()); c.Attachment = b; var a = (function (e) { __extends(d, e); function d(f) { var g = e.call(this, f) || this; g.id = (d.nextID++ & 65535) << 11; g.worldVerticesLength = 0; g.deformAttachment = g; return g } d.prototype.computeWorldVertices = function (g, k, q, C, l, G) { q = l + (q >> 1) * G; var h = g.bone.skeleton; var j = g.deform; var o = this.vertices; var J = this.bones; if (J == null) { if (j.length > 0) { o = j } var m = g.bone; var s = m.worldX; var r = m.worldY; var P = m.a, N = m.b, M = m.c, L = m.d; for (var A = k, t = l; t < q; A += 2, t += G) { var E = o[A], B = o[A + 1]; C[t] = E * P + B * N + s; C[t + 1] = E * M + B * L + r } return } var u = 0, H = 0; for (var I = 0; I < k; I += 2) { var F = J[u]; u += F + 1; H += F } var p = h.bones; if (j.length == 0) { for (var t = l, N = H * 3; t < q; t += G) { var Q = 0, O = 0; var F = J[u++]; F += u; for (; u < F; u++, N += 3) { var m = p[J[u]]; var E = o[N], B = o[N + 1], z = o[N + 2]; Q += (E * m.a + B * m.b + m.worldX) * z; O += (E * m.c + B * m.d + m.worldY) * z } C[t] = Q; C[t + 1] = O } } else { var D = j; for (var t = l, N = H * 3, K = H << 1; t < q; t += G) { var Q = 0, O = 0; var F = J[u++]; F += u; for (; u < F; u++, N += 3, K += 2) { var m = p[J[u]]; var E = o[N] + D[K], B = o[N + 1] + D[K + 1], z = o[N + 2]; Q += (E * m.a + B * m.b + m.worldX) * z; O += (E * m.c + B * m.d + m.worldY) * z } C[t] = Q; C[t + 1] = O } } }; d.prototype.copyTo = function (f) { if (this.bones != null) { f.bones = new Array(this.bones.length); c.Utils.arrayCopy(this.bones, 0, f.bones, 0, this.bones.length) } else { f.bones = null } if (this.vertices != null) { f.vertices = c.Utils.newFloatArray(this.vertices.length); c.Utils.arrayCopy(this.vertices, 0, f.vertices, 0, this.vertices.length) } else { f.vertices = null } f.worldVerticesLength = this.worldVerticesLength; f.deformAttachment = this.deformAttachment }; d.nextID = 0; return d }(b)); c.VertexAttachment = a })(spine || (spine = {})); var spine; (function (b) { var a; (function (c) { c[c.Region = 0] = "Region"; c[c.BoundingBox = 1] = "BoundingBox"; c[c.Mesh = 2] = "Mesh"; c[c.LinkedMesh = 3] = "LinkedMesh"; c[c.Path = 4] = "Path"; c[c.Point = 5] = "Point"; c[c.Clipping = 6] = "Clipping" })(a = b.AttachmentType || (b.AttachmentType = {})) })(spine || (spine = {})); var spine; (function (b) { var a = (function (d) { __extends(c, d); function c(e) { var f = d.call(this, e) || this; f.color = new b.Color(1, 1, 1, 1); return f } c.prototype.copy = function () { var e = new c(name); this.copyTo(e); e.color.setFromColor(this.color); return e }; return c }(b.VertexAttachment)); b.BoundingBoxAttachment = a })(spine || (spine = {})); var spine; (function (a) { var b = (function (c) { __extends(d, c); function d(e) { var f = c.call(this, e) || this; f.color = new a.Color(0.2275, 0.2275, 0.8078, 1); return f } d.prototype.copy = function () { var e = new d(name); this.copyTo(e); e.endSlot = this.endSlot; e.color.setFromColor(this.color); return e }; return d }(a.VertexAttachment)); a.ClippingAttachment = b })(spine || (spine = {})); var spine; (function (b) { var a = (function (d) { __extends(c, d); function c(e) { var f = d.call(this, e) || this; f.color = new b.Color(1, 1, 1, 1); f.tempColor = new b.Color(0, 0, 0, 0); return f } c.prototype.updateUVs = function () { var k = this.regionUVs; if (this.uvs == null || this.uvs.length != k.length) { this.uvs = b.Utils.newFloatArray(k.length) } var g = this.uvs; var f = this.uvs.length; var p = this.region.u, o = this.region.v, e = 0, q = 0; if (this.region instanceof b.TextureAtlasRegion) { var l = this.region; var j = l.texture.getImage().width, m = l.texture.getImage().height; switch (l.degrees) { case 90: p -= (l.originalHeight - l.offsetY - l.height) / j; o -= (l.originalWidth - l.offsetX - l.width) / m; e = l.originalHeight / j; q = l.originalWidth / m; for (var h = 0; h < f; h += 2) { g[h] = p + k[h + 1] * e; g[h + 1] = o + (1 - k[h]) * q } return; case 180: p -= (l.originalWidth - l.offsetX - l.width) / j; o -= l.offsetY / m; e = l.originalWidth / j; q = l.originalHeight / m; for (var h = 0; h < f; h += 2) { g[h] = p + (1 - k[h]) * e; g[h + 1] = o + (1 - k[h + 1]) * q } return; case 270: p -= l.offsetY / j; o -= l.offsetX / m; e = l.originalHeight / j; q = l.originalWidth / m; for (var h = 0; h < f; h += 2) { g[h] = p + (1 - k[h + 1]) * e; g[h + 1] = o + k[h] * q } return }p -= l.offsetX / j; o -= (l.originalHeight - l.offsetY - l.height) / m; e = l.originalWidth / j; q = l.originalHeight / m } else { if (this.region == null) { p = o = 0; e = q = 1 } else { e = this.region.u2 - p; q = this.region.v2 - o } } for (var h = 0; h < f; h += 2) { g[h] = p + k[h] * e; g[h + 1] = o + k[h + 1] * q } }; c.prototype.getParentMesh = function () { return this.parentMesh }; c.prototype.setParentMesh = function (e) { this.parentMesh = e; if (e != null) { this.bones = e.bones; this.vertices = e.vertices; this.worldVerticesLength = e.worldVerticesLength; this.regionUVs = e.regionUVs; this.triangles = e.triangles; this.hullLength = e.hullLength; this.worldVerticesLength = e.worldVerticesLength } }; c.prototype.copy = function () { if (this.parentMesh != null) { return this.newLinkedMesh() } var e = new c(this.name); e.region = this.region; e.path = this.path; e.color.setFromColor(this.color); this.copyTo(e); e.regionUVs = new Array(this.regionUVs.length); b.Utils.arrayCopy(this.regionUVs, 0, e.regionUVs, 0, this.regionUVs.length); e.uvs = new Array(this.uvs.length); b.Utils.arrayCopy(this.uvs, 0, e.uvs, 0, this.uvs.length); e.triangles = new Array(this.triangles.length); b.Utils.arrayCopy(this.triangles, 0, e.triangles, 0, this.triangles.length); e.hullLength = this.hullLength; if (this.edges != null) { e.edges = new Array(this.edges.length); b.Utils.arrayCopy(this.edges, 0, e.edges, 0, this.edges.length) } e.width = this.width; e.height = this.height; return e }; c.prototype.newLinkedMesh = function () { var e = new c(this.name); e.region = this.region; e.path = this.path; e.color.setFromColor(this.color); e.deformAttachment = this.deformAttachment; e.setParentMesh(this.parentMesh != null ? this.parentMesh : this); e.updateUVs(); return e }; return c }(b.VertexAttachment)); b.MeshAttachment = a })(spine || (spine = {})); var spine; (function (b) { var a = (function (d) { __extends(c, d); function c(e) { var f = d.call(this, e) || this; f.closed = false; f.constantSpeed = false; f.color = new b.Color(1, 1, 1, 1); return f } c.prototype.copy = function () { var e = new c(name); this.copyTo(e); e.lengths = new Array(this.lengths.length); b.Utils.arrayCopy(this.lengths, 0, e.lengths, 0, this.lengths.length); e.closed = closed; e.constantSpeed = this.constantSpeed; e.color.setFromColor(this.color); return e }; return c }(b.VertexAttachment)); b.PathAttachment = a })(spine || (spine = {})); var spine; (function (b) { var a = (function (d) { __extends(c, d); function c(e) { var f = d.call(this, e) || this; f.color = new b.Color(0.38, 0.94, 0, 1); return f } c.prototype.computeWorldPosition = function (f, e) { e.x = this.x * f.a + this.y * f.b + f.worldX; e.y = this.x * f.c + this.y * f.d + f.worldY; return e }; c.prototype.computeWorldRotation = function (h) { var g = b.MathUtils.cosDeg(this.rotation), f = b.MathUtils.sinDeg(this.rotation); var e = g * h.a + f * h.b; var i = g * h.c + f * h.d; return Math.atan2(i, e) * b.MathUtils.radDeg }; c.prototype.copy = function () { var e = new c(name); e.x = this.x; e.y = this.y; e.rotation = this.rotation; e.color.setFromColor(this.color); return e }; return c }(b.VertexAttachment)); b.PointAttachment = a })(spine || (spine = {})); var spine; (function (b) { var a = (function (d) { __extends(c, d); function c(e) { var f = d.call(this, e) || this; f.x = 0; f.y = 0; f.scaleX = 1; f.scaleY = 1; f.rotation = 0; f.width = 0; f.height = 0; f.color = new b.Color(1, 1, 1, 1); f.offset = b.Utils.newFloatArray(8); f.uvs = b.Utils.newFloatArray(8); f.tempColor = new b.Color(1, 1, 1, 1); return f } c.prototype.updateOffset = function () { var t = this.width / this.region.originalWidth * this.scaleX; var s = this.height / this.region.originalHeight * this.scaleY; var f = -this.width / 2 * this.scaleX + this.region.offsetX * t; var v = -this.height / 2 * this.scaleY + this.region.offsetY * s; var k = f + this.region.width * t; var r = v + this.region.height * s; var u = this.rotation * Math.PI / 180; var g = Math.cos(u); var e = Math.sin(u); var m = f * g + this.x; var l = f * e; var p = v * g + this.y; var n = v * e; var q = k * g + this.x; var o = k * e; var i = r * g + this.y; var h = r * e; var j = this.offset; j[c.OX1] = m - n; j[c.OY1] = p + l; j[c.OX2] = m - h; j[c.OY2] = i + l; j[c.OX3] = q - h; j[c.OY3] = i + o; j[c.OX4] = q - n; j[c.OY4] = p + o }; c.prototype.setRegion = function (f) { this.region = f; var e = this.uvs; if (f.rotate) { e[2] = f.u; e[3] = f.v2; e[4] = f.u; e[5] = f.v; e[6] = f.u2; e[7] = f.v; e[0] = f.u2; e[1] = f.v2 } else { e[0] = f.u; e[1] = f.v2; e[2] = f.u; e[3] = f.v; e[4] = f.u2; e[5] = f.v; e[6] = f.u2; e[7] = f.v2 } }; c.prototype.computeWorldVertices = function (q, f, g, e) { var k = this.offset; var p = q.worldX, n = q.worldY; var o = q.a, m = q.b, l = q.c, j = q.d; var i = 0, h = 0; i = k[c.OX1]; h = k[c.OY1]; f[g] = i * o + h * m + p; f[g + 1] = i * l + h * j + n; g += e; i = k[c.OX2]; h = k[c.OY2]; f[g] = i * o + h * m + p; f[g + 1] = i * l + h * j + n; g += e; i = k[c.OX3]; h = k[c.OY3]; f[g] = i * o + h * m + p; f[g + 1] = i * l + h * j + n; g += e; i = k[c.OX4]; h = k[c.OY4]; f[g] = i * o + h * m + p; f[g + 1] = i * l + h * j + n }; c.prototype.copy = function () { var e = new c(this.name); e.region = this.region; e.rendererObject = this.rendererObject; e.path = this.path; e.x = this.x; e.y = this.y; e.scaleX = this.scaleX; e.scaleY = this.scaleY; e.rotation = this.rotation; e.width = this.width; e.height = this.height; b.Utils.arrayCopy(this.uvs, 0, e.uvs, 0, 8); b.Utils.arrayCopy(this.offset, 0, e.offset, 0, 8); e.color.setFromColor(this.color); return e }; c.OX1 = 0; c.OY1 = 1; c.OX2 = 2; c.OY2 = 3; c.OX3 = 4; c.OY3 = 5; c.OX4 = 6; c.OY4 = 7; c.X1 = 0; c.Y1 = 1; c.C1R = 2; c.C1G = 3; c.C1B = 4; c.C1A = 5; c.U1 = 6; c.V1 = 7; c.X2 = 8; c.Y2 = 9; c.C2R = 10; c.C2G = 11; c.C2B = 12; c.C2A = 13; c.U2 = 14; c.V2 = 15; c.X3 = 16; c.Y3 = 17; c.C3R = 18; c.C3G = 19; c.C3B = 20; c.C3A = 21; c.U3 = 22; c.V3 = 23; c.X4 = 24; c.Y4 = 25; c.C4R = 26; c.C4G = 27; c.C4B = 28; c.C4A = 29; c.U4 = 30; c.V4 = 31; return c }(b.Attachment)); b.RegionAttachment = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(e, d) { this.jitterX = 0; this.jitterY = 0; this.jitterX = e; this.jitterY = d } c.prototype.begin = function (d) { }; c.prototype.transform = function (d, g, e, f) { d.x += b.MathUtils.randomTriangular(-this.jitterX, this.jitterY); d.y += b.MathUtils.randomTriangular(-this.jitterX, this.jitterY) }; c.prototype.end = function () { }; return c }()); b.JitterEffect = a })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(d) { this.centerX = 0; this.centerY = 0; this.radius = 0; this.angle = 0; this.worldX = 0; this.worldY = 0; this.radius = d } c.prototype.begin = function (d) { this.worldX = d.x + this.centerX; this.worldY = d.y + this.centerY }; c.prototype.transform = function (g, e, f, j) { var l = this.angle * b.MathUtils.degreesToRadians; var m = g.x - this.worldX; var k = g.y - this.worldY; var i = Math.sqrt(m * m + k * k); if (i < this.radius) { var d = c.interpolation.apply(0, l, (this.radius - i) / this.radius); var n = Math.cos(d); var h = Math.sin(d); g.x = n * m - h * k + this.worldX; g.y = h * m + n * k + this.worldY } }; c.prototype.end = function () { }; c.interpolation = new b.PowOut(2); return c }()); b.SwirlEffect = a })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function (f) { __extends(e, f); function e(g, h) { if (h === void 0) { h = "" } return f.call(this, function (i) { return new b.webgl.GLTexture(g, i) }, h) || this } return e }(b.AssetManager)); d.AssetManager = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function () { function e(f, g) { this.position = new d.Vector3(0, 0, 0); this.direction = new d.Vector3(0, 0, -1); this.up = new d.Vector3(0, 1, 0); this.near = 0; this.far = 100; this.zoom = 1; this.viewportWidth = 0; this.viewportHeight = 0; this.projectionView = new d.Matrix4(); this.inverseProjectionView = new d.Matrix4(); this.projection = new d.Matrix4(); this.view = new d.Matrix4(); this.tmp = new d.Vector3(); this.viewportWidth = f; this.viewportHeight = g; this.update() } e.prototype.update = function () { var f = this.projection; var h = this.view; var l = this.projectionView; var k = this.inverseProjectionView; var j = this.zoom, g = this.viewportWidth, i = this.viewportHeight; f.ortho(j * (-g / 2), j * (g / 2), j * (-i / 2), j * (i / 2), this.near, this.far); h.lookAt(this.position, this.direction, this.up); l.set(f.values); l.multiply(h); k.set(l.values).invert() }; e.prototype.screenToWorld = function (h, i, k) { var f = h.x, j = k - h.y - 1; var g = this.tmp; g.x = (2 * f) / i - 1; g.y = (2 * j) / k - 1; g.z = (2 * h.z) - 1; g.project(this.inverseProjectionView); h.set(g.x, g.y, g.z); return h }; e.prototype.setViewport = function (f, g) { this.viewportWidth = f; this.viewportHeight = g }; return e }()); d.OrthoCamera = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function (f) { __extends(e, f); function e(h, i, g) { if (g === void 0) { g = false } var j = f.call(this, i) || this; j.texture = null; j.boundUnit = 0; j.useMipMaps = false; j.context = h instanceof d.ManagedWebGLRenderingContext ? h : new d.ManagedWebGLRenderingContext(h); j.useMipMaps = g; j.restore(); j.context.addRestorable(j); return j } e.prototype.setFilters = function (g, h) { var i = this.context.gl; this.bind(); i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, g); i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, e.validateMagFilter(h)) }; e.validateMagFilter = function (g) { switch (g) { case b.TextureFilter.MipMap: case b.TextureFilter.MipMapLinearLinear: case b.TextureFilter.MipMapLinearNearest: case b.TextureFilter.MipMapNearestLinear: case b.TextureFilter.MipMapNearestNearest: return b.TextureFilter.Linear; default: return g } }; e.prototype.setWraps = function (g, h) { var i = this.context.gl; this.bind(); i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, g); i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, h) }; e.prototype.update = function (g) { var h = this.context.gl; if (!this.texture) { this.texture = this.context.gl.createTexture() } this.bind(); if (e.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL) { h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) } h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, this._image); h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR); h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, g ? h.LINEAR_MIPMAP_LINEAR : h.LINEAR); h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE); h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE); if (g) { h.generateMipmap(h.TEXTURE_2D) } }; e.prototype.restore = function () { this.texture = null; this.update(this.useMipMaps) }; e.prototype.bind = function (g) { if (g === void 0) { g = 0 } var h = this.context.gl; this.boundUnit = g; h.activeTexture(h.TEXTURE0 + g); h.bindTexture(h.TEXTURE_2D, this.texture) }; e.prototype.unbind = function () { var g = this.context.gl; g.activeTexture(g.TEXTURE0 + this.boundUnit); g.bindTexture(g.TEXTURE_2D, null) }; e.prototype.dispose = function () { this.context.removeRestorable(this); var g = this.context.gl; g.deleteTexture(this.texture) }; e.DISABLE_UNPACK_PREMULTIPLIED_ALPHA_WEBGL = false; return e }(b.Texture)); d.GLTexture = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var e = (function () { function f(g) { this.lastX = 0; this.lastY = 0; this.buttonDown = false; this.currTouch = null; this.touchesPool = new b.Pool(function () { return new b.webgl.Touch(0, 0, 0) }); this.listeners = new Array(); this.element = g; this.setupCallbacks(g) } f.prototype.setupCallbacks = function (j) { var k = this; var h = function (p) { if (p instanceof MouseEvent) { var o = j.getBoundingClientRect(); var l = p.clientX - o.left; var q = p.clientY - o.top; var n = k.listeners; for (var m = 0; m < n.length; m++) { if (n[m].down) { n[m].down(l, q) } } k.lastX = l; k.lastY = q; k.buttonDown = true; document.addEventListener("mousemove", i); document.addEventListener("mouseup", g) } }; var i = function (p) { if (p instanceof MouseEvent) { var o = j.getBoundingClientRect(); var l = p.clientX - o.left; var q = p.clientY - o.top; var n = k.listeners; for (var m = 0; m < n.length; m++) { if (k.buttonDown) { if (n[m].dragged) { n[m].dragged(l, q) } } else { if (n[m].moved) { n[m].moved(l, q) } } } k.lastX = l; k.lastY = q } }; var g = function (p) { if (p instanceof MouseEvent) { var o = j.getBoundingClientRect(); var l = p.clientX - o.left; var q = p.clientY - o.top; var n = k.listeners; for (var m = 0; m < n.length; m++) { if (n[m].up) { n[m].up(l, q) } } k.lastX = l; k.lastY = q; k.buttonDown = false; document.removeEventListener("mousemove", i); document.removeEventListener("mouseup", g) } }; j.addEventListener("mousedown", h, true); j.addEventListener("mousemove", i, true); j.addEventListener("mouseup", g, true); j.addEventListener("touchstart", function (q) { if (k.currTouch != null) { return } var n = q.changedTouches; for (var m = 0; m < n.length; m++) { var l = n[m]; var r = j.getBoundingClientRect(); var s = l.clientX - r.left; var p = l.clientY - r.top; k.currTouch = k.touchesPool.obtain(); k.currTouch.identifier = l.identifier; k.currTouch.x = s; k.currTouch.y = p; break } var o = k.listeners; for (var t = 0; t < o.length; t++) { if (o[t].down) { o[t].down(k.currTouch.x, k.currTouch.y) } } k.lastX = k.currTouch.x; k.lastY = k.currTouch.y; k.buttonDown = true; q.preventDefault() }, false); j.addEventListener("touchend", function (q) { var n = q.changedTouches; for (var m = 0; m < n.length; m++) { var l = n[m]; if (k.currTouch.identifier === l.identifier) { var r = j.getBoundingClientRect(); var t = k.currTouch.x = l.clientX - r.left; var p = k.currTouch.y = l.clientY - r.top; k.touchesPool.free(k.currTouch); var o = k.listeners; for (var s = 0; s < o.length; s++) { if (o[s].up) { o[s].up(t, p) } } k.lastX = t; k.lastY = p; k.buttonDown = false; k.currTouch = null; break } } q.preventDefault() }, false); j.addEventListener("touchcancel", function (r) { var n = r.changedTouches; for (var m = 0; m < n.length; m++) { var l = n[m]; if (k.currTouch.identifier === l.identifier) { var s = j.getBoundingClientRect(); var t = k.currTouch.x = l.clientX - s.left; var q = k.currTouch.y = l.clientY - s.top; k.touchesPool.free(k.currTouch); var o = k.listeners; for (var p = 0; p < o.length; p++) { if (o[p].up) { o[p].up(t, q) } } k.lastX = t; k.lastY = q; k.buttonDown = false; k.currTouch = null; break } } r.preventDefault() }, false); j.addEventListener("touchmove", function (q) { if (k.currTouch == null) { return } var n = q.changedTouches; for (var m = 0; m < n.length; m++) { var l = n[m]; if (k.currTouch.identifier === l.identifier) { var r = j.getBoundingClientRect(); var t = l.clientX - r.left; var p = l.clientY - r.top; var o = k.listeners; for (var s = 0; s < o.length; s++) { if (o[s].dragged) { o[s].dragged(t, p) } } k.lastX = k.currTouch.x = t; k.lastY = k.currTouch.y = p; break } } q.preventDefault() }, false) }; f.prototype.addListener = function (g) { this.listeners.push(g) }; f.prototype.removeListener = function (h) { var g = this.listeners.indexOf(h); if (g > -1) { this.listeners.splice(g, 1) } }; return f }()); d.Input = e; var c = (function () { function f(h, g, i) { this.identifier = h; this.x = g; this.y = i } return f }()); d.Touch = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function () { function e(g) { this.logo = null; this.spinner = null; this.angle = 0; this.fadeOut = 0; this.timeKeeper = new b.TimeKeeper(); this.backgroundColor = new b.Color(0.135, 0.135, 0.135, 1); this.tempColor = new b.Color(); this.firstDraw = 0; this.renderer = g; this.timeKeeper.maxDelta = 9; if (e.logoImg === null) { var f = navigator.userAgent.indexOf("Safari") > -1; e.logoImg = new Image(); e.logoImg.src = e.SPINE_LOGO_DATA; if (!f) { e.logoImg.crossOrigin = "anonymous" } e.logoImg.onload = function (h) { e.loaded++ }; e.spinnerImg = new Image(); e.spinnerImg.src = e.SPINNER_DATA; if (!f) { e.spinnerImg.crossOrigin = "anonymous" } e.spinnerImg.onload = function (h) { e.loaded++ } } } e.prototype.draw = function (h) { if (h === void 0) { h = false } if (h && this.fadeOut > e.FADE_SECONDS) { return } this.timeKeeper.update(); var n = Math.abs(Math.sin(this.timeKeeper.totalTime + 0.75)); this.angle -= this.timeKeeper.delta / 1.4 * 360 * (1 + 1.5 * Math.pow(n, 5)); var l = this.renderer; var i = l.canvas; var k = l.context.gl; l.resize(d.ResizeMode.Stretch); var p = l.camera.position.x, o = l.camera.position.y; l.camera.position.set(i.width / 2, i.height / 2, 0); l.camera.viewportWidth = i.width; l.camera.viewportHeight = i.height; if (!h) { k.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a); k.clear(k.COLOR_BUFFER_BIT); this.tempColor.a = 1 } else { this.fadeOut += this.timeKeeper.delta * (this.timeKeeper.totalTime < 1 ? 2 : 1); if (this.fadeOut > e.FADE_SECONDS) { l.camera.position.set(p, o, 0); return } n = 1 - this.fadeOut / e.FADE_SECONDS; this.tempColor.setFromColor(this.backgroundColor); this.tempColor.a = 1 - (n - 1) * (n - 1); l.begin(); l.quad(true, 0, 0, i.width, 0, i.width, i.height, 0, i.height, this.tempColor, this.tempColor, this.tempColor, this.tempColor); l.end() } this.tempColor.set(1, 1, 1, this.tempColor.a); if (e.loaded != 2) { return } if (this.logo === null) { this.logo = new d.GLTexture(l.context, e.logoImg); this.spinner = new d.GLTexture(l.context, e.spinnerImg) } this.logo.update(false); this.spinner.update(false); var m = this.logo.getImage().width; var j = this.logo.getImage().height; var g = this.spinner.getImage().width; var f = this.spinner.getImage().height; l.batcher.setBlendMode(k.SRC_ALPHA, k.ONE_MINUS_SRC_ALPHA); l.begin(); l.drawTexture(this.logo, (i.width - m) / 2, (i.height - j) / 2, m, j, this.tempColor); l.drawTextureRotated(this.spinner, (i.width - g) / 2, (i.height - f) / 2, g, f, g / 2, f / 2, this.angle, this.tempColor); l.end(); l.camera.position.set(p, o, 0) }; e.FADE_SECONDS = 1; e.loaded = 0; e.spinnerImg = null; e.logoImg = null; e.SPINNER_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKMAAACjCAYAAADmbK6AAAAACXBIWXMAAAsTAAALEwEAmpwYAAALB2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNS41IChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTgtMTEtMTVUMTY6NDA6NTkrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpmZDhlNTljMC02NGJjLTIxNGQtODAyZi1jZDlhODJjM2ZjMGMiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpmYmNmZWJlYS03MjY2LWE0NGQtOTI4NS0wOTJmNGNhYzk4ZWEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpZUmVzb2x1dGlvbj0iNzIwMDAwLzEwMDAwIiB0aWZmOlJlc29sdXRpb25Vbml0PSIyIiBleGlmOkNvbG9yU3BhY2U9IjY1NTM1IiBleGlmOlBpeGVsWERpbWVuc2lvbj0iMjk3IiBleGlmOlBpeGVsWURpbWVuc2lvbj0iMjQyIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHN0RXZ0OndoZW49IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiNThlMTlkNi0xYTRjLTQyNDEtODU0ZC01MDVlZjYxMjRhODQiIHN0RXZ0OndoZW49IjIwMTgtMTEtMTVUMTY6NDA6MjMrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ3YzYzYzIwLWJkYjgtYzM0YS1hYzMyLWQ5MDdjOWEyOTA0MCIgc3RFdnQ6d2hlbj0iMjAxOC0xMS0xNVQxNjo0MDo1OSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZmQ4ZTU5YzAtNjRiYy0yMTRkLTgwMmYtY2Q5YTgyYzNmYzBjIiBzdEV2dDp3aGVuPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0N2M2M2MyMC1iZGI4LWMzNGEtYWMzMi1kOTA3YzlhMjkwNDAiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2OWRmZjljYy01YzFiLWE5NDctOTc3OS03ODgxZjM0ODk3MDMiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiLz4gPHBob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPHJkZjpCYWc+IDxyZGY6bGk+eG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2U8L3JkZjpsaT4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7qS4aQAAAKZElEQVR42u2de4xVxR3HP8dd3rQryPKo4dGNbtVAQRa1YB93E1tTS7VYqCBiSWhsqGltSx+0xD60tKBorYnNkkBtFUt9xJaGNGlty6EqRAK1KlalshK2C8tzpcIigpz+MbPr5e5y987dM2fv4/tJbjC7v3P2+JvPnTMzZ85MEEURQhQClUpB7gRBAECUYiYwH6gDqoEKoA1oBDYCy4OQJgB92R3yq2S5yRilWASs6CZ0DzA5CNmn/ObOOUpB7kQpRgNLcwj9AHCnMiYZfXIT0C/H2DlRSs0gyeiPaQ6xg4FapUwy+mKUY/wwpUwy+uK4Y/xhpUwy+mKfY3yTUiYZfdHiENsahBxRyiSjL5odYncpXZLRJ3sdYhuVLslYKDKqZpSMBXObVs0oGQumA6OaUTL6Iwg5CBzNMXy7MiYZffNCDjH7g5DdSpVk9M36mGKEZOwxq4Fj3cT8UmmSjEm0Gw8At2UJaQhCtilTeeRWM5EdkmVfOwCIUtQBE4AqILC1ZQuwPgjpSKryWwgy1gfZfjsQ886IKFY2xO9N0jOR69srDOAtzCyYFuCUSrcg6AOcBIYCY4C3gVeT+uNJyvg94GPAxzFjcDuBl4C/AP+UBwXBR4AaYDYwDvgr8Drwi1KScRnwXfut6wNcYT+7Ma97LgX+JRd6jfOAucAXgCvTfl4DvAuMtJVJ0cu41IoYWRHTGWM/1TZmq/2fF8nR14r4U2BQF7+LgMW2k7bY54X4Htr5EvD99s5SlriPArcAY+VGsh1YYDpwMzAgSwy2svhWscpYA/wkx9gKm5S5wBA5kgjnAJcDX7NNpVxcWAZMLUYZJwHDHeKrgXnAdWjZlSS4BLgVuMzRlxt9eeNTxsG2veFyy7gQWAR8Sq54byfeYDssAx3LqLabJldBytgMHMjjuPHAQvTOsU++aJtE/fI4dpevTqZPGV+2veN8+DTwIHCBr29hmVJhJXwA+GAex7cBjxZjm7EFWAL8DfeX39s7NPOy9PKEO7XAV+k8xJYLrcDPgL8Xo4xgJqIuA7bkeXw9ZsBVxMMMYEqex64FfuO7e++bTcAPgD8Bpx2PvRSYKIdi61DOs3edXImAV4Cv2zJsKnYZ24B/AJ+xteRrwAmHBF4mj2JhEnCRg4QnrYh3YZ5NH/J9gUmP5zXYtsdsW+Pl8vffkEex8I5D7HHgGeBhe0dLhKRlbMJM298NXI8Z68rGk8AGeRQLu4DHMGOL2dgJPA78AXguyQvsjScdrTYp2zBDPzfbXl7mmNc64B7MFCbRc/bbfPYHrs343WnbZHsG+BXwZ8y65JS6jOnfwPuBg8BnMQtxjsWsh/0IsNJ2fkR8bAHutbfhG2x7vp9tDzZiFs5/Non2YaHJ2N6OWQf8BxiBeRx4EDPZ9nm544WNVsLtwFWYJ2Wh/fmO3ryw3noHpiv6YyZ5NsuXROhrRypeAv7nfHQJvAOTjbclYuJ3pWcL6YL03rSQjEJIRiEZhZCMQjIKIRmFZBRCMgrJKIRkFJJRCMkoJKMQklFIRiEkoxCSUUhGISSjkIxCSEYhGYWQjEIyCiEZhWQUQjIKySiEZBSSUQjJKCSjEAVCJUAQmCWPoxSjgZuAaZgF348D+zD7ADYDe+2nGWgJQg52dVJvSzOLgqHdmU5ln2IYZou9861Do+x/j8Ss2z7AOrQJWBOEZtetKIrMmt5BEBClWAQsxW3b16OY/QHXA6uD0GzpG0VRPmt6i2KSMeyQrxpYgNl4dCJmV7NcOQEsCULu6ZCR+mAmZiOannAMuC0IWS0Zy0PGKMUCzFZug3p4ullsiJ5obzPOj+H6BgGrohR1KqrSx5bzqhhE7PCvXcY4BZqgoioL4iznunQZq2M8cZXKqSyIs5yr02WsiPHEaiyWSbMxxnNVpMvYFuOJj6mcyoI4y7ktXcbGGE/conIqC+Is58Z0GTfGdNIGzJijKH3W2/KOg43pMi4n//2F92P2KJ4ShCwMQvT4pRwajCFRELIQmGLLf3+ep9pj/TvjCcwI4E5gDp1H0VsxO7k3Zvy7PQjZnXl2DXqXhYydiFKMAcYD44CajH+HZIQfBdYCtwch+854HJh2wkqgFhgGHAaagpAjLhcqGctTxqxOpKgCRgNDMXuK7whCTqU7U9khz3ucAv59xomUe9FVhePGEfs5q1eaQiYKBskoJKMQklFIRiEko5CMQkhGIRmFkIxCMgohGYVkFEIyCskohGQUklEIySiEZBSSUQjJKCSjEJJRSEYhJKOQjEJIRiEZhZCMQjIKIRmFZBSijGXMvIZ+KpZEaF8qeygwHOjb2xdUWQBJqQL6ADOBi4GHMGuGH5Iv3hiG2SJtIWaV4mZgB/AadF6jvVxkvAKzv3UdMNX+bDJm9fx10PV+1qLHIl4P3GLzfh3QBLwKbAZ+DJwuFxkDm5CZmN0Vzsv4/TTMyviVwGOYnRZEPAwBZgDfAC5K+/lo+5kKXAjcBzwPnCz1NuP77LfxO12I2M7FNmFXE+++huVOPfDNDBEz25FzgHuBa4Bzk8x/0jJeCiwCFmP2BsnGh4BbgYFyKDZmZRExnTpbGcywHZySuk0PsbeAG4HZDt+2C6yMb8mjWHgXs+NFd5v09Ac+AYzC7An0EPBKqdSM1wDfBqY7Vvubk263lDhPYHamypVa4MvAHUCq2GvGgcB8YAEwKQ/5nwa33blEVrYDLwJXOhxzLvBJzDhkK/BCMdaMA4C5wF2Y4RrXv7UF+KO9tYh42A08msfoRxVwLfBDYGwxyliLGUMclMexL9rOy075EyvvAKuBlcCbeTa3Pl+MMk7GbP/qyiHg18BWueOFNnu3ymeP8X62h11dbDKm7K3a9Zv7e+BJOeOVRmCNvQO5cgmdt4AueBkH5zCE0FWHpQH4r3zxzlPAw3kcdxg4VmwybnaMfx1YAWxTpyURjtj24wpHuZ7C0yNanzL+FnjZIX4lsEGOJEorcDewKcf4vTb+ZLHJuAeYBxzvJm4/8CPg58AJ+ZE4BzBDNk93k//jwOeAN4qxNw1m5sdV9jZwtlvv48ADujX3GpFtUt0OhPZnJzN63wdtOW7xeSFJPJvehBnBv8/2ricAp2wb8UHgETRvsRDYCiy3IrbPCWi0Mt4BPOf7AoIoivycub5TR/rDmBkjs4Df2fbHJjlQcLwfuNyW13rMXILOkyQ2REUtI5jnnG+mNRFOF3Gh1dlavgozhHUMaLEFGJWImBVnbT4VlYwlSBCYL1iUYgGw6ixhDUHIwo4GmfIrGX3JGKWotj3KbM/cpwQh2yRjYfWmS5EFdD/54ytKk2RMgukxxQjJ2GMm5hAzPEoxRqmSjN6IUgwj9xkr45UxyeiTkQ6x45QuyeiT8x1ia5QuyeiTUaoZJWMxyqiaUTIWzG1aNaNkLJgOzJAoRZVSJhl9McIxfrRSJhl94fq241ClTDL6Yq9jvCYNS0ZvuEwGPopZmlhIRi+sIfeXxtYGIaeUMsnohSCkCViSQ+gezAtOwiW/mvzpkKz3ZnrPxCz1V4dZd6YC8+JSI2YNm+VWXE2ulYyiGPk/nslB8d6ayMkAAAAASUVORK5CYII="; e.SPINE_LOGO_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKUAAABsCAYAAAALzHKmAAAACXBIWXMAAAsTAAALEwEAmpwYAAALB2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNS41IChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTgtMTEtMTVUMTY6NDA6NTkrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowMTdhZGQ3Ni04OTZlLThlNGUtYmM5MS00ZjEyNjI1YjA3MjgiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDplMTViNGE2ZS1hMDg3LWEzNDktODdhOS1mNDYzYjE2MzQ0Y2MiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHRpZmY6T3JpZW50YXRpb249IjEiIHRpZmY6WFJlc29sdXRpb249IjcyMDAwMC8xMDAwMCIgdGlmZjpZUmVzb2x1dGlvbj0iNzIwMDAwLzEwMDAwIiB0aWZmOlJlc29sdXRpb25Vbml0PSIyIiBleGlmOkNvbG9yU3BhY2U9IjY1NTM1IiBleGlmOlBpeGVsWERpbWVuc2lvbj0iMjk3IiBleGlmOlBpeGVsWURpbWVuc2lvbj0iMjQyIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiIHN0RXZ0OndoZW49IjIwMTYtMDktMDhUMTQ6MjU6MTIrMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiNThlMTlkNi0xYTRjLTQyNDEtODU0ZC01MDVlZjYxMjRhODQiIHN0RXZ0OndoZW49IjIwMTgtMTEtMTVUMTY6NDA6MjMrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjJlNjJiMWM2LWIxYzQtNDk0MC04MDMxLWU4ZDkyNTBmODJjNSIgc3RFdnQ6d2hlbj0iMjAxOC0xMS0xNVQxNjo0MDo1OSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDE3YWRkNzYtODk2ZS04ZTRlLWJjOTEtNGYxMjYyNWIwNzI4IiBzdEV2dDp3aGVuPSIyMDE4LTExLTE1VDE2OjQwOjU5KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyZTYyYjFjNi1iMWM0LTQ5NDAtODAzMS1lOGQ5MjUwZjgyYzUiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2OWRmZjljYy01YzFiLWE5NDctOTc3OS03ODgxZjM0ODk3MDMiIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2UiLz4gPHBob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPHJkZjpCYWc+IDxyZGY6bGk+eG1wLmRpZDowODMzNWIyYy04NzYyLWQzNGMtOTBhOS02ODJjYjJmYTQ2M2U8L3JkZjpsaT4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5ayrctAAATYUlEQVR42u2dfVQV553Hv88AXq5uAAlJ0CBem912jQh60kZ8y0tdC5soJnoaXzC4Tdz4cjya1GN206Zqsu3Jpm6yeM5uTG3iaYGoJNFdEY3GaFGD0p4mqS9AXpoV0OZFUOHS3usFuc/+Idde8M7M8zr3gsw5HOCZZ2aemecz39/LPPMMMLAMLDG2kIFzjqmFDiDZP6AkN3gf0gEob8x2kj4MCx2AMnbb1BcVld6IwJJ+0oYb2YTT/gYq6WPHJP3gmtA+Biztr1CSKLevLytprCkh7ctQkj4KsK590hiGlsbSOcVCR5I+BC7pA6BEAzQaq1DqhFFH3Vg16TSG4KHRgNPpyFd1XdIHAyrdCkhjADgaTSiJw/VIP1BSp6GhUQSOOgmlkzASxSqq2zpQB+ClGiGlUb65tAUZOmDUAa5u5XRSgajibVRCR3VCSRyoQwSBE/EvYy3YkYGESuwrpuAkDgPJCg4RhFVUNUkMw6hK6agDcFInoSQxAqNqWHVdD6fUhQqUsfiaVCN41IlOUBEx88JIJCCU8T+tttOR6pEFUgRQXoCVrydRAJJw/G+2jig6llN+p0wnsZpYXsAoxzGognYzryeagBRRR8L5t4iCRsvflDHnIopINcCpGkzlUOoCkqWcKABdlznXZa5lTK7Z/6zlvMeXXqdTCVWoI696ygZN0YZSp/KxQCijmiJgUp3gyQBpVy4Kq4gPqhpWlQrCCxgPeLz70wqmyqcksgELS5kKQEWCIBn1FEn7qFBKKgmnajCloZQtlwWSZR0PoCJBkJMDMnT4iSxlsQCmFJQidVUASQS3ZSlXadqhWDVkTCoLiDKw8t40XOU6oFQBJMtvkSBJ1ITLqKaOgIbVF+y9jd3/omAqVUtViigTTfMAyKqqKnxOlWZcFEzVZjrSb11gaodSRiVVAikCo4hKyjzpkh3No8tf1AUmrxnXCmW0gSSCcIqki4hipbTqGNU+IwuMqsAUfSLVoywezi46gGSFU8Sk86bBKOd1oJzrwuuEQLIbBU8sfiPC37DYhuW8pEfex3NcQBUqyVrO+7edeZdNIfFCSi22oZwdSkzUk1jAaQcrGMA0O34kUJXAaAYl0aSMkRQMjODxAArGct6onPf68CgLbGCkNv4r4axrp4wwUUc7CAnDdkzXJ14SNFHVEQFNRjHtbg7ZoMfuOlHGDiG9/DPCCDgLjDBROFgon50ZV6mQ1/YVzwmgSniJhFryAMpybB4TLjJLRqTOZPUbZYIrwmiqZYC02lboXOIV0C3qm5nVZQGSSCiuaETOe5PygEg4AbXyM1lhJIxqqiWYUQklUaiShMGc2gFpBbDdcXl9StHXka38KVZ/i8V35DXzZibcClIWtRS90ZQpJa/ysZhtHiBV+pk8imm2TjTFwxsQWIHL42PaRd4iroW0ksZLKAFv5MoKbyQQVZl1mShc5LxYOo4Fxt4KyZPysXMhrOrwqKWyHGa8wiCHVSXtzDaxgYSA36xDEk4V5lvGpxRVIZb8pZ0Z571x7My6Up9S17SBhMGvjASfocCUi0TkvOaZMJh11vSPGVSEcT0s1JYyKKnu1BABQOMloeJ9ssMCg53phoKUkVDQs2MMcvNSsZICwfYufPZVB+o/86HxbAAXP/ah9Z2LuPSnAK5wqB1PLlIkmGEBkzVbwKuWolkE6ddXeYeb2akfEfwRTRnZRf89/r84Bf81NB73WtDQ+VUHKocfw1ob35J3QAXrYApq8X94edBmvVUZS9si/Qbr/wacWXgeN/LCCAHAQ+sNhvqhOiQOcNucZMKwQXh42XCkM95AELjZRFNjRCAPSxSmAbXlKXlNOlF0wj2WoqKi5Hnz5mdTGiQA8OCDDx4T6aiNGzeOufnmm5MBoKysrHbfvn3tVhf40hX8MSked1u1LUhx+e1mXGBIz1znC77xxtaJhmFQwzDo3LmPHBdJ6ezZs2cqIVf3UVt7unH16tWNsB4gwpItsPKdlSfTZd4EZH1MKKJkEX8WLfqnlPXr1/8oNTV1QQ8QgsG2pqamX+TkZG+OtP/y8jcn5efnb+nq6vKmpg7NfeONrZOmT5++3uVyZYTvp76+vjg3d8IWs2vy2DDcsunvUDrIQLrZBT3fgXduO4ZnrEx1aWlpbkHBrM0AkJyclFVZWZl3990TngpvT1dXl7e29vRLU6dOLTcxmT3+P3Hi5NLMzMwlhmEkh7fH7/cfraqqemHevLknTMy10yZci/mO2rR5GzZs2JaamrogGAy2Xbx4cWtTU9OLXq93r2EYyR6P52kLdQQAxMXFJR05cvSRGTNmvOZyuTJ8Pl+d1+utCa0fPXr0kydOnHzSzFRu+RLNM09j7qc+vHY5iIbe7Wu7gt8t+wwbGG9YAEBV1eHvT516z0uh9vj9/tpQW7Ozc54rL39zkt1Dh6+/Pl/h8XieNgwjORAInGpqanqxvb19TzAYbHO73VPz8vK2vfXW29kKUnuOLIZitYWFryjlq1RXV890uVxjAWD37oqFo0Z5fjR2bNYvRozIWLFx48b7zpw5s8EmqgYA5OTkrA8EAud2767452HD0ueOGJHxxLp16x7w+Xx1AODxeB5buXLlCDOf9d2L8H7rd3jFfQSzv/MBpjx7BrP/4yzmP1qP76W8j6U7m3HJzpoEg8Fr5ePHj1/n8/nqtmx5fe6wYemPpKffNreysnJxaP2999672sqi/eEPJ5YkJiZmAcDhw1WP3nrrLQVjx2Ztysi4ffmqVSunBAKBU4ZhJE+bNu1VDj81qosRZfVjyU0CABk6dGgmAHR2djYVFRWdCl+3du1Pzo0bl7PZDPxwCHw+X11R0aOPLFy4sCa0vrj4P8+9++7+jaE6P/jBY3NYgrTft8P3s0Y0rPkcn5R9jRaGtNR159zdnieeeuqpulBZYeGCmsbGxtcBwO12jzFT3Iceejh55MiRTwBAQ0PDzwsKCqrDj1NSUuL98MMPX+hW3pHvvXdwqoK+1jELs3KlVGHmbZPVgUBHGwAkJCRklpSUjBW9MB988PvXwwKaa3UWLVpUEwgEzgFAamrqnWYppZ+Owt8eHoeCfdmY/vYYTH43B9/76Nt4tP5uLHlrDCbyntd77x0oPnDggLd3nbNnz9aG/i4vf3NipG1XrFgxKeRD7tq1a2+k4+Tn570fDAbbAOD222/P5uwTJ9/41BJ9izaOKXVQXFxcWVxc/IxhGMmzZj20+5NPPn21vLx8+9q1Pzlrd/xwpWxtbfWawev3+//kcrkyUlJSJpi1618z8cs4guRIx/mmG34Aky2i0+si1bC29VgX1s4e7Q+vl5aWNiJUmJ2dnVlRUTGiWxUpAISi8M7OzqaQ66O4r7UM4HDyxTEpn+XXv/5V2/Tp/1CYn/+PryQkJGSmp6cvXbVq1dLFixdX19TUbJ49++Fjsvm1L774oqYbSMtcpOk6YrqOuwND6S7W/dx///0l6CdLfBQVkntZuHDhqfnz58/84Q9XP5iZmbkgMTExa8iQIZOnTZs2+fPP/2/7HXd8Y63uNrR04vitgzAt0rqvOnAADgyCjbScOXNmAyGEAoBhGNd+E4Jrqrl//77KGwlK6hSY27Zta922bdtWANsrKiomT5iQ+y+JiYlZaWlp83bs2LlvzpzZx0X3PXz48Nyr/utV3zLS8vgn+Onr3wK9ZRDuI93X7wpFW9Nl7J51GpsQpY+4jxuX8yqsHy9SxMAH5p1KCfGAq3R/BQUF1cuXLy8KOfKjRo3KipDQ7bGkpKQkmbXrpptuGg0AXq+33uyglRfQdtsxPJ15HJOL6pE/4xS+m3AY373jt3j59F/gtzn369oUUrXedQn5a3lYnR7n5fP5rvmdW7ZsyXKYHW1fVjMcbqjyLyjs2PF2W0dHx1nWHdx117cfz8vLS+q9r4MHD82Ji4tLAoDm5uY6WM/6gHMBdJZ+jfN7LqAVzn0cqceyb9871X/NZ9433+6GjCXwoqWUvJ1hCUFjY9O/19XVLSssLOwR+R469JsHQsnjy5cvtyHSY6swNRo8ePCdpaVl5WVlZbmhstLS0gnjx49fBVx9vPfssz/eEaFN17VrrQee34zDA59OwIrWKdjsvwf/uysL90TYhjKCyzPvOH3++efPtrS0bO+OxOedOHFyaaR9VldXz2hsbHpRQf9R8E05I8RFvNM+oY1Pavpik8vlykxJSSl85ZVNz7z00svvB4NBEhcXlxwG5OlJkyZuh/mLUSGTVzd48OA7Z84s+OX5883nuvd97Znz0aNH/u3gwYPeCBexRwDzq7/HXYvS8VrvE5mSjO8DOGzRCT0nc+oOTnp3bASzHrFD16xZs2HTpk1ZiYmJWR6P5+lLl1qXBAKBU6H1brd7Snh1sD2rjqqJNxw6sOzkobSqquoFv99/NHShhwwZMjkEZEtLy/Zly5YtMrubwzv40KFDL3/00UfPdXV1eV0uV0YIyEAgcK6iYtcTs2bN2m+iCD3KvuyAN1LDr1D8xSSwuFYW3p7m5mavHRQXLlxoM1FdunPnjtbly5cXNTQ0/DwYDLYZhpHsdrunhH6Aq4MyPv744yWM6kwZ1VFr7tDub7P/HR8lBIAUFRWlRBi2Fn6DXXec0CghAKisrFxcWLjgOABSVlY2MQRG92M+rhfHGnKxZmQiFgAgXRTeLzuwf+Vn+O//aUErg2ljnemMdZQOBUBLSkrGpqXdkhQCPz8/7wjYBveKjBLinenN1nIAoCpHnvNOEGD2zo0RATKrdbZvPJaXvzk5BOXevXsfnz9/Xg3jednlYsnEJAz5hhvuPRdwsfUKuhhUHzYdZjWvJAuwlBE8ltHoVnDa3UDCUKp8omM3QwPrdlb7sVuHSD5luLns/ttquhIzGCP6eMe9aD/uRTtnMAfoeSXCDkie9rGabuX+qFOPGSMFHdREgVjA6w0N7xt2PLNWUCur8ZwHnu8kYWTbFfiS4zHY3wX/nFr8llEZRGG0U1Fq4xebKR+PD6kN1mg80bEC1Awyq1dCbUG0UEpWv9sUrCcz8OOkePR4Xp79N7jr5J8RsIFSdo5yW//SQkV5VZIKmmKhaDxeEkKr90/AYM5Z1NIOFtuX4ktLS08TQhZRSklpaWkt+N+tNl28XfhjOJS+LtSf/DMuC4Aoo5i8QFKbDIFTSfbIT7M4Ah2WYEck+FH9Zh/AN+EVU6RtBuo3B2PQ1tGYlZYAT3sXvljXgMqdzWiTMN0qfEuegEVHlC38eq1IR7BOJgAOIKEATqt9mKWw7CJuFZPx83x+xA5Klq8+iAIJsL8kZrdOGso4zo5gnQhV9qsOVuMheYbYs3yvmmc9lagn+iUGarMPVsW0y5FSAUXXYuLjBXZMBLdhmU02UtBjFQzx+ps850EtoLfzpbnVgUN5VOQxWdVR9MtmUiki1Skhq3wiTIBkgRMCKR/CWM6bV+W581kHL7DkMXk+1sQKJK9VcWQEEq/5FjXhIsGF7Ddt7MDhufAqTBYFlHzuWORLYpRBSXnNtowvKaWULDN42W3D+hkNMOQhAfNEN8/stay5U5nv3/AGPLI5TFa/kgrUlb05uW7gOEF1UqWWdhOk8kS9Ks0uT3BDGbbn8Sl54VTla1qZZ542Sy9xnGkgcAAkOoMukQBT1L+TMfci7gGvOecxsSzmXTaYYTk/nuvODSVLmchH5cH5t+hMuyyjuFmdedFXGyij/waoiXhlHlOyHgsMbY5q9G3le/LOu83ywSHRNBXLY1GRtA9vwMPaqU59wVZFG6DoWkkppajS8XyHW8V3t4lEekP09VS7kTp2Ebmsvyli0kWyBSqsyHVlcYIAyviWsmASThhVBjY84wtZ9suaK5RJy4iaaNa8pVKVNINSRi11gSkSheu4o82UkAVmnhymKIgi0TnA/8hRNPKmqqHkVUsnwBR91Meqjiocd5ZASgQKFT4nT1DDA6TUdSOaymXAFEkniZp7FSOBdAU9LOkVqgBQp4BkLieKgLUqkzXvVuDx7EMEQl35URHoIAmODMAqFJIZyjjNKqriE8a8yXynAxsIdgRrp/KabxkYow6kjFKIqqjKZDnhvAFELYNO8w3Jjuc15yLmmjWoUQZlnIT5UgGmjGqyjLtUrXy6oGRRTl2QivqwrJaJG2KZ5DQvsKwmmccHZVVD2fSSLmXk6XxRSHgVU5U6iqqnFJSyYKqAU+QGiJVAh2oClUdhqeLjSgOpSjFkTbwOVRXNGEDB9aCSwFIFHa3DFZBRfi1Q6gBTFk4Rs63zGijrFIg/ylRt7lW3m6kOUagQqiJ5orFONKJtHR0ok/vUAaPKOrbRt2owZZVTJmhRDaKOYW26I1st06yoBFKmk4jD61UCShSfq1OdpTLgUDW6R8t87rqcfZ1BlMr6uq6Vjhf2owGvozDKmG9dyiQCeTSAiwXVdNIP1A2uls7QkYhW/fgzVgIeXVOe6ISFOnSOjjn+uuHsK5F2NM1hLG/jSGfpjoSdjLSJg7Cp7FjaR7ZzXEGcinBJDF8DnZ1Ho7wPrYNadHdINGCLdVMdrU6nMdimqHYgiaF2kn4IXJ8FMJY6iPRxsPqTksbc55ZJP2vHgOnuYwD2tU4k/eycaT891g0F5YDZ7qfQ3SidTAZgG4By4FwHgBtYBpYbZ/l/2EJnC9N0gaQAAAAASUVORK5CYII="; return e }()); d.LoadingScreen = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { d.M00 = 0; d.M01 = 4; d.M02 = 8; d.M03 = 12; d.M10 = 1; d.M11 = 5; d.M12 = 9; d.M13 = 13; d.M20 = 2; d.M21 = 6; d.M22 = 10; d.M23 = 14; d.M30 = 3; d.M31 = 7; d.M32 = 11; d.M33 = 15; var c = (function () { function e() { this.temp = new Float32Array(16); this.values = new Float32Array(16); var f = this.values; f[d.M00] = 1; f[d.M11] = 1; f[d.M22] = 1; f[d.M33] = 1 } e.prototype.set = function (f) { this.values.set(f); return this }; e.prototype.transpose = function () { var g = this.temp; var f = this.values; g[d.M00] = f[d.M00]; g[d.M01] = f[d.M10]; g[d.M02] = f[d.M20]; g[d.M03] = f[d.M30]; g[d.M10] = f[d.M01]; g[d.M11] = f[d.M11]; g[d.M12] = f[d.M21]; g[d.M13] = f[d.M31]; g[d.M20] = f[d.M02]; g[d.M21] = f[d.M12]; g[d.M22] = f[d.M22]; g[d.M23] = f[d.M32]; g[d.M30] = f[d.M03]; g[d.M31] = f[d.M13]; g[d.M32] = f[d.M23]; g[d.M33] = f[d.M33]; return this.set(g) }; e.prototype.identity = function () { var f = this.values; f[d.M00] = 1; f[d.M01] = 0; f[d.M02] = 0; f[d.M03] = 0; f[d.M10] = 0; f[d.M11] = 1; f[d.M12] = 0; f[d.M13] = 0; f[d.M20] = 0; f[d.M21] = 0; f[d.M22] = 1; f[d.M23] = 0; f[d.M30] = 0; f[d.M31] = 0; f[d.M32] = 0; f[d.M33] = 1; return this }; e.prototype.invert = function () { var f = this.values; var h = this.temp; var g = f[d.M30] * f[d.M21] * f[d.M12] * f[d.M03] - f[d.M20] * f[d.M31] * f[d.M12] * f[d.M03] - f[d.M30] * f[d.M11] * f[d.M22] * f[d.M03] + f[d.M10] * f[d.M31] * f[d.M22] * f[d.M03] + f[d.M20] * f[d.M11] * f[d.M32] * f[d.M03] - f[d.M10] * f[d.M21] * f[d.M32] * f[d.M03] - f[d.M30] * f[d.M21] * f[d.M02] * f[d.M13] + f[d.M20] * f[d.M31] * f[d.M02] * f[d.M13] + f[d.M30] * f[d.M01] * f[d.M22] * f[d.M13] - f[d.M00] * f[d.M31] * f[d.M22] * f[d.M13] - f[d.M20] * f[d.M01] * f[d.M32] * f[d.M13] + f[d.M00] * f[d.M21] * f[d.M32] * f[d.M13] + f[d.M30] * f[d.M11] * f[d.M02] * f[d.M23] - f[d.M10] * f[d.M31] * f[d.M02] * f[d.M23] - f[d.M30] * f[d.M01] * f[d.M12] * f[d.M23] + f[d.M00] * f[d.M31] * f[d.M12] * f[d.M23] + f[d.M10] * f[d.M01] * f[d.M32] * f[d.M23] - f[d.M00] * f[d.M11] * f[d.M32] * f[d.M23] - f[d.M20] * f[d.M11] * f[d.M02] * f[d.M33] + f[d.M10] * f[d.M21] * f[d.M02] * f[d.M33] + f[d.M20] * f[d.M01] * f[d.M12] * f[d.M33] - f[d.M00] * f[d.M21] * f[d.M12] * f[d.M33] - f[d.M10] * f[d.M01] * f[d.M22] * f[d.M33] + f[d.M00] * f[d.M11] * f[d.M22] * f[d.M33]; if (g == 0) { throw new Error("non-invertible matrix") } var i = 1 / g; h[d.M00] = f[d.M12] * f[d.M23] * f[d.M31] - f[d.M13] * f[d.M22] * f[d.M31] + f[d.M13] * f[d.M21] * f[d.M32] - f[d.M11] * f[d.M23] * f[d.M32] - f[d.M12] * f[d.M21] * f[d.M33] + f[d.M11] * f[d.M22] * f[d.M33]; h[d.M01] = f[d.M03] * f[d.M22] * f[d.M31] - f[d.M02] * f[d.M23] * f[d.M31] - f[d.M03] * f[d.M21] * f[d.M32] + f[d.M01] * f[d.M23] * f[d.M32] + f[d.M02] * f[d.M21] * f[d.M33] - f[d.M01] * f[d.M22] * f[d.M33]; h[d.M02] = f[d.M02] * f[d.M13] * f[d.M31] - f[d.M03] * f[d.M12] * f[d.M31] + f[d.M03] * f[d.M11] * f[d.M32] - f[d.M01] * f[d.M13] * f[d.M32] - f[d.M02] * f[d.M11] * f[d.M33] + f[d.M01] * f[d.M12] * f[d.M33]; h[d.M03] = f[d.M03] * f[d.M12] * f[d.M21] - f[d.M02] * f[d.M13] * f[d.M21] - f[d.M03] * f[d.M11] * f[d.M22] + f[d.M01] * f[d.M13] * f[d.M22] + f[d.M02] * f[d.M11] * f[d.M23] - f[d.M01] * f[d.M12] * f[d.M23]; h[d.M10] = f[d.M13] * f[d.M22] * f[d.M30] - f[d.M12] * f[d.M23] * f[d.M30] - f[d.M13] * f[d.M20] * f[d.M32] + f[d.M10] * f[d.M23] * f[d.M32] + f[d.M12] * f[d.M20] * f[d.M33] - f[d.M10] * f[d.M22] * f[d.M33]; h[d.M11] = f[d.M02] * f[d.M23] * f[d.M30] - f[d.M03] * f[d.M22] * f[d.M30] + f[d.M03] * f[d.M20] * f[d.M32] - f[d.M00] * f[d.M23] * f[d.M32] - f[d.M02] * f[d.M20] * f[d.M33] + f[d.M00] * f[d.M22] * f[d.M33]; h[d.M12] = f[d.M03] * f[d.M12] * f[d.M30] - f[d.M02] * f[d.M13] * f[d.M30] - f[d.M03] * f[d.M10] * f[d.M32] + f[d.M00] * f[d.M13] * f[d.M32] + f[d.M02] * f[d.M10] * f[d.M33] - f[d.M00] * f[d.M12] * f[d.M33]; h[d.M13] = f[d.M02] * f[d.M13] * f[d.M20] - f[d.M03] * f[d.M12] * f[d.M20] + f[d.M03] * f[d.M10] * f[d.M22] - f[d.M00] * f[d.M13] * f[d.M22] - f[d.M02] * f[d.M10] * f[d.M23] + f[d.M00] * f[d.M12] * f[d.M23]; h[d.M20] = f[d.M11] * f[d.M23] * f[d.M30] - f[d.M13] * f[d.M21] * f[d.M30] + f[d.M13] * f[d.M20] * f[d.M31] - f[d.M10] * f[d.M23] * f[d.M31] - f[d.M11] * f[d.M20] * f[d.M33] + f[d.M10] * f[d.M21] * f[d.M33]; h[d.M21] = f[d.M03] * f[d.M21] * f[d.M30] - f[d.M01] * f[d.M23] * f[d.M30] - f[d.M03] * f[d.M20] * f[d.M31] + f[d.M00] * f[d.M23] * f[d.M31] + f[d.M01] * f[d.M20] * f[d.M33] - f[d.M00] * f[d.M21] * f[d.M33]; h[d.M22] = f[d.M01] * f[d.M13] * f[d.M30] - f[d.M03] * f[d.M11] * f[d.M30] + f[d.M03] * f[d.M10] * f[d.M31] - f[d.M00] * f[d.M13] * f[d.M31] - f[d.M01] * f[d.M10] * f[d.M33] + f[d.M00] * f[d.M11] * f[d.M33]; h[d.M23] = f[d.M03] * f[d.M11] * f[d.M20] - f[d.M01] * f[d.M13] * f[d.M20] - f[d.M03] * f[d.M10] * f[d.M21] + f[d.M00] * f[d.M13] * f[d.M21] + f[d.M01] * f[d.M10] * f[d.M23] - f[d.M00] * f[d.M11] * f[d.M23]; h[d.M30] = f[d.M12] * f[d.M21] * f[d.M30] - f[d.M11] * f[d.M22] * f[d.M30] - f[d.M12] * f[d.M20] * f[d.M31] + f[d.M10] * f[d.M22] * f[d.M31] + f[d.M11] * f[d.M20] * f[d.M32] - f[d.M10] * f[d.M21] * f[d.M32]; h[d.M31] = f[d.M01] * f[d.M22] * f[d.M30] - f[d.M02] * f[d.M21] * f[d.M30] + f[d.M02] * f[d.M20] * f[d.M31] - f[d.M00] * f[d.M22] * f[d.M31] - f[d.M01] * f[d.M20] * f[d.M32] + f[d.M00] * f[d.M21] * f[d.M32]; h[d.M32] = f[d.M02] * f[d.M11] * f[d.M30] - f[d.M01] * f[d.M12] * f[d.M30] - f[d.M02] * f[d.M10] * f[d.M31] + f[d.M00] * f[d.M12] * f[d.M31] + f[d.M01] * f[d.M10] * f[d.M32] - f[d.M00] * f[d.M11] * f[d.M32]; h[d.M33] = f[d.M01] * f[d.M12] * f[d.M20] - f[d.M02] * f[d.M11] * f[d.M20] + f[d.M02] * f[d.M10] * f[d.M21] - f[d.M00] * f[d.M12] * f[d.M21] - f[d.M01] * f[d.M10] * f[d.M22] + f[d.M00] * f[d.M11] * f[d.M22]; f[d.M00] = h[d.M00] * i; f[d.M01] = h[d.M01] * i; f[d.M02] = h[d.M02] * i; f[d.M03] = h[d.M03] * i; f[d.M10] = h[d.M10] * i; f[d.M11] = h[d.M11] * i; f[d.M12] = h[d.M12] * i; f[d.M13] = h[d.M13] * i; f[d.M20] = h[d.M20] * i; f[d.M21] = h[d.M21] * i; f[d.M22] = h[d.M22] * i; f[d.M23] = h[d.M23] * i; f[d.M30] = h[d.M30] * i; f[d.M31] = h[d.M31] * i; f[d.M32] = h[d.M32] * i; f[d.M33] = h[d.M33] * i; return this }; e.prototype.determinant = function () { var f = this.values; return f[d.M30] * f[d.M21] * f[d.M12] * f[d.M03] - f[d.M20] * f[d.M31] * f[d.M12] * f[d.M03] - f[d.M30] * f[d.M11] * f[d.M22] * f[d.M03] + f[d.M10] * f[d.M31] * f[d.M22] * f[d.M03] + f[d.M20] * f[d.M11] * f[d.M32] * f[d.M03] - f[d.M10] * f[d.M21] * f[d.M32] * f[d.M03] - f[d.M30] * f[d.M21] * f[d.M02] * f[d.M13] + f[d.M20] * f[d.M31] * f[d.M02] * f[d.M13] + f[d.M30] * f[d.M01] * f[d.M22] * f[d.M13] - f[d.M00] * f[d.M31] * f[d.M22] * f[d.M13] - f[d.M20] * f[d.M01] * f[d.M32] * f[d.M13] + f[d.M00] * f[d.M21] * f[d.M32] * f[d.M13] + f[d.M30] * f[d.M11] * f[d.M02] * f[d.M23] - f[d.M10] * f[d.M31] * f[d.M02] * f[d.M23] - f[d.M30] * f[d.M01] * f[d.M12] * f[d.M23] + f[d.M00] * f[d.M31] * f[d.M12] * f[d.M23] + f[d.M10] * f[d.M01] * f[d.M32] * f[d.M23] - f[d.M00] * f[d.M11] * f[d.M32] * f[d.M23] - f[d.M20] * f[d.M11] * f[d.M02] * f[d.M33] + f[d.M10] * f[d.M21] * f[d.M02] * f[d.M33] + f[d.M20] * f[d.M01] * f[d.M12] * f[d.M33] - f[d.M00] * f[d.M21] * f[d.M12] * f[d.M33] - f[d.M10] * f[d.M01] * f[d.M22] * f[d.M33] + f[d.M00] * f[d.M11] * f[d.M22] * f[d.M33] }; e.prototype.translate = function (f, i, h) { var g = this.values; g[d.M03] += f; g[d.M13] += i; g[d.M23] += h; return this }; e.prototype.copy = function () { return new e().set(this.values) }; e.prototype.projection = function (l, h, j, m) { this.identity(); var k = (1 / Math.tan((j * (Math.PI / 180)) / 2)); var g = (h + l) / (l - h); var f = (2 * h * l) / (l - h); var i = this.values; i[d.M00] = k / m; i[d.M10] = 0; i[d.M20] = 0; i[d.M30] = 0; i[d.M01] = 0; i[d.M11] = k; i[d.M21] = 0; i[d.M31] = 0; i[d.M02] = 0; i[d.M12] = 0; i[d.M22] = g; i[d.M32] = -1; i[d.M03] = 0; i[d.M13] = 0; i[d.M23] = f; i[d.M33] = 0; return this }; e.prototype.ortho2d = function (g, i, h, f) { return this.ortho(g, g + h, i, i + f, 0, 1) }; e.prototype.ortho = function (h, r, f, o, n, m) { this.identity(); var l = 2 / (r - h); var p = 2 / (o - f); var g = -2 / (m - n); var k = -(r + h) / (r - h); var j = -(o + f) / (o - f); var i = -(m + n) / (m - n); var q = this.values; q[d.M00] = l; q[d.M10] = 0; q[d.M20] = 0; q[d.M30] = 0; q[d.M01] = 0; q[d.M11] = p; q[d.M21] = 0; q[d.M31] = 0; q[d.M02] = 0; q[d.M12] = 0; q[d.M22] = g; q[d.M32] = 0; q[d.M03] = k; q[d.M13] = j; q[d.M23] = i; q[d.M33] = 1; return this }; e.prototype.multiply = function (h) { var i = this.temp; var g = this.values; var f = h.values; i[d.M00] = g[d.M00] * f[d.M00] + g[d.M01] * f[d.M10] + g[d.M02] * f[d.M20] + g[d.M03] * f[d.M30]; i[d.M01] = g[d.M00] * f[d.M01] + g[d.M01] * f[d.M11] + g[d.M02] * f[d.M21] + g[d.M03] * f[d.M31]; i[d.M02] = g[d.M00] * f[d.M02] + g[d.M01] * f[d.M12] + g[d.M02] * f[d.M22] + g[d.M03] * f[d.M32]; i[d.M03] = g[d.M00] * f[d.M03] + g[d.M01] * f[d.M13] + g[d.M02] * f[d.M23] + g[d.M03] * f[d.M33]; i[d.M10] = g[d.M10] * f[d.M00] + g[d.M11] * f[d.M10] + g[d.M12] * f[d.M20] + g[d.M13] * f[d.M30]; i[d.M11] = g[d.M10] * f[d.M01] + g[d.M11] * f[d.M11] + g[d.M12] * f[d.M21] + g[d.M13] * f[d.M31]; i[d.M12] = g[d.M10] * f[d.M02] + g[d.M11] * f[d.M12] + g[d.M12] * f[d.M22] + g[d.M13] * f[d.M32]; i[d.M13] = g[d.M10] * f[d.M03] + g[d.M11] * f[d.M13] + g[d.M12] * f[d.M23] + g[d.M13] * f[d.M33]; i[d.M20] = g[d.M20] * f[d.M00] + g[d.M21] * f[d.M10] + g[d.M22] * f[d.M20] + g[d.M23] * f[d.M30]; i[d.M21] = g[d.M20] * f[d.M01] + g[d.M21] * f[d.M11] + g[d.M22] * f[d.M21] + g[d.M23] * f[d.M31]; i[d.M22] = g[d.M20] * f[d.M02] + g[d.M21] * f[d.M12] + g[d.M22] * f[d.M22] + g[d.M23] * f[d.M32]; i[d.M23] = g[d.M20] * f[d.M03] + g[d.M21] * f[d.M13] + g[d.M22] * f[d.M23] + g[d.M23] * f[d.M33]; i[d.M30] = g[d.M30] * f[d.M00] + g[d.M31] * f[d.M10] + g[d.M32] * f[d.M20] + g[d.M33] * f[d.M30]; i[d.M31] = g[d.M30] * f[d.M01] + g[d.M31] * f[d.M11] + g[d.M32] * f[d.M21] + g[d.M33] * f[d.M31]; i[d.M32] = g[d.M30] * f[d.M02] + g[d.M31] * f[d.M12] + g[d.M32] * f[d.M22] + g[d.M33] * f[d.M32]; i[d.M33] = g[d.M30] * f[d.M03] + g[d.M31] * f[d.M13] + g[d.M32] * f[d.M23] + g[d.M33] * f[d.M33]; return this.set(this.temp) }; e.prototype.multiplyLeft = function (h) { var i = this.temp; var g = this.values; var f = h.values; i[d.M00] = f[d.M00] * g[d.M00] + f[d.M01] * g[d.M10] + f[d.M02] * g[d.M20] + f[d.M03] * g[d.M30]; i[d.M01] = f[d.M00] * g[d.M01] + f[d.M01] * g[d.M11] + f[d.M02] * g[d.M21] + f[d.M03] * g[d.M31]; i[d.M02] = f[d.M00] * g[d.M02] + f[d.M01] * g[d.M12] + f[d.M02] * g[d.M22] + f[d.M03] * g[d.M32]; i[d.M03] = f[d.M00] * g[d.M03] + f[d.M01] * g[d.M13] + f[d.M02] * g[d.M23] + f[d.M03] * g[d.M33]; i[d.M10] = f[d.M10] * g[d.M00] + f[d.M11] * g[d.M10] + f[d.M12] * g[d.M20] + f[d.M13] * g[d.M30]; i[d.M11] = f[d.M10] * g[d.M01] + f[d.M11] * g[d.M11] + f[d.M12] * g[d.M21] + f[d.M13] * g[d.M31]; i[d.M12] = f[d.M10] * g[d.M02] + f[d.M11] * g[d.M12] + f[d.M12] * g[d.M22] + f[d.M13] * g[d.M32]; i[d.M13] = f[d.M10] * g[d.M03] + f[d.M11] * g[d.M13] + f[d.M12] * g[d.M23] + f[d.M13] * g[d.M33]; i[d.M20] = f[d.M20] * g[d.M00] + f[d.M21] * g[d.M10] + f[d.M22] * g[d.M20] + f[d.M23] * g[d.M30]; i[d.M21] = f[d.M20] * g[d.M01] + f[d.M21] * g[d.M11] + f[d.M22] * g[d.M21] + f[d.M23] * g[d.M31]; i[d.M22] = f[d.M20] * g[d.M02] + f[d.M21] * g[d.M12] + f[d.M22] * g[d.M22] + f[d.M23] * g[d.M32]; i[d.M23] = f[d.M20] * g[d.M03] + f[d.M21] * g[d.M13] + f[d.M22] * g[d.M23] + f[d.M23] * g[d.M33]; i[d.M30] = f[d.M30] * g[d.M00] + f[d.M31] * g[d.M10] + f[d.M32] * g[d.M20] + f[d.M33] * g[d.M30]; i[d.M31] = f[d.M30] * g[d.M01] + f[d.M31] * g[d.M11] + f[d.M32] * g[d.M21] + f[d.M33] * g[d.M31]; i[d.M32] = f[d.M30] * g[d.M02] + f[d.M31] * g[d.M12] + f[d.M32] * g[d.M22] + f[d.M33] * g[d.M32]; i[d.M33] = f[d.M30] * g[d.M03] + f[d.M31] * g[d.M13] + f[d.M32] * g[d.M23] + f[d.M33] * g[d.M33]; return this.set(this.temp) }; e.prototype.lookAt = function (g, k, f) { e.initTemps(); var i = e.xAxis, h = e.yAxis, j = e.zAxis; j.setFrom(k).normalize(); i.setFrom(k).normalize(); i.cross(f).normalize(); h.setFrom(i).cross(j).normalize(); this.identity(); var l = this.values; l[d.M00] = i.x; l[d.M01] = i.y; l[d.M02] = i.z; l[d.M10] = h.x; l[d.M11] = h.y; l[d.M12] = h.z; l[d.M20] = -j.x; l[d.M21] = -j.y; l[d.M22] = -j.z; e.tmpMatrix.identity(); e.tmpMatrix.values[d.M03] = -g.x; e.tmpMatrix.values[d.M13] = -g.y; e.tmpMatrix.values[d.M23] = -g.z; this.multiply(e.tmpMatrix); return this }; e.initTemps = function () { if (e.xAxis === null) { e.xAxis = new d.Vector3() } if (e.yAxis === null) { e.yAxis = new d.Vector3() } if (e.zAxis === null) { e.zAxis = new d.Vector3() } }; e.xAxis = null; e.yAxis = null; e.zAxis = null; e.tmpMatrix = new e(); return e }()); d.Matrix4 = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (c) { var g = (function () { function l(p, n, m, q) { this.attributes = n; this.verticesLength = 0; this.dirtyVertices = false; this.indicesLength = 0; this.dirtyIndices = false; this.elementsPerVertex = 0; this.context = p instanceof c.ManagedWebGLRenderingContext ? p : new c.ManagedWebGLRenderingContext(p); this.elementsPerVertex = 0; for (var o = 0; o < n.length; o++) { this.elementsPerVertex += n[o].numElements } this.vertices = new Float32Array(m * this.elementsPerVertex); this.indices = new Uint16Array(q); this.context.addRestorable(this) } l.prototype.getAttributes = function () { return this.attributes }; l.prototype.maxVertices = function () { return this.vertices.length / this.elementsPerVertex }; l.prototype.numVertices = function () { return this.verticesLength / this.elementsPerVertex }; l.prototype.setVerticesLength = function (m) { this.dirtyVertices = true; this.verticesLength = m }; l.prototype.getVertices = function () { return this.vertices }; l.prototype.maxIndices = function () { return this.indices.length }; l.prototype.numIndices = function () { return this.indicesLength }; l.prototype.setIndicesLength = function (m) { this.dirtyIndices = true; this.indicesLength = m }; l.prototype.getIndices = function () { return this.indices }; l.prototype.getVertexSizeInFloats = function () { var n = 0; for (var m = 0; m < this.attributes.length; m++) { var o = this.attributes[m]; n += o.numElements } return n }; l.prototype.setVertices = function (m) { this.dirtyVertices = true; if (m.length > this.vertices.length) { throw Error("Mesh can't store more than " + this.maxVertices() + " vertices") } this.vertices.set(m, 0); this.verticesLength = m.length }; l.prototype.setIndices = function (m) { this.dirtyIndices = true; if (m.length > this.indices.length) { throw Error("Mesh can't store more than " + this.maxIndices() + " indices") } this.indices.set(m, 0); this.indicesLength = m.length }; l.prototype.draw = function (n, m) { this.drawWithOffset(n, m, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex) }; l.prototype.drawWithOffset = function (o, m, q, n) { var p = this.context.gl; if (this.dirtyVertices || this.dirtyIndices) { this.update() } this.bind(o); if (this.indicesLength > 0) { p.drawElements(m, n, p.UNSIGNED_SHORT, q * 2) } else { p.drawArrays(m, q, n) } this.unbind(o) }; l.prototype.bind = function (o) { var r = this.context.gl; r.bindBuffer(r.ARRAY_BUFFER, this.verticesBuffer); var q = 0; for (var n = 0; n < this.attributes.length; n++) { var p = this.attributes[n]; var m = o.getAttributeLocation(p.name); r.enableVertexAttribArray(m); r.vertexAttribPointer(m, p.numElements, r.FLOAT, false, this.elementsPerVertex * 4, q * 4); q += p.numElements } if (this.indicesLength > 0) { r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indicesBuffer) } }; l.prototype.unbind = function (n) { var p = this.context.gl; for (var m = 0; m < this.attributes.length; m++) { var o = this.attributes[m]; var q = n.getAttributeLocation(o.name); p.disableVertexAttribArray(q) } p.bindBuffer(p.ARRAY_BUFFER, null); if (this.indicesLength > 0) { p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, null) } }; l.prototype.update = function () { var m = this.context.gl; if (this.dirtyVertices) { if (!this.verticesBuffer) { this.verticesBuffer = m.createBuffer() } m.bindBuffer(m.ARRAY_BUFFER, this.verticesBuffer); m.bufferData(m.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), m.DYNAMIC_DRAW); this.dirtyVertices = false } if (this.dirtyIndices) { if (!this.indicesBuffer) { this.indicesBuffer = m.createBuffer() } m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, this.indicesBuffer); m.bufferData(m.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), m.DYNAMIC_DRAW); this.dirtyIndices = false } }; l.prototype.restore = function () { this.verticesBuffer = null; this.indicesBuffer = null; this.update() }; l.prototype.dispose = function () { this.context.removeRestorable(this); var m = this.context.gl; m.deleteBuffer(this.verticesBuffer); m.deleteBuffer(this.indicesBuffer) }; return l }()); c.Mesh = g; var i = (function () { function l(n, o, m) { this.name = n; this.type = o; this.numElements = m } return l }()); c.VertexAttribute = i; var k = (function (l) { __extends(m, l); function m() { return l.call(this, c.Shader.POSITION, f.Float, 2) || this } return m }(i)); c.Position2Attribute = k; var h = (function (l) { __extends(m, l); function m() { return l.call(this, c.Shader.POSITION, f.Float, 3) || this } return m }(i)); c.Position3Attribute = h; var d = (function (l) { __extends(m, l); function m(n) { if (n === void 0) { n = 0 } return l.call(this, c.Shader.TEXCOORDS + (n == 0 ? "" : n), f.Float, 2) || this } return m }(i)); c.TexCoordAttribute = d; var e = (function (m) { __extends(l, m); function l() { return m.call(this, c.Shader.COLOR, f.Float, 4) || this } return l }(i)); c.ColorAttribute = e; var j = (function (m) { __extends(l, m); function l() { return m.call(this, c.Shader.COLOR2, f.Float, 4) || this } return l }(i)); c.Color2Attribute = j; var f; (function (l) { l[l.Float = 0] = "Float" })(f = c.VertexAttributeType || (c.VertexAttributeType = {})) })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function () { function e(i, g, f) { if (g === void 0) { g = true } if (f === void 0) { f = 10920 } this.isDrawing = false; this.shader = null; this.lastTexture = null; this.verticesLength = 0; this.indicesLength = 0; if (f > 10920) { throw new Error("Can't have more than 10920 triangles per batch: " + f) } this.context = i instanceof d.ManagedWebGLRenderingContext ? i : new d.ManagedWebGLRenderingContext(i); var h = g ? [new d.Position2Attribute(), new d.ColorAttribute(), new d.TexCoordAttribute(), new d.Color2Attribute()] : [new d.Position2Attribute(), new d.ColorAttribute(), new d.TexCoordAttribute()]; this.mesh = new d.Mesh(i, h, f, f * 3); this.srcBlend = this.context.gl.SRC_ALPHA; this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA } e.prototype.begin = function (f) { var g = this.context.gl; if (this.isDrawing) { throw new Error("PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()") } this.drawCalls = 0; this.shader = f; this.lastTexture = null; this.isDrawing = true; g.enable(g.BLEND); g.blendFunc(this.srcBlend, this.dstBlend) }; e.prototype.setBlendMode = function (f, g) { var h = this.context.gl; this.srcBlend = f; this.dstBlend = g; if (this.isDrawing) { this.flush(); h.blendFunc(this.srcBlend, this.dstBlend) } }; e.prototype.draw = function (m, k, n) { if (m != this.lastTexture) { this.flush(); this.lastTexture = m } else { if (this.verticesLength + k.length > this.mesh.getVertices().length || this.indicesLength + n.length > this.mesh.getIndices().length) { this.flush() } } var h = this.mesh.numVertices(); this.mesh.getVertices().set(k, this.verticesLength); this.verticesLength += k.length; this.mesh.setVerticesLength(this.verticesLength); var g = this.mesh.getIndices(); for (var l = this.indicesLength, f = 0; f < n.length; l++, f++) { g[l] = n[f] + h } this.indicesLength += n.length; this.mesh.setIndicesLength(this.indicesLength) }; e.prototype.flush = function () { var f = this.context.gl; if (this.verticesLength == 0) { return } this.lastTexture.bind(); this.mesh.draw(this.shader, f.TRIANGLES); this.verticesLength = 0; this.indicesLength = 0; this.mesh.setVerticesLength(0); this.mesh.setIndicesLength(0); this.drawCalls++ }; e.prototype.end = function () { var f = this.context.gl; if (!this.isDrawing) { throw new Error("PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()") } if (this.verticesLength > 0 || this.indicesLength > 0) { this.flush() } this.shader = null; this.lastTexture = null; this.isDrawing = false; f.disable(f.BLEND) }; e.prototype.getDrawCalls = function () { return this.drawCalls }; e.prototype.dispose = function () { this.mesh.dispose() }; return e }()); d.PolygonBatcher = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (e) { var c = (function () { function f(h, i, g) { if (g === void 0) { g = true } this.twoColorTint = false; this.activeRenderer = null; this.QUAD = [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0]; this.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0]; this.WHITE = new b.Color(1, 1, 1, 1); this.canvas = h; this.context = i instanceof e.ManagedWebGLRenderingContext ? i : new e.ManagedWebGLRenderingContext(i); this.twoColorTint = g; this.camera = new e.OrthoCamera(h.width, h.height); this.batcherShader = g ? e.Shader.newTwoColoredTextured(this.context) : e.Shader.newColoredTextured(this.context); this.batcher = new e.PolygonBatcher(this.context, g); this.shapesShader = e.Shader.newColored(this.context); this.shapes = new e.ShapeRenderer(this.context); this.skeletonRenderer = new e.SkeletonRenderer(this.context, g); this.skeletonDebugRenderer = new e.SkeletonDebugRenderer(this.context) } f.prototype.begin = function () { this.camera.update(); this.enableRenderer(this.batcher) }; f.prototype.drawSkeleton = function (i, g, j, h) { if (g === void 0) { g = false } if (j === void 0) { j = -1 } if (h === void 0) { h = -1 } this.enableRenderer(this.batcher); this.skeletonRenderer.premultipliedAlpha = g; this.skeletonRenderer.draw(this.batcher, i, j, h) }; f.prototype.drawSkeletonDebug = function (i, g, h) { if (g === void 0) { g = false } if (h === void 0) { h = null } this.enableRenderer(this.shapes); this.skeletonDebugRenderer.premultipliedAlpha = g; this.skeletonDebugRenderer.draw(this.shapes, i, h) }; f.prototype.drawTexture = function (n, h, o, m, g, k) { if (k === void 0) { k = null } this.enableRenderer(this.batcher); if (k === null) { k = this.WHITE } var j = this.QUAD; var l = 0; j[l++] = h; j[l++] = o; j[l++] = k.r; j[l++] = k.g; j[l++] = k.b; j[l++] = k.a; j[l++] = 0; j[l++] = 1; if (this.twoColorTint) { j[l++] = 0; j[l++] = 0; j[l++] = 0; j[l++] = 0 } j[l++] = h + m; j[l++] = o; j[l++] = k.r; j[l++] = k.g; j[l++] = k.b; j[l++] = k.a; j[l++] = 1; j[l++] = 1; if (this.twoColorTint) { j[l++] = 0; j[l++] = 0; j[l++] = 0; j[l++] = 0 } j[l++] = h + m; j[l++] = o + g; j[l++] = k.r; j[l++] = k.g; j[l++] = k.b; j[l++] = k.a; j[l++] = 1; j[l++] = 0; if (this.twoColorTint) { j[l++] = 0; j[l++] = 0; j[l++] = 0; j[l++] = 0 } j[l++] = h; j[l++] = o + g; j[l++] = k.r; j[l++] = k.g; j[l++] = k.b; j[l++] = k.a; j[l++] = 0; j[l++] = 0; if (this.twoColorTint) { j[l++] = 0; j[l++] = 0; j[l++] = 0; j[l++] = 0 } this.batcher.draw(n, j, this.QUAD_TRIANGLES) }; f.prototype.drawTextureUV = function (l, o, m, h, s, r, q, g, n, j) { if (j === void 0) { j = null } this.enableRenderer(this.batcher); if (j === null) { j = this.WHITE } var p = this.QUAD; var k = 0; p[k++] = o; p[k++] = m; p[k++] = j.r; p[k++] = j.g; p[k++] = j.b; p[k++] = j.a; p[k++] = r; p[k++] = q; if (this.twoColorTint) { p[k++] = 0; p[k++] = 0; p[k++] = 0; p[k++] = 0 } p[k++] = o + h; p[k++] = m; p[k++] = j.r; p[k++] = j.g; p[k++] = j.b; p[k++] = j.a; p[k++] = g; p[k++] = q; if (this.twoColorTint) { p[k++] = 0; p[k++] = 0; p[k++] = 0; p[k++] = 0 } p[k++] = o + h; p[k++] = m + s; p[k++] = j.r; p[k++] = j.g; p[k++] = j.b; p[k++] = j.a; p[k++] = g; p[k++] = n; if (this.twoColorTint) { p[k++] = 0; p[k++] = 0; p[k++] = 0; p[k++] = 0 } p[k++] = o; p[k++] = m + s; p[k++] = j.r; p[k++] = j.g; p[k++] = j.b; p[k++] = j.a; p[k++] = r; p[k++] = n; if (this.twoColorTint) { p[k++] = 0; p[k++] = 0; p[k++] = 0; p[k++] = 0 } this.batcher.draw(l, p, this.QUAD_TRIANGLES) }; f.prototype.drawTextureRotated = function (v, H, G, g, j, N, M, u, D, h) { if (D === void 0) { D = null } if (h === void 0) { h = false } this.enableRenderer(this.batcher); if (D === null) { D = this.WHITE } var n = this.QUAD; var F = H + N; var E = G + M; var B = -N; var z = -M; var C = g - N; var o = j - M; var J = B; var I = z; var A = B; var w = o; var m = C; var l = o; var L = C; var K = z; var t = 0; var S = 0; var s = 0; var R = 0; var r = 0; var Q = 0; var q = 0; var P = 0; if (u != 0) { var k = b.MathUtils.cosDeg(u); var p = b.MathUtils.sinDeg(u); t = k * J - p * I; S = p * J + k * I; q = k * A - p * w; P = p * A + k * w; r = k * m - p * l; Q = p * m + k * l; s = r + (t - q); R = Q + (S - P) } else { t = J; S = I; q = A; P = w; r = m; Q = l; s = L; R = K } t += F; S += E; s += F; R += E; r += F; Q += E; q += F; P += E; var O = 0; n[O++] = t; n[O++] = S; n[O++] = D.r; n[O++] = D.g; n[O++] = D.b; n[O++] = D.a; n[O++] = 0; n[O++] = 1; if (this.twoColorTint) { n[O++] = 0; n[O++] = 0; n[O++] = 0; n[O++] = 0 } n[O++] = s; n[O++] = R; n[O++] = D.r; n[O++] = D.g; n[O++] = D.b; n[O++] = D.a; n[O++] = 1; n[O++] = 1; if (this.twoColorTint) { n[O++] = 0; n[O++] = 0; n[O++] = 0; n[O++] = 0 } n[O++] = r; n[O++] = Q; n[O++] = D.r; n[O++] = D.g; n[O++] = D.b; n[O++] = D.a; n[O++] = 1; n[O++] = 0; if (this.twoColorTint) { n[O++] = 0; n[O++] = 0; n[O++] = 0; n[O++] = 0 } n[O++] = q; n[O++] = P; n[O++] = D.r; n[O++] = D.g; n[O++] = D.b; n[O++] = D.a; n[O++] = 0; n[O++] = 0; if (this.twoColorTint) { n[O++] = 0; n[O++] = 0; n[O++] = 0; n[O++] = 0 } this.batcher.draw(v, n, this.QUAD_TRIANGLES) }; f.prototype.drawRegion = function (m, n, l, g, p, j, h) { if (j === void 0) { j = null } if (h === void 0) { h = false } this.enableRenderer(this.batcher); if (j === null) { j = this.WHITE } var o = this.QUAD; var k = 0; o[k++] = n; o[k++] = l; o[k++] = j.r; o[k++] = j.g; o[k++] = j.b; o[k++] = j.a; o[k++] = m.u; o[k++] = m.v2; if (this.twoColorTint) { o[k++] = 0; o[k++] = 0; o[k++] = 0; o[k++] = 0 } o[k++] = n + g; o[k++] = l; o[k++] = j.r; o[k++] = j.g; o[k++] = j.b; o[k++] = j.a; o[k++] = m.u2; o[k++] = m.v2; if (this.twoColorTint) { o[k++] = 0; o[k++] = 0; o[k++] = 0; o[k++] = 0 } o[k++] = n + g; o[k++] = l + p; o[k++] = j.r; o[k++] = j.g; o[k++] = j.b; o[k++] = j.a; o[k++] = m.u2; o[k++] = m.v; if (this.twoColorTint) { o[k++] = 0; o[k++] = 0; o[k++] = 0; o[k++] = 0 } o[k++] = n; o[k++] = l + p; o[k++] = j.r; o[k++] = j.g; o[k++] = j.b; o[k++] = j.a; o[k++] = m.u; o[k++] = m.v; if (this.twoColorTint) { o[k++] = 0; o[k++] = 0; o[k++] = 0; o[k++] = 0 } this.batcher.draw(m.texture, o, this.QUAD_TRIANGLES) }; f.prototype.line = function (h, l, j, k, i, g) { if (i === void 0) { i = null } if (g === void 0) { g = null } this.enableRenderer(this.shapes); this.shapes.line(h, l, j, k, i) }; f.prototype.triangle = function (p, m, k, h, l, g, j, i, o, n) { if (i === void 0) { i = null } if (o === void 0) { o = null } if (n === void 0) { n = null } this.enableRenderer(this.shapes); this.shapes.triangle(p, m, k, h, l, g, j, i, o, n) }; f.prototype.quad = function (r, o, l, h, m, g, k, s, j, i, q, p, n) { if (i === void 0) { i = null } if (q === void 0) { q = null } if (p === void 0) { p = null } if (n === void 0) { n = null } this.enableRenderer(this.shapes); this.shapes.quad(r, o, l, h, m, g, k, s, j, i, q, p, n) }; f.prototype.rect = function (k, h, l, j, g, i) { if (i === void 0) { i = null } this.enableRenderer(this.shapes); this.shapes.rect(k, h, l, j, g, i) }; f.prototype.rectLine = function (m, i, l, h, j, k, g) { if (g === void 0) { g = null } this.enableRenderer(this.shapes); this.shapes.rectLine(m, i, l, h, j, k, g) }; f.prototype.polygon = function (j, i, h, g) { if (g === void 0) { g = null } this.enableRenderer(this.shapes); this.shapes.polygon(j, i, h, g) }; f.prototype.circle = function (k, h, l, g, i, j) { if (i === void 0) { i = null } if (j === void 0) { j = 0 } this.enableRenderer(this.shapes); this.shapes.circle(k, h, l, g, i, j) }; f.prototype.curve = function (h, p, n, j, m, i, g, o, l, k) { if (k === void 0) { k = null } this.enableRenderer(this.shapes); this.shapes.curve(h, p, n, j, m, i, g, o, l, k) }; f.prototype.end = function () { if (this.activeRenderer === this.batcher) { this.batcher.end() } else { if (this.activeRenderer === this.shapes) { this.shapes.end() } } this.activeRenderer = null }; f.prototype.resize = function (l) { var i = this.canvas; var r = i.clientWidth; var n = i.clientHeight; if (i.width != r || i.height != n) { i.width = r; i.height = n } this.context.gl.viewport(0, 0, i.width, i.height); if (l === d.Stretch) { } else { if (l === d.Expand) { this.camera.setViewport(r, n) } else { if (l === d.Fit) { var g = i.width, j = i.height; var q = this.camera.viewportWidth, o = this.camera.viewportHeight; var k = o / q; var p = j / g; var m = k < p ? q / g : o / j; this.camera.viewportWidth = g * m; this.camera.viewportHeight = j * m } } } this.camera.update() }; f.prototype.enableRenderer = function (g) { if (this.activeRenderer === g) { return } this.end(); if (g instanceof e.PolygonBatcher) { this.batcherShader.bind(); this.batcherShader.setUniform4x4f(e.Shader.MVP_MATRIX, this.camera.projectionView.values); this.batcherShader.setUniformi("u_texture", 0); this.batcher.begin(this.batcherShader); this.activeRenderer = this.batcher } else { if (g instanceof e.ShapeRenderer) { this.shapesShader.bind(); this.shapesShader.setUniform4x4f(e.Shader.MVP_MATRIX, this.camera.projectionView.values); this.shapes.begin(this.shapesShader); this.activeRenderer = this.shapes } else { this.activeRenderer = this.skeletonDebugRenderer } } }; f.prototype.dispose = function () { this.batcher.dispose(); this.batcherShader.dispose(); this.shapes.dispose(); this.shapesShader.dispose(); this.skeletonDebugRenderer.dispose() }; return f }()); e.SceneRenderer = c; var d; (function (f) { f[f.Stretch = 0] = "Stretch"; f[f.Expand = 1] = "Expand"; f[f.Fit = 2] = "Fit" })(d = e.ResizeMode || (e.ResizeMode = {})) })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function () { function e(g, h, f) { this.vertexShader = h; this.fragmentShader = f; this.vs = null; this.fs = null; this.program = null; this.tmp2x2 = new Float32Array(2 * 2); this.tmp3x3 = new Float32Array(3 * 3); this.tmp4x4 = new Float32Array(4 * 4); this.vsSource = h; this.fsSource = f; this.context = g instanceof d.ManagedWebGLRenderingContext ? g : new d.ManagedWebGLRenderingContext(g); this.context.addRestorable(this); this.compile() } e.prototype.getProgram = function () { return this.program }; e.prototype.getVertexShader = function () { return this.vertexShader }; e.prototype.getFragmentShader = function () { return this.fragmentShader }; e.prototype.getVertexShaderSource = function () { return this.vsSource }; e.prototype.getFragmentSource = function () { return this.fsSource }; e.prototype.compile = function () { var g = this.context.gl; try { this.vs = this.compileShader(g.VERTEX_SHADER, this.vertexShader); this.fs = this.compileShader(g.FRAGMENT_SHADER, this.fragmentShader); this.program = this.compileProgram(this.vs, this.fs) } catch (f) { this.dispose(); throw f } }; e.prototype.compileShader = function (g, i) { var j = this.context.gl; var h = j.createShader(g); j.shaderSource(h, i); j.compileShader(h); if (!j.getShaderParameter(h, j.COMPILE_STATUS)) { var f = "Couldn't compile shader: " + j.getShaderInfoLog(h); j.deleteShader(h); if (!j.isContextLost()) { throw new Error(f) } } return h }; e.prototype.compileProgram = function (j, f) { var i = this.context.gl; var g = i.createProgram(); i.attachShader(g, j); i.attachShader(g, f); i.linkProgram(g); if (!i.getProgramParameter(g, i.LINK_STATUS)) { var h = "Couldn't compile shader program: " + i.getProgramInfoLog(g); i.deleteProgram(g); if (!i.isContextLost()) { throw new Error(h) } } return g }; e.prototype.restore = function () { this.compile() }; e.prototype.bind = function () { this.context.gl.useProgram(this.program) }; e.prototype.unbind = function () { this.context.gl.useProgram(null) }; e.prototype.setUniformi = function (f, g) { this.context.gl.uniform1i(this.getUniformLocation(f), g) }; e.prototype.setUniformf = function (f, g) { this.context.gl.uniform1f(this.getUniformLocation(f), g) }; e.prototype.setUniform2f = function (f, h, g) { this.context.gl.uniform2f(this.getUniformLocation(f), h, g) }; e.prototype.setUniform3f = function (g, i, h, f) { this.context.gl.uniform3f(this.getUniformLocation(g), i, h, f) }; e.prototype.setUniform4f = function (g, i, h, f, j) { this.context.gl.uniform4f(this.getUniformLocation(g), i, h, f, j) }; e.prototype.setUniform2x2f = function (f, g) { var h = this.context.gl; this.tmp2x2.set(g); h.uniformMatrix2fv(this.getUniformLocation(f), false, this.tmp2x2) }; e.prototype.setUniform3x3f = function (f, g) { var h = this.context.gl; this.tmp3x3.set(g); h.uniformMatrix3fv(this.getUniformLocation(f), false, this.tmp3x3) }; e.prototype.setUniform4x4f = function (f, g) { var h = this.context.gl; this.tmp4x4.set(g); h.uniformMatrix4fv(this.getUniformLocation(f), false, this.tmp4x4) }; e.prototype.getUniformLocation = function (f) { var h = this.context.gl; var g = h.getUniformLocation(this.program, f); if (!g && !h.isContextLost()) { throw new Error("Couldn't find location for uniform " + f) } return g }; e.prototype.getAttributeLocation = function (g) { var h = this.context.gl; var f = h.getAttribLocation(this.program, g); if (f == -1 && !h.isContextLost()) { throw new Error("Couldn't find location for attribute " + g) } return f }; e.prototype.dispose = function () { this.context.removeRestorable(this); var f = this.context.gl; if (this.vs) { f.deleteShader(this.vs); this.vs = null } if (this.fs) { f.deleteShader(this.fs); this.fs = null } if (this.program) { f.deleteProgram(this.program); this.program = null } }; e.newColoredTextured = function (g) { var h = "\n\t\t\t\tattribute vec4 " + e.POSITION + ";\n\t\t\t\tattribute vec4 " + e.COLOR + ";\n\t\t\t\tattribute vec2 " + e.TEXCOORDS + ";\n\t\t\t\tuniform mat4 " + e.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_color;\n\t\t\t\tvarying vec2 v_texCoords;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_color = " + e.COLOR + ";\n\t\t\t\t\tv_texCoords = " + e.TEXCOORDS + ";\n\t\t\t\t\tgl_Position = " + e.MVP_MATRIX + " * " + e.POSITION + ";\n\t\t\t\t}\n\t\t\t"; var f = "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_color;\n\t\t\t\tvarying vec2 v_texCoords;\n\t\t\t\tuniform sampler2D u_texture;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tgl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n\t\t\t\t}\n\t\t\t"; return new e(g, h, f) }; e.newTwoColoredTextured = function (g) { var h = "\n\t\t\t\tattribute vec4 " + e.POSITION + ";\n\t\t\t\tattribute vec4 " + e.COLOR + ";\n\t\t\t\tattribute vec4 " + e.COLOR2 + ";\n\t\t\t\tattribute vec2 " + e.TEXCOORDS + ";\n\t\t\t\tuniform mat4 " + e.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_light;\n\t\t\t\tvarying vec4 v_dark;\n\t\t\t\tvarying vec2 v_texCoords;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_light = " + e.COLOR + ";\n\t\t\t\t\tv_dark = " + e.COLOR2 + ";\n\t\t\t\t\tv_texCoords = " + e.TEXCOORDS + ";\n\t\t\t\t\tgl_Position = " + e.MVP_MATRIX + " * " + e.POSITION + ";\n\t\t\t\t}\n\t\t\t"; var f = "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_light;\n\t\t\t\tvarying LOWP vec4 v_dark;\n\t\t\t\tvarying vec2 v_texCoords;\n\t\t\t\tuniform sampler2D u_texture;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tvec4 texColor = texture2D(u_texture, v_texCoords);\n\t\t\t\t\tgl_FragColor.a = texColor.a * v_light.a;\n\t\t\t\t\tgl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n\t\t\t\t}\n\t\t\t"; return new e(g, h, f) }; e.newColored = function (g) { var h = "\n\t\t\t\tattribute vec4 " + e.POSITION + ";\n\t\t\t\tattribute vec4 " + e.COLOR + ";\n\t\t\t\tuniform mat4 " + e.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_color;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_color = " + e.COLOR + ";\n\t\t\t\t\tgl_Position = " + e.MVP_MATRIX + " * " + e.POSITION + ";\n\t\t\t\t}\n\t\t\t"; var f = "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_color;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tgl_FragColor = v_color;\n\t\t\t\t}\n\t\t\t"; return new e(g, h, f) }; e.MVP_MATRIX = "u_projTrans"; e.POSITION = "a_position"; e.COLOR = "a_color"; e.COLOR2 = "a_color2"; e.TEXCOORDS = "a_texCoords"; e.SAMPLER = "u_texture"; return e }()); d.Shader = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var e = (function () { function f(h, g) { if (g === void 0) { g = 10920 } this.isDrawing = false; this.shapeType = c.Filled; this.color = new b.Color(1, 1, 1, 1); this.vertexIndex = 0; this.tmp = new b.Vector2(); if (g > 10920) { throw new Error("Can't have more than 10920 triangles per batch: " + g) } this.context = h instanceof d.ManagedWebGLRenderingContext ? h : new d.ManagedWebGLRenderingContext(h); this.mesh = new d.Mesh(h, [new d.Position2Attribute(), new d.ColorAttribute()], g, 0); this.srcBlend = this.context.gl.SRC_ALPHA; this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA } f.prototype.begin = function (g) { if (this.isDrawing) { throw new Error("ShapeRenderer.begin() has already been called") } this.shader = g; this.vertexIndex = 0; this.isDrawing = true; var h = this.context.gl; h.enable(h.BLEND); h.blendFunc(this.srcBlend, this.dstBlend) }; f.prototype.setBlendMode = function (g, h) { var i = this.context.gl; this.srcBlend = g; this.dstBlend = h; if (this.isDrawing) { this.flush(); i.blendFunc(this.srcBlend, this.dstBlend) } }; f.prototype.setColor = function (g) { this.color.setFromColor(g) }; f.prototype.setColorWith = function (k, j, h, i) { this.color.set(k, j, h, i) }; f.prototype.point = function (g, i, h) { if (h === void 0) { h = null } this.check(c.Point, 1); if (h === null) { h = this.color } this.vertex(g, i, h) }; f.prototype.line = function (h, m, j, l, i) { if (i === void 0) { i = null } this.check(c.Line, 2); var k = this.mesh.getVertices(); var g = this.vertexIndex; if (i === null) { i = this.color } this.vertex(h, m, i); this.vertex(j, l, i) }; f.prototype.triangle = function (r, n, l, h, m, g, k, i, q, p) { if (i === void 0) { i = null } if (q === void 0) { q = null } if (p === void 0) { p = null } this.check(r ? c.Filled : c.Line, 3); var j = this.mesh.getVertices(); var o = this.vertexIndex; if (i === null) { i = this.color } if (q === null) { q = this.color } if (p === null) { p = this.color } if (r) { this.vertex(n, l, i); this.vertex(h, m, q); this.vertex(g, k, p) } else { this.vertex(n, l, i); this.vertex(h, m, q); this.vertex(h, m, i); this.vertex(g, k, q); this.vertex(g, k, i); this.vertex(n, l, q) } }; f.prototype.quad = function (t, p, m, h, n, g, l, u, k, i, s, r, o) { if (i === void 0) { i = null } if (s === void 0) { s = null } if (r === void 0) { r = null } if (o === void 0) { o = null } this.check(t ? c.Filled : c.Line, 3); var j = this.mesh.getVertices(); var q = this.vertexIndex; if (i === null) { i = this.color } if (s === null) { s = this.color } if (r === null) { r = this.color } if (o === null) { o = this.color } if (t) { this.vertex(p, m, i); this.vertex(h, n, s); this.vertex(g, l, r); this.vertex(g, l, r); this.vertex(u, k, o); this.vertex(p, m, i) } else { this.vertex(p, m, i); this.vertex(h, n, s); this.vertex(h, n, s); this.vertex(g, l, r); this.vertex(g, l, r); this.vertex(u, k, o); this.vertex(u, k, o); this.vertex(p, m, i) } }; f.prototype.rect = function (k, h, l, j, g, i) { if (i === void 0) { i = null } this.quad(k, h, l, h + j, l, h + j, l + g, h, l + g, i, i, i, i) }; f.prototype.rectLine = function (p, i, n, g, m, h, j) { if (j === void 0) { j = null } this.check(p ? c.Filled : c.Line, 8); if (j === null) { j = this.color } var o = this.tmp.set(m - n, i - g); o.normalize(); h *= 0.5; var l = o.x * h; var k = o.y * h; if (!p) { this.vertex(i + l, n + k, j); this.vertex(i - l, n - k, j); this.vertex(g + l, m + k, j); this.vertex(g - l, m - k, j); this.vertex(g + l, m + k, j); this.vertex(i + l, n + k, j); this.vertex(g - l, m - k, j); this.vertex(i - l, n - k, j) } else { this.vertex(i + l, n + k, j); this.vertex(i - l, n - k, j); this.vertex(g + l, m + k, j); this.vertex(g - l, m - k, j); this.vertex(g + l, m + k, j); this.vertex(i - l, n - k, j) } }; f.prototype.x = function (g, i, h) { this.line(g - h, i - h, g + h, i + h); this.line(g - h, i + h, g + h, i - h) }; f.prototype.polygon = function (q, o, r, m) { if (m === void 0) { m = null } if (r < 3) { throw new Error("Polygon must contain at least 3 vertices") } this.check(c.Line, r * 2); if (m === null) { m = this.color } var s = this.mesh.getVertices(); var v = this.vertexIndex; o <<= 1; r <<= 1; var l = q[o]; var k = q[o + 1]; var w = o + r; for (var p = o, j = o + r - 2; p < j; p += 2) { var h = q[p]; var u = q[p + 1]; var g = 0; var t = 0; if (p + 2 >= w) { g = l; t = k } else { g = q[p + 2]; t = q[p + 3] } this.vertex(h, u, m); this.vertex(g, t, m) } }; f.prototype.circle = function (v, s, r, p, k, n) { if (k === void 0) { k = null } if (n === void 0) { n = 0 } if (n === 0) { n = Math.max(1, (6 * b.MathUtils.cbrt(p)) | 0) } if (n <= 0) { throw new Error("segments must be > 0.") } if (k === null) { k = this.color } var h = 2 * b.MathUtils.PI / n; var u = Math.cos(h); var q = Math.sin(h); var j = p, g = 0; if (!v) { this.check(c.Line, n * 2 + 2); for (var l = 0; l < n; l++) { this.vertex(s + j, r + g, k); var o = j; j = u * j - q * g; g = q * o + u * g; this.vertex(s + j, r + g, k) } this.vertex(s + j, r + g, k) } else { this.check(c.Filled, n * 3 + 3); n--; for (var l = 0; l < n; l++) { this.vertex(s, r, k); this.vertex(s + j, r + g, k); var m = j; j = u * j - q * g; g = q * m + u * g; this.vertex(s + j, r + g, k) } this.vertex(s, r, k); this.vertex(s + j, r + g, k) } var t = j; j = p; g = 0; this.vertex(s + j, r + g, k) }; f.prototype.curve = function (D, n, y, H, x, G, C, l, A, B) { if (B === void 0) { B = null } this.check(c.Line, A * 2 + 2); if (B === null) { B = this.color } var z = 1 / A; var s = z * z; var r = z * z * z; var k = 3 * z; var i = 3 * s; var g = 6 * s; var I = 6 * r; var F = D - y * 2 + x; var E = n - H * 2 + G; var q = (y - x) * 3 - D + C; var p = (H - G) * 3 - n + l; var o = D; var m = n; var w = (y - D) * k + F * i + q * r; var v = (H - n) * k + E * i + p * r; var u = F * g + q * I; var t = E * g + p * I; var j = q * I; var h = p * I; while (A-- > 0) { this.vertex(o, m, B); o += w; m += v; w += u; v += t; u += j; t += h; this.vertex(o, m, B) } this.vertex(o, m, B); this.vertex(C, l, B) }; f.prototype.vertex = function (h, k, i) { var g = this.vertexIndex; var j = this.mesh.getVertices(); j[g++] = h; j[g++] = k; j[g++] = i.r; j[g++] = i.g; j[g++] = i.b; j[g++] = i.a; this.vertexIndex = g }; f.prototype.end = function () { if (!this.isDrawing) { throw new Error("ShapeRenderer.begin() has not been called") } this.flush(); this.context.gl.disable(this.context.gl.BLEND); this.isDrawing = false }; f.prototype.flush = function () { if (this.vertexIndex == 0) { return } this.mesh.setVerticesLength(this.vertexIndex); this.mesh.draw(this.shader, this.shapeType); this.vertexIndex = 0 }; f.prototype.check = function (h, g) { if (!this.isDrawing) { throw new Error("ShapeRenderer.begin() has not been called") } if (this.shapeType == h) { if (this.mesh.maxVertices() - this.mesh.numVertices() < g) { this.flush() } else { return } } else { this.flush(); this.shapeType = h } }; f.prototype.dispose = function () { this.mesh.dispose() }; return f }()); d.ShapeRenderer = e; var c; (function (f) { f[f.Point = 0] = "Point"; f[f.Line = 1] = "Line"; f[f.Filled = 4] = "Filled" })(c = d.ShapeType || (d.ShapeType = {})) })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (c) { var d = (function () { function e(f) { this.boneLineColor = new b.Color(1, 0, 0, 1); this.boneOriginColor = new b.Color(0, 1, 0, 1); this.attachmentLineColor = new b.Color(0, 0, 1, 0.5); this.triangleLineColor = new b.Color(1, 0.64, 0, 0.5); this.pathColor = new b.Color().setFromString("FF7F00"); this.clipColor = new b.Color(0.8, 0, 0, 2); this.aabbColor = new b.Color(0, 1, 0, 0.5); this.drawBones = true; this.drawRegionAttachments = true; this.drawBoundingBoxes = true; this.drawMeshHull = true; this.drawMeshTriangles = true; this.drawPaths = true; this.drawSkeletonXY = false; this.drawClipping = true; this.premultipliedAlpha = false; this.scale = 1; this.boneWidth = 2; this.bounds = new b.SkeletonBounds(); this.temp = new Array(); this.vertices = b.Utils.newFloatArray(2 * 1024); this.context = f instanceof c.ManagedWebGLRenderingContext ? f : new c.ManagedWebGLRenderingContext(f) } e.prototype.draw = function (E, z, h) { if (h === void 0) { h = null } var I = z.x; var H = z.y; var m = this.context.gl; var q = this.premultipliedAlpha ? m.ONE : m.SRC_ALPHA; E.setBlendMode(q, m.ONE_MINUS_SRC_ALPHA); var Q = z.bones; if (this.drawBones) { E.setColor(this.boneLineColor); for (var U = 0, R = Q.length; U < R; U++) { var u = Q[U]; if (h && h.indexOf(u.data.name) > -1) { continue } if (u.parent == null) { continue } var O = I + u.data.length * u.a + u.worldX; var N = H + u.data.length * u.c + u.worldY; E.rectLine(true, I + u.worldX, H + u.worldY, O, N, this.boneWidth * this.scale) } if (this.drawSkeletonXY) { E.x(I, H, 4 * this.scale) } } if (this.drawRegionAttachments) { E.setColor(this.attachmentLineColor); var V = z.slots; for (var U = 0, R = V.length; U < R; U++) { var o = V[U]; var w = o.getAttachment(); if (w instanceof b.RegionAttachment) { var K = w; var g = this.vertices; K.computeWorldVertices(o.bone, g, 0, 2); E.line(g[0], g[1], g[2], g[3]); E.line(g[2], g[3], g[4], g[5]); E.line(g[4], g[5], g[6], g[7]); E.line(g[6], g[7], g[0], g[1]) } } } if (this.drawMeshHull || this.drawMeshTriangles) { var V = z.slots; for (var U = 0, R = V.length; U < R; U++) { var o = V[U]; if (!o.bone.active) { continue } var w = o.getAttachment(); if (!(w instanceof b.MeshAttachment)) { continue } var v = w; var g = this.vertices; v.computeWorldVertices(o, 0, v.worldVerticesLength, g, 0, 2); var k = v.triangles; var f = v.hullLength; if (this.drawMeshTriangles) { E.setColor(this.triangleLineColor); for (var F = 0, W = k.length; F < W; F += 3) { var Z = k[F] * 2, Y = k[F + 1] * 2, X = k[F + 2] * 2; E.triangle(false, g[Z], g[Z + 1], g[Y], g[Y + 1], g[X], g[X + 1]) } } if (this.drawMeshHull && f > 0) { E.setColor(this.attachmentLineColor); f = (f >> 1) * 2; var l = g[f - 2], j = g[f - 1]; for (var F = 0, W = f; F < W; F += 2) { var O = g[F], N = g[F + 1]; E.line(O, N, l, j); l = O; j = N } } } } if (this.drawBoundingBoxes) { var G = this.bounds; G.update(z, true); E.setColor(this.aabbColor); E.rect(false, G.minX, G.minY, G.getWidth(), G.getHeight()); var ac = G.polygons; var J = G.boundingBoxes; for (var U = 0, R = ac.length; U < R; U++) { var t = ac[U]; E.setColor(J[U].color); E.polygon(t, 0, t.length) } } if (this.drawPaths) { var V = z.slots; for (var U = 0, R = V.length; U < R; U++) { var o = V[U]; if (!o.bone.active) { continue } var w = o.getAttachment(); if (!(w instanceof b.PathAttachment)) { continue } var P = w; var W = P.worldVerticesLength; var A = this.temp = b.Utils.setArraySize(this.temp, W, 0); P.computeWorldVertices(o, 0, W, A, 0, 2); var D = this.pathColor; var s = A[2], ab = A[3], r = 0, aa = 0; if (P.closed) { E.setColor(D); var T = A[0], C = A[1], S = A[W - 2], B = A[W - 1]; r = A[W - 4]; aa = A[W - 3]; E.curve(s, ab, T, C, S, B, r, aa, 32); E.setColor(e.LIGHT_GRAY); E.line(s, ab, T, C); E.line(r, aa, S, B) } W -= 4; for (var F = 4; F < W; F += 6) { var T = A[F], C = A[F + 1], S = A[F + 2], B = A[F + 3]; r = A[F + 4]; aa = A[F + 5]; E.setColor(D); E.curve(s, ab, T, C, S, B, r, aa, 32); E.setColor(e.LIGHT_GRAY); E.line(s, ab, T, C); E.line(r, aa, S, B); s = r; ab = aa } } } if (this.drawBones) { E.setColor(this.boneOriginColor); for (var U = 0, R = Q.length; U < R; U++) { var u = Q[U]; if (h && h.indexOf(u.data.name) > -1) { continue } E.circle(true, I + u.worldX, H + u.worldY, 3 * this.scale, e.GREEN, 8) } } if (this.drawClipping) { var V = z.slots; E.setColor(this.clipColor); for (var U = 0, R = V.length; U < R; U++) { var o = V[U]; if (!o.bone.active) { continue } var w = o.getAttachment(); if (!(w instanceof b.ClippingAttachment)) { continue } var L = w; var W = L.worldVerticesLength; var A = this.temp = b.Utils.setArraySize(this.temp, W, 0); L.computeWorldVertices(o, 0, W, A, 0, 2); for (var p = 0, M = A.length; p < M; p += 2) { var O = A[p]; var N = A[p + 1]; var r = A[(p + 2) % A.length]; var aa = A[(p + 3) % A.length]; E.line(O, N, r, aa) } } } }; e.prototype.dispose = function () { }; e.LIGHT_GRAY = new b.Color(192 / 255, 192 / 255, 192 / 255, 1); e.GREEN = new b.Color(0, 1, 0, 1); return e }()); c.SkeletonDebugRenderer = d })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function () { function f(g, h, i) { this.vertices = g; this.numVertices = h; this.numFloats = i } return f }()); var e = (function () { function f(h, g) { if (g === void 0) { g = true } this.premultipliedAlpha = false; this.vertexEffect = null; this.tempColor = new b.Color(); this.tempColor2 = new b.Color(); this.vertexSize = 2 + 2 + 4; this.twoColorTint = false; this.renderable = new c(null, 0, 0); this.clipper = new b.SkeletonClipping(); this.temp = new b.Vector2(); this.temp2 = new b.Vector2(); this.temp3 = new b.Color(); this.temp4 = new b.Color(); this.twoColorTint = g; if (g) { this.vertexSize += 4 } this.vertices = b.Utils.newFloatArray(this.vertexSize * 1024) } f.prototype.draw = function (ac, D, F, z) { if (F === void 0) { F = -1 } if (z === void 0) { z = -1 } var o = this.clipper; var g = this.premultipliedAlpha; var x = this.twoColorTint; var aa = null; var W = this.temp; var k = this.temp2; var E = this.temp3; var t = this.temp4; var I = this.renderable; var Q = null; var q = null; var G = D.drawOrder; var p = null; var r = D.color; var m = x ? 12 : 8; var ad = false; if (F == -1) { ad = true } for (var X = 0, V = G.length; X < V; X++) { var T = o.isClipping() ? 2 : m; var s = G[X]; if (!s.bone.active) { o.clipEndWithSlot(s); continue } if (F >= 0 && F == s.data.index) { ad = true } if (!ad) { o.clipEndWithSlot(s); continue } if (z >= 0 && z == s.data.index) { ad = false } var C = s.getAttachment(); var A = null; if (C instanceof b.RegionAttachment) { var ab = C; I.vertices = this.vertices; I.numVertices = 4; I.numFloats = T << 2; ab.computeWorldVertices(s.bone, I.vertices, 0, T); q = f.QUAD_TRIANGLES; Q = ab.uvs; A = ab.region.renderObject.texture; p = ab.color } else { if (C instanceof b.MeshAttachment) { var B = C; I.vertices = this.vertices; I.numVertices = (B.worldVerticesLength >> 1); I.numFloats = I.numVertices * T; if (I.numFloats > I.vertices.length) { I.vertices = this.vertices = b.Utils.newFloatArray(I.numFloats) } B.computeWorldVertices(s, 0, B.worldVerticesLength, I.vertices, 0, T); q = B.triangles; A = B.region.renderObject.texture; Q = B.uvs; p = B.color } else { if (C instanceof b.ClippingAttachment) { var N = (C); o.clipStart(s, N); continue } else { o.clipEndWithSlot(s); continue } } } if (A != null) { var Z = s.color; var U = this.tempColor; U.r = r.r * Z.r * p.r; U.g = r.g * Z.g * p.g; U.b = r.b * Z.b * p.b; U.a = r.a * Z.a * p.a; if (g) { U.r *= U.a; U.g *= U.a; U.b *= U.a } var h = this.tempColor2; if (s.darkColor == null) { h.set(0, 0, 0, 1) } else { if (g) { h.r = s.darkColor.r * U.a; h.g = s.darkColor.g * U.a; h.b = s.darkColor.b * U.a } else { h.setFromColor(s.darkColor) } h.a = g ? 1 : 0 } var H = s.data.blendMode; if (H != aa) { aa = H; ac.setBlendMode(d.WebGLBlendModeConverter.getSourceGLBlendMode(aa, g), d.WebGLBlendModeConverter.getDestGLBlendMode(aa)) } if (o.isClipping()) { o.clipTriangles(I.vertices, I.numFloats, q, q.length, Q, U, h, x); var w = new Float32Array(o.clippedVertices); var j = o.clippedTriangles; if (this.vertexEffect != null) { var y = this.vertexEffect; var Y = w; if (!x) { for (var R = 0, P = w.length; R < P; R += m) { W.x = Y[R]; W.y = Y[R + 1]; E.set(Y[R + 2], Y[R + 3], Y[R + 4], Y[R + 5]); k.x = Y[R + 6]; k.y = Y[R + 7]; t.set(0, 0, 0, 0); y.transform(W, k, E, t); Y[R] = W.x; Y[R + 1] = W.y; Y[R + 2] = E.r; Y[R + 3] = E.g; Y[R + 4] = E.b; Y[R + 5] = E.a; Y[R + 6] = k.x; Y[R + 7] = k.y } } else { for (var R = 0, O = w.length; R < O; R += m) { W.x = Y[R]; W.y = Y[R + 1]; E.set(Y[R + 2], Y[R + 3], Y[R + 4], Y[R + 5]); k.x = Y[R + 6]; k.y = Y[R + 7]; t.set(Y[R + 8], Y[R + 9], Y[R + 10], Y[R + 11]); y.transform(W, k, E, t); Y[R] = W.x; Y[R + 1] = W.y; Y[R + 2] = E.r; Y[R + 3] = E.g; Y[R + 4] = E.b; Y[R + 5] = E.a; Y[R + 6] = k.x; Y[R + 7] = k.y; Y[R + 8] = t.r; Y[R + 9] = t.g; Y[R + 10] = t.b; Y[R + 11] = t.a } } } ac.draw(A, w, j) } else { var Y = I.vertices; if (this.vertexEffect != null) { var y = this.vertexEffect; if (!x) { for (var R = 0, S = 0, M = I.numFloats; R < M; R += m, S += 2) { W.x = Y[R]; W.y = Y[R + 1]; k.x = Q[S]; k.y = Q[S + 1]; E.setFromColor(U); t.set(0, 0, 0, 0); y.transform(W, k, E, t); Y[R] = W.x; Y[R + 1] = W.y; Y[R + 2] = E.r; Y[R + 3] = E.g; Y[R + 4] = E.b; Y[R + 5] = E.a; Y[R + 6] = k.x; Y[R + 7] = k.y } } else { for (var R = 0, S = 0, L = I.numFloats; R < L; R += m, S += 2) { W.x = Y[R]; W.y = Y[R + 1]; k.x = Q[S]; k.y = Q[S + 1]; E.setFromColor(U); t.setFromColor(h); y.transform(W, k, E, t); Y[R] = W.x; Y[R + 1] = W.y; Y[R + 2] = E.r; Y[R + 3] = E.g; Y[R + 4] = E.b; Y[R + 5] = E.a; Y[R + 6] = k.x; Y[R + 7] = k.y; Y[R + 8] = t.r; Y[R + 9] = t.g; Y[R + 10] = t.b; Y[R + 11] = t.a } } } else { if (!x) { for (var R = 2, S = 0, K = I.numFloats; R < K; R += m, S += 2) { Y[R] = U.r; Y[R + 1] = U.g; Y[R + 2] = U.b; Y[R + 3] = U.a; Y[R + 4] = Q[S]; Y[R + 5] = Q[S + 1] } } else { for (var R = 2, S = 0, J = I.numFloats; R < J; R += m, S += 2) { Y[R] = U.r; Y[R + 1] = U.g; Y[R + 2] = U.b; Y[R + 3] = U.a; Y[R + 4] = Q[S]; Y[R + 5] = Q[S + 1]; Y[R + 6] = h.r; Y[R + 7] = h.g; Y[R + 8] = h.b; Y[R + 9] = h.a } } } var l = I.vertices.subarray(0, I.numFloats); ac.draw(A, l, q) } } o.clipEndWithSlot(s) } o.clipEnd() }; f.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0]; return f }()); d.SkeletonRenderer = e })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function () { function e(f, h, g) { if (f === void 0) { f = 0 } if (h === void 0) { h = 0 } if (g === void 0) { g = 0 } this.x = 0; this.y = 0; this.z = 0; this.x = f; this.y = h; this.z = g } e.prototype.setFrom = function (f) { this.x = f.x; this.y = f.y; this.z = f.z; return this }; e.prototype.set = function (f, h, g) { this.x = f; this.y = h; this.z = g; return this }; e.prototype.add = function (f) { this.x += f.x; this.y += f.y; this.z += f.z; return this }; e.prototype.sub = function (f) { this.x -= f.x; this.y -= f.y; this.z -= f.z; return this }; e.prototype.scale = function (f) { this.x *= f; this.y *= f; this.z *= f; return this }; e.prototype.normalize = function () { var f = this.length(); if (f == 0) { return this } f = 1 / f; this.x *= f; this.y *= f; this.z *= f; return this }; e.prototype.cross = function (f) { return this.set(this.y * f.z - this.z * f.y, this.z * f.x - this.x * f.z, this.x * f.y - this.y * f.x) }; e.prototype.multiply = function (f) { var g = f.values; return this.set(this.x * g[d.M00] + this.y * g[d.M01] + this.z * g[d.M02] + g[d.M03], this.x * g[d.M10] + this.y * g[d.M11] + this.z * g[d.M12] + g[d.M13], this.x * g[d.M20] + this.y * g[d.M21] + this.z * g[d.M22] + g[d.M23]) }; e.prototype.project = function (g) { var h = g.values; var f = 1 / (this.x * h[d.M30] + this.y * h[d.M31] + this.z * h[d.M32] + h[d.M33]); return this.set((this.x * h[d.M00] + this.y * h[d.M01] + this.z * h[d.M02] + h[d.M03]) * f, (this.x * h[d.M10] + this.y * h[d.M11] + this.z * h[d.M12] + h[d.M13]) * f, (this.x * h[d.M20] + this.y * h[d.M21] + this.z * h[d.M22] + h[d.M23]) * f) }; e.prototype.dot = function (f) { return this.x * f.x + this.y * f.y + this.z * f.z }; e.prototype.length = function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }; e.prototype.distance = function (h) { var g = h.x - this.x; var f = h.y - this.y; var i = h.z - this.z; return Math.sqrt(g * g + f * f + i * i) }; return e }()); d.Vector3 = c })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (b) { var a; (function (d) { var c = (function () { function f(g, i) { var j = this; if (i === void 0) { i = { alpha: "true" } } this.restorables = new Array(); if (g instanceof HTMLCanvasElement) { var h = g; this.gl = (h.getContext("webgl2", i) || h.getContext("webgl", i)); this.canvas = h; h.addEventListener("webglcontextlost", function (l) { var k = l; if (l) { l.preventDefault() } }); h.addEventListener("webglcontextrestored", function (l) { for (var k = 0, m = j.restorables.length; k < m; k++) { j.restorables[k].restore() } }) } else { this.gl = g; this.canvas = this.gl.canvas } } f.prototype.addRestorable = function (g) { this.restorables.push(g) }; f.prototype.removeRestorable = function (h) { var g = this.restorables.indexOf(h); if (g > -1) { this.restorables.splice(g, 1) } }; return f }()); d.ManagedWebGLRenderingContext = c; var e = (function () { function f() { } f.getDestGLBlendMode = function (g) { switch (g) { case b.BlendMode.Normal: return f.ONE_MINUS_SRC_ALPHA; case b.BlendMode.Additive: return f.ONE; case b.BlendMode.Multiply: return f.ONE_MINUS_SRC_ALPHA; case b.BlendMode.Screen: return f.ONE_MINUS_SRC_ALPHA; default: throw new Error("Unknown blend mode: " + g) } }; f.getSourceGLBlendMode = function (h, g) { if (g === void 0) { g = false } switch (h) { case b.BlendMode.Normal: return g ? f.ONE : f.SRC_ALPHA; case b.BlendMode.Additive: return g ? f.ONE : f.SRC_ALPHA; case b.BlendMode.Multiply: return f.DST_COLOR; case b.BlendMode.Screen: return f.ONE; default: throw new Error("Unknown blend mode: " + h) } }; f.ZERO = 0; f.ONE = 1; f.SRC_COLOR = 768; f.ONE_MINUS_SRC_COLOR = 769; f.SRC_ALPHA = 770; f.ONE_MINUS_SRC_ALPHA = 771; f.DST_ALPHA = 772; f.ONE_MINUS_DST_ALPHA = 773; f.DST_COLOR = 774; return f }()); d.WebGLBlendModeConverter = e })(a = b.webgl || (b.webgl = {})) })(spine || (spine = {})); var spine; (function (k) { var i = (function () { function l(m, n, o) { this.player = m; this.dom = d('\n\t\t\t\t<div class="spine-player-popup spine-player-hidden">\n\t\t\t\t</div>\n\t\t\t'); this.dom.innerHTML = o; n.appendChild(this.dom) } l.prototype.show = function (r) { var q = this; this.dom.classList.remove("spine-player-hidden"); var n = false; var m = function () { if (!n) { requestAnimationFrame(m) } var s = Math.abs(q.dom.getBoundingClientRect().bottom - q.player.getBoundingClientRect().bottom); var u = Math.abs(q.dom.getBoundingClientRect().right - q.player.getBoundingClientRect().right); var t = q.player.clientHeight - s - u; q.dom.style.maxHeight = t + "px" }; requestAnimationFrame(m); var o = true; var p = function (s) { if (o) { o = false; return } if (!g(q.dom, s.target)) { q.dom.remove(); window.removeEventListener("click", p); r(); n = true } }; window.addEventListener("click", p) }; return l }()); var a = (function () { function l(m) { this.text = m; this.enabled = false } l.prototype.render = function () { var m = this; this["switch"] = d('\n\t\t\t\t<div class="spine-player-switch">\n\t\t\t\t\t<span class="spine-player-switch-text">' + this.text + '</span>\n\t\t\t\t\t<div class="spine-player-switch-knob-area">\n\t\t\t\t\t\t<div class="spine-player-switch-knob"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t'); this["switch"].addEventListener("click", function () { m.setEnabled(!m.enabled); if (m.change) { m.change(m.enabled) } }); return this["switch"] }; l.prototype.setEnabled = function (m) { if (m) { this["switch"].classList.add("active") } else { this["switch"].classList.remove("active") } this.enabled = m }; l.prototype.isEnabled = function () { return this.enabled }; return l }()); var f = (function () { function l(o, n, m) { if (o === void 0) { o = 0 } if (n === void 0) { n = 0.1 } if (m === void 0) { m = false } this.snaps = o; this.snapPercentage = n; this.big = m } l.prototype.render = function () { var o = this; this.slider = d('\n\t\t\t\t<div class="spine-player-slider ' + (this.big ? "big" : "") + '">\n\t\t\t\t\t<div class="spine-player-slider-value"></div>\n\t\t\t\t\t<!--<div class="spine-player-slider-knob"></div>-->\n\t\t\t\t</div>\n\t\t\t'); this.value = c(this.slider, "spine-player-slider-value")[0]; this.setValue(0); var m = new k.webgl.Input(this.slider); var n = false; m.addListener({ down: function (p, q) { n = true; o.value.classList.add("hovering") }, up: function (p, r) { n = false; var q = p / o.slider.clientWidth; q = q = Math.max(0, Math.min(q, 1)); o.setValue(p / o.slider.clientWidth); if (o.change) { o.change(q) } o.value.classList.remove("hovering") }, moved: function (p, r) { if (n) { var q = p / o.slider.clientWidth; q = Math.max(0, Math.min(q, 1)); q = o.setValue(p / o.slider.clientWidth); if (o.change) { o.change(q) } } }, dragged: function (p, r) { var q = p / o.slider.clientWidth; q = Math.max(0, Math.min(q, 1)); q = o.setValue(p / o.slider.clientWidth); if (o.change) { o.change(q) } } }); return this.slider }; l.prototype.setValue = function (m) { m = Math.max(0, Math.min(1, m)); if (this.snaps > 0) { var n = m % (1 / this.snaps); if (n < (1 / this.snaps) * this.snapPercentage) { m = m - n } else { if (n > (1 / this.snaps) - (1 / this.snaps) * this.snapPercentage) { m = m - n + (1 / this.snaps) } } m = Math.max(0, Math.min(1, m)) } this.value.style.width = "" + (m * 100) + "%"; return m }; return l }()); var j = (function () { function l(n, m) { this.config = m; this.time = new k.TimeKeeper(); this.paused = true; this.playTime = 0; this.speed = 1; this.animationViewports = {}; this.currentViewport = null; this.previousViewport = null; this.viewportTransitionStart = 0; this.stopRequestAnimationFrame = false; this.cancelId = 0; if (typeof n === "string") { this.parent = document.getElementById(n) } else { this.parent = n } this.parent.appendChild(this.render()) } l.prototype.validateConfig = function (m) { if (!m) { throw new Error("Please pass a configuration to new.spine.SpinePlayer().") } if (!m.jsonUrl && !m.skelUrl) { throw new Error("Please specify the URL of the skeleton JSON or .skel file.") } if (!m.atlasUrl) { throw new Error("Please specify the URL of the atlas file.") } if (!m.alpha) { m.alpha = false } if (!m.backgroundColor) { m.backgroundColor = "#000000" } if (!m.fullScreenBackgroundColor) { m.fullScreenBackgroundColor = m.backgroundColor } if (typeof m.premultipliedAlpha === "undefined") { m.premultipliedAlpha = true } if (!m.success) { m.success = function (n) { } } if (!m.error) { m.error = function (n, o) { } } if (!m.debug) { m.debug = { bones: false, regions: false, meshes: false, bounds: false, clipping: false, paths: false, points: false, hulls: false } } if (typeof m.debug.bones === "undefined") { m.debug.bones = false } if (typeof m.debug.bounds === "undefined") { m.debug.bounds = false } if (typeof m.debug.clipping === "undefined") { m.debug.clipping = false } if (typeof m.debug.hulls === "undefined") { m.debug.hulls = false } if (typeof m.debug.paths === "undefined") { m.debug.paths = false } if (typeof m.debug.points === "undefined") { m.debug.points = false } if (typeof m.debug.regions === "undefined") { m.debug.regions = false } if (typeof m.debug.meshes === "undefined") { m.debug.meshes = false } if (m.animations && m.animation) { if (m.animations.indexOf(m.animation) < 0) { throw new Error("Default animation '" + m.animation + "' is not contained in the list of selectable animations " + e(JSON.stringify(this.config.animations)) + ".") } } if (m.skins && m.skin) { if (m.skins.indexOf(m.skin) < 0) { throw new Error("Default skin '" + m.skin + "' is not contained in the list of selectable skins " + e(JSON.stringify(this.config.skins)) + ".") } } if (!m.controlBones) { m.controlBones = [] } if (typeof m.showControls === "undefined") { m.showControls = true } if (typeof m.defaultMix === "undefined") { m.defaultMix = 0.25 } return m }; l.prototype.showError = function (m) { var n = c(this.dom, "spine-player-error")[0]; n.classList.remove("spine-player-hidden"); n.innerHTML = '<p style="text-align: center; align-self: center;">' + m + "</p>"; this.config.error(this, m) }; l.prototype.render = function () { var w = this; var p = this.config; var s = this.dom = d('\n\t\t\t\t<div class="spine-player">\n\t\t\t\t\t<canvas class="spine-player-canvas"></canvas>\n\t\t\t\t\t<div class="spine-player-error spine-player-hidden"></div>\n\t\t\t\t\t<div class="spine-player-controls spine-player-popup-parent spine-player-controls-hidden">\n\t\t\t\t\t\t<div class="spine-player-timeline">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class="spine-player-buttons">\n\t\t\t\t\t\t\t<button id="spine-player-button-play-pause" class="spine-player-button spine-player-button-icon-pause"></button>\n\t\t\t\t\t\t\t<div class="spine-player-button-spacer"></div>\n\t\t\t\t\t\t\t<button id="spine-player-button-speed" class="spine-player-button spine-player-button-icon-speed"></button>\n\t\t\t\t\t\t\t<button id="spine-player-button-animation" class="spine-player-button spine-player-button-icon-animations"></button>\n\t\t\t\t\t\t\t<button id="spine-player-button-skin" class="spine-player-button spine-player-button-icon-skins"></button>\n\t\t\t\t\t\t\t<button id="spine-player-button-settings" class="spine-player-button spine-player-button-icon-settings"></button>\n\t\t\t\t\t\t\t<button id="spine-player-button-fullscreen" class="spine-player-button spine-player-button-icon-fullscreen"></button>\n\t\t\t\t\t\t\t<img id="spine-player-button-logo" class="spine-player-button-icon-spine-logo" src="data:image/svg+xml,%3Csvg%20id%3D%22Spine_Logo%22%20data-name%3D%22Spine%20Logo%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20104%2031.16%22%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill%3A%23fff%3B%7D.cls-2%7Bfill%3A%23ff4000%3B%7D%3C%2Fstyle%3E%3C%2Fdefs%3E%3Ctitle%3Espine-logo-white%3C%2Ftitle%3E%3Cpath%20id%3D%22e%22%20class%3D%22cls-1%22%20d%3D%22M104%2C12.68a1.31%2C1.31%2C0%2C0%2C1-.37%2C1%2C1.28%2C1.28%2C0%2C0%2C1-.85.31H91.57a10.51%2C10.51%2C0%2C0%2C0%2C.29%2C2.55%2C4.92%2C4.92%2C0%2C0%2C0%2C1%2C2A4.27%2C4.27%2C0%2C0%2C0%2C94.5%2C19.8a6.89%2C6.89%2C0%2C0%2C0%2C2.6.44%2C10.66%2C10.66%2C0%2C0%2C0%2C2.17-.2%2C12.81%2C12.81%2C0%2C0%2C0%2C1.64-.44q.69-.25%2C1.14-.44a1.87%2C1.87%2C0%2C0%2C1%2C.68-.2A.44.44%2C0%2C0%2C1%2C103%2C19a.43.43%2C0%2C0%2C1%2C.16.2%2C1.38%2C1.38%2C0%2C0%2C1%2C.09.37%2C4.89%2C4.89%2C0%2C0%2C1%2C0%2C.58%2C4.14%2C4.14%2C0%2C0%2C1%2C0%2C.43v.32a.83.83%2C0%2C0%2C1-.09.26%2C1.1%2C1.1%2C0%2C0%2C1-.17.22%2C2.77%2C2.77%2C0%2C0%2C1-.61.34%2C8.94%2C8.94%2C0%2C0%2C1-1.32.46%2C18.54%2C18.54%2C0%2C0%2C1-1.88.41%2C13.78%2C13.78%2C0%2C0%2C1-2.28.18%2C10.55%2C10.55%2C0%2C0%2C1-3.68-.59%2C6.82%2C6.82%2C0%2C0%2C1-2.66-1.74%2C7.44%2C7.44%2C0%2C0%2C1-1.63-2.89%2C13.48%2C13.48%2C0%2C0%2C1-.55-4%2C12.76%2C12.76%2C0%2C0%2C1%2C.57-3.94%2C8.35%2C8.35%2C0%2C0%2C1%2C1.64-3%2C7.15%2C7.15%2C0%2C0%2C1%2C2.58-1.87%2C8.47%2C8.47%2C0%2C0%2C1%2C3.39-.65%2C8.19%2C8.19%2C0%2C0%2C1%2C3.41.64%2C6.46%2C6.46%2C0%2C0%2C1%2C2.32%2C1.73A7%2C7%2C0%2C0%2C1%2C103.59%2C9a11.17%2C11.17%2C0%2C0%2C1%2C.43%2C3.13Zm-3.14-.93a5.69%2C5.69%2C0%2C0%2C0-1.09-3.86%2C4.17%2C4.17%2C0%2C0%2C0-3.42-1.4%2C4.52%2C4.52%2C0%2C0%2C0-2%2C.44%2C4.41%2C4.41%2C0%2C0%2C0-1.47%2C1.15A5.29%2C5.29%2C0%2C0%2C0%2C92%2C9.75a7%2C7%2C0%2C0%2C0-.36%2C2Z%22%2F%3E%3Cpath%20id%3D%22n%22%20class%3D%22cls-1%22%20d%3D%22M80.68%2C21.94a.42.42%2C0%2C0%2C1-.08.26.59.59%2C0%2C0%2C1-.25.18%2C1.74%2C1.74%2C0%2C0%2C1-.47.11%2C6.31%2C6.31%2C0%2C0%2C1-.76%2C0%2C6.5%2C6.5%2C0%2C0%2C1-.78%2C0%2C1.74%2C1.74%2C0%2C0%2C1-.47-.11.59.59%2C0%2C0%2C1-.25-.18.42.42%2C0%2C0%2C1-.08-.26V12a9.8%2C9.8%2C0%2C0%2C0-.23-2.35%2C4.86%2C4.86%2C0%2C0%2C0-.66-1.53%2C2.88%2C2.88%2C0%2C0%2C0-1.13-1%2C3.57%2C3.57%2C0%2C0%2C0-1.6-.34%2C4%2C4%2C0%2C0%2C0-2.35.83A12.71%2C12.71%2C0%2C0%2C0%2C69.11%2C10v11.9a.42.42%2C0%2C0%2C1-.08.26.59.59%2C0%2C0%2C1-.25.18%2C1.74%2C1.74%2C0%2C0%2C1-.47.11%2C6.51%2C6.51%2C0%2C0%2C1-.78%2C0%2C6.31%2C6.31%2C0%2C0%2C1-.76%2C0%2C1.88%2C1.88%2C0%2C0%2C1-.48-.11.52.52%2C0%2C0%2C1-.25-.18.46.46%2C0%2C0%2C1-.07-.26v-17A.53.53%2C0%2C0%2C1%2C66%2C4.69a.5.5%2C0%2C0%2C1%2C.23-.19%2C1.28%2C1.28%2C0%2C0%2C1%2C.44-.11%2C8.53%2C8.53%2C0%2C0%2C1%2C1.39%2C0%2C1.12%2C1.12%2C0%2C0%2C1%2C.43.11.6.6%2C0%2C0%2C1%2C.22.19.47.47%2C0%2C0%2C1%2C.07.26V7.2a10.46%2C10.46%2C0%2C0%2C1%2C2.87-2.36%2C6.17%2C6.17%2C0%2C0%2C1%2C2.88-.75%2C6.41%2C6.41%2C0%2C0%2C1%2C2.87.58%2C5.16%2C5.16%2C0%2C0%2C1%2C1.88%2C1.54%2C6.15%2C6.15%2C0%2C0%2C1%2C1%2C2.26%2C13.46%2C13.46%2C0%2C0%2C1%2C.31%2C3.11Z%22%2F%3E%3Cg%20id%3D%22i%22%3E%3Cpath%20class%3D%22cls-2%22%20d%3D%22M43.35%2C2.86c.09%2C2.6%2C1.89%2C4%2C5.48%2C4.61%2C3%2C.48%2C5.79.24%2C6.69-2.37%2C1.75-5.09-2.4-3.82-6-4.39S43.21-1.32%2C43.35%2C2.86Z%22%2F%3E%3Cpath%20class%3D%22cls-2%22%20d%3D%22M44.43%2C13.55c.33%2C1.94%2C2.14%2C3.06%2C4.91%2C3s4.84-1.16%2C5.13-3.25c.53-3.88-2.53-2.38-5.3-2.3S43.77%2C9.74%2C44.43%2C13.55Z%22%2F%3E%3Cpath%20class%3D%22cls-2%22%20d%3D%22M48%2C22.44c.55%2C1.45%2C2.06%2C2.06%2C4.1%2C1.63s3.45-1.11%2C3.33-2.76c-.21-3.06-2.22-2.1-4.26-1.66S47%2C19.6%2C48%2C22.44Z%22%2F%3E%3Cpath%20class%3D%22cls-2%22%20d%3D%22M49.78%2C29.22c.16%2C1.22%2C1.22%2C2%2C2.88%2C1.93s2.92-.67%2C3.13-2c.4-2.43-1.46-1.53-3.12-1.51S49.5%2C26.82%2C49.78%2C29.22Z%22%2F%3E%3C%2Fg%3E%3Cpath%20id%3D%22p%22%20class%3D%22cls-1%22%20d%3D%22M35.28%2C13.16a15.33%2C15.33%2C0%2C0%2C1-.48%2C4%2C8.75%2C8.75%2C0%2C0%2C1-1.42%2C3%2C6.35%2C6.35%2C0%2C0%2C1-2.32%2C1.91%2C7.14%2C7.14%2C0%2C0%2C1-3.16.67%2C6.1%2C6.1%2C0%2C0%2C1-1.4-.15%2C5.34%2C5.34%2C0%2C0%2C1-1.26-.47A7.29%2C7.29%2C0%2C0%2C1%2C24%2C21.31q-.61-.49-1.29-1.15v8.51a.47.47%2C0%2C0%2C1-.08.26.56.56%2C0%2C0%2C1-.25.19%2C1.74%2C1.74%2C0%2C0%2C1-.47.11%2C6.47%2C6.47%2C0%2C0%2C1-.78%2C0%2C6.26%2C6.26%2C0%2C0%2C1-.76%2C0%2C1.89%2C1.89%2C0%2C0%2C1-.48-.11.49.49%2C0%2C0%2C1-.25-.19.51.51%2C0%2C0%2C1-.07-.26V4.91a.57.57%2C0%2C0%2C1%2C.06-.27.46.46%2C0%2C0%2C1%2C.23-.18%2C1.47%2C1.47%2C0%2C0%2C1%2C.44-.1%2C7.41%2C7.41%2C0%2C0%2C1%2C1.3%2C0%2C1.45%2C1.45%2C0%2C0%2C1%2C.43.1.52.52%2C0%2C0%2C1%2C.24.18.51.51%2C0%2C0%2C1%2C.07.27V7.2a18.06%2C18.06%2C0%2C0%2C1%2C1.49-1.38%2C9%2C9%2C0%2C0%2C1%2C1.45-1%2C6.82%2C6.82%2C0%2C0%2C1%2C1.49-.59%2C7.09%2C7.09%2C0%2C0%2C1%2C4.78.52%2C6%2C6%2C0%2C0%2C1%2C2.13%2C2%2C8.79%2C8.79%2C0%2C0%2C1%2C1.2%2C2.9A15.72%2C15.72%2C0%2C0%2C1%2C35.28%2C13.16ZM32%2C13.52a15.64%2C15.64%2C0%2C0%2C0-.2-2.53%2C7.32%2C7.32%2C0%2C0%2C0-.69-2.17%2C4.06%2C4.06%2C0%2C0%2C0-1.3-1.51%2C3.49%2C3.49%2C0%2C0%2C0-2-.57%2C4.1%2C4.1%2C0%2C0%2C0-1.2.18%2C4.92%2C4.92%2C0%2C0%2C0-1.2.57%2C8.54%2C8.54%2C0%2C0%2C0-1.28%2C1A15.77%2C15.77%2C0%2C0%2C0%2C22.76%2C10v6.77a13.53%2C13.53%2C0%2C0%2C0%2C2.46%2C2.4%2C4.12%2C4.12%2C0%2C0%2C0%2C2.44.83%2C3.56%2C3.56%2C0%2C0%2C0%2C2-.57A4.28%2C4.28%2C0%2C0%2C0%2C31%2C18a7.58%2C7.58%2C0%2C0%2C0%2C.77-2.12A11.43%2C11.43%2C0%2C0%2C0%2C32%2C13.52Z%22%2F%3E%3Cpath%20id%3D%22s%22%20class%3D%22cls-1%22%20d%3D%22M12%2C17.3a5.39%2C5.39%2C0%2C0%2C1-.48%2C2.33%2C4.73%2C4.73%2C0%2C0%2C1-1.37%2C1.72%2C6.19%2C6.19%2C0%2C0%2C1-2.12%2C1.06%2C9.62%2C9.62%2C0%2C0%2C1-2.71.36%2C10.38%2C10.38%2C0%2C0%2C1-3.21-.5%2C7.63%2C7.63%2C0%2C0%2C1-1.11-.45%2C3.25%2C3.25%2C0%2C0%2C1-.66-.43%2C1.09%2C1.09%2C0%2C0%2C1-.3-.53A3.59%2C3.59%2C0%2C0%2C1%2C0%2C19.93a4.06%2C4.06%2C0%2C0%2C1%2C0-.61%2C2%2C2%2C0%2C0%2C1%2C.09-.4.42.42%2C0%2C0%2C1%2C.16-.22.43.43%2C0%2C0%2C1%2C.24-.07%2C1.35%2C1.35%2C0%2C0%2C1%2C.61.26q.41.26%2C1%2C.56A9.22%2C9.22%2C0%2C0%2C0%2C3.51%2C20a6.25%2C6.25%2C0%2C0%2C0%2C1.87.26%2C5.62%2C5.62%2C0%2C0%2C0%2C1.44-.17%2C3.48%2C3.48%2C0%2C0%2C0%2C1.12-.5%2C2.23%2C2.23%2C0%2C0%2C0%2C.73-.84%2C2.68%2C2.68%2C0%2C0%2C0%2C.26-1.21%2C2%2C2%2C0%2C0%2C0-.37-1.21%2C3.55%2C3.55%2C0%2C0%2C0-1-.87A8.09%2C8.09%2C0%2C0%2C0%2C6.2%2C14.8l-1.56-.61a16%2C16%2C0%2C0%2C1-1.57-.73%2C6%2C6%2C0%2C0%2C1-1.37-1%2C4.52%2C4.52%2C0%2C0%2C1-1-1.4%2C4.69%2C4.69%2C0%2C0%2C1-.37-2A4.88%2C4.88%2C0%2C0%2C1%2C.72%2C7.19%2C4.46%2C4.46%2C0%2C0%2C1%2C1.88%2C5.58%2C5.83%2C5.83%2C0%2C0%2C1%2C3.82%2C4.47%2C8.06%2C8.06%2C0%2C0%2C1%2C6.53%2C4a8.28%2C8.28%2C0%2C0%2C1%2C1.36.11%2C9.36%2C9.36%2C0%2C0%2C1%2C1.23.28%2C5.92%2C5.92%2C0%2C0%2C1%2C.94.37%2C4.09%2C4.09%2C0%2C0%2C1%2C.59.35%2C1%2C1%2C0%2C0%2C1%2C.26.26.83.83%2C0%2C0%2C1%2C.09.26%2C1.32%2C1.32%2C0%2C0%2C0%2C.06.35%2C3.87%2C3.87%2C0%2C0%2C1%2C0%2C.51%2C4.76%2C4.76%2C0%2C0%2C1%2C0%2C.56%2C1.39%2C1.39%2C0%2C0%2C1-.09.39.5.5%2C0%2C0%2C1-.16.22.35.35%2C0%2C0%2C1-.21.07%2C1%2C1%2C0%2C0%2C1-.49-.21%2C7%2C7%2C0%2C0%2C0-.83-.44%2C9.26%2C9.26%2C0%2C0%2C0-1.2-.44A5.49%2C5.49%2C0%2C0%2C0%2C6.5%2C6.48a4.93%2C4.93%2C0%2C0%2C0-1.4.18%2C2.69%2C2.69%2C0%2C0%2C0-1%2C.51A2.16%2C2.16%2C0%2C0%2C0%2C3.51%2C8a2.43%2C2.43%2C0%2C0%2C0-.2%2C1%2C2%2C2%2C0%2C0%2C0%2C.38%2C1.24%2C3.6%2C3.6%2C0%2C0%2C0%2C1%2C.88%2C8.25%2C8.25%2C0%2C0%2C0%2C1.38.68l1.58.62q.8.32%2C1.59.72a6%2C6%2C0%2C0%2C1%2C1.39%2C1%2C4.37%2C4.37%2C0%2C0%2C1%2C1%2C1.36A4.46%2C4.46%2C0%2C0%2C1%2C12%2C17.3Z%22%2F%3E%3C%2Fsvg%3E"/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t'); try { this.config = this.validateConfig(p) } catch (x) { this.showError(x); return s } try { this.canvas = c(s, "spine-player-canvas")[0]; var o = { alpha: p.alpha }; this.context = new k.webgl.ManagedWebGLRenderingContext(this.canvas, o); this.sceneRenderer = new k.webgl.SceneRenderer(this.canvas, this.context, true); this.loadingScreen = new k.webgl.LoadingScreen(this.sceneRenderer) } catch (x) { this.showError("Sorry, your browser does not support WebGL.<br><br>Please use the latest version of Firefox, Chrome, Edge, or Safari."); return s } this.assetManager = new k.webgl.AssetManager(this.context); if (p.rawDataURIs) { for (var C in p.rawDataURIs) { var t = p.rawDataURIs[C]; this.assetManager.setRawDataURI(C, t) } } if (p.jsonUrl) { this.assetManager.loadText(p.jsonUrl) } else { this.assetManager.loadBinary(p.skelUrl) } this.assetManager.loadTextureAtlas(p.atlasUrl); if (p.backgroundImage && p.backgroundImage.url) { this.assetManager.loadTexture(p.backgroundImage.url) } requestAnimationFrame(function () { return w.drawFrame() }); this.playerControls = c(s, "spine-player-controls")[0]; var A = c(s, "spine-player-timeline")[0]; this.timelineSlider = new f(); A.appendChild(this.timelineSlider.render()); this.playButton = b(s, "spine-player-button-play-pause")[0]; var q = b(s, "spine-player-button-speed")[0]; this.animationButton = b(s, "spine-player-button-animation")[0]; this.skinButton = b(s, "spine-player-button-skin")[0]; var n = b(s, "spine-player-button-settings")[0]; var B = b(s, "spine-player-button-fullscreen")[0]; var y = b(s, "spine-player-button-logo")[0]; this.playButton.onclick = function () { if (w.paused) { w.play() } else { w.pause() } }; q.onclick = function () { w.showSpeedDialog(q) }; this.animationButton.onclick = function () { w.showAnimationsDialog(w.animationButton) }; this.skinButton.onclick = function () { w.showSkinsDialog(w.skinButton) }; n.onclick = function () { w.showSettingsDialog(n) }; var r = this.canvas.clientWidth; var z = this.canvas.clientHeight; var v = this.canvas.style.width; var m = this.canvas.style.height; var u = false; B.onclick = function () { var D = function () { u = !u; if (!u) { w.canvas.style.width = "" + r + "px"; w.canvas.style.height = "" + z + "px"; w.drawFrame(false); requestAnimationFrame(function () { w.canvas.style.width = v; w.canvas.style.height = m }) } }; var F = document; s.onfullscreenchange = D; s.onwebkitfullscreenchange = D; if (F.fullscreenElement || F.webkitFullscreenElement || F.mozFullScreenElement || F.msFullscreenElement) { if (F.exitFullscreen) { F.exitFullscreen() } else { if (F.mozCancelFullScreen) { F.mozCancelFullScreen() } else { if (F.webkitExitFullscreen) { F.webkitExitFullscreen() } else { if (F.msExitFullscreen) { F.msExitFullscreen() } } } } } else { r = w.canvas.clientWidth; z = w.canvas.clientHeight; v = w.canvas.style.width; m = w.canvas.style.height; var E = s; if (E.requestFullscreen) { E.requestFullscreen() } else { if (E.webkitRequestFullScreen) { E.webkitRequestFullScreen() } else { if (E.mozRequestFullScreen) { E.mozRequestFullScreen() } else { if (E.msRequestFullscreen) { E.msRequestFullscreen() } } } } } }; y.onclick = function () { window.open("http://esotericsoftware.com") }; window.onresize = function () { w.drawFrame(false) }; return s }; l.prototype.showSpeedDialog = function (n) { var q = this; if (this.lastPopup) { this.lastPopup.dom.remove() } if (this.lastPopup && c(this.lastPopup.dom, "spine-player-popup-title")[0].textContent == "Speed") { this.lastPopup = null; n.classList.remove("spine-player-button-icon-speed-selected"); return } var m = new i(this.dom, this.playerControls, '\n\t\t\t\t<div class="spine-player-popup-title">Speed</div>\n\t\t\t\t<hr>\n\t\t\t\t<div class="spine-player-row" style="user-select: none; align-items: center; padding: 8px;">\n\t\t\t\t\t<div class="spine-player-column">\n\t\t\t\t\t\t<div class="spine-player-speed-slider" style="margin-bottom: 4px;"></div>\n\t\t\t\t\t\t<div class="spine-player-row" style="justify-content: space-between;">\n\t\t\t\t\t\t\t<div>0.1x</div>\n\t\t\t\t\t\t\t<div>1x</div>\n\t\t\t\t\t\t\t<div>2x</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t'); var o = c(m.dom, "spine-player-speed-slider")[0]; var p = new f(2, 0.1, true); o.appendChild(p.render()); p.setValue(this.speed / 2); p.change = function (r) { q.speed = r * 2 }; n.classList.add("spine-player-button-icon-speed-selected"); m.show(function () { n.classList.remove("spine-player-button-icon-speed-selected"); m.dom.remove(); q.lastPopup = null }); this.lastPopup = m }; l.prototype.showAnimationsDialog = function (n) { var p = this; if (this.lastPopup) { this.lastPopup.dom.remove() } if (this.lastPopup && c(this.lastPopup.dom, "spine-player-popup-title")[0].textContent == "Animations") { this.lastPopup = null; n.classList.remove("spine-player-button-icon-animations-selected"); return } if (!this.skeleton || this.skeleton.data.animations.length == 0) { return } var m = new i(this.dom, this.playerControls, '\n\t\t\t\t<div class="spine-player-popup-title">Animations</div>\n\t\t\t\t<hr>\n\t\t\t\t<ul class="spine-player-list"></ul>\n\t\t\t'); var o = c(m.dom, "spine-player-list")[0]; this.skeleton.data.animations.forEach(function (q) { if (p.config.animations && p.config.animations.indexOf(q.name) < 0) { return } var r = d('\n\t\t\t\t\t<li class="spine-player-list-item selectable">\n\t\t\t\t\t\t<div class="selectable-circle">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class="selectable-text">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</li>\n\t\t\t\t'); if (q.name == p.config.animation) { r.classList.add("selected") } c(r, "selectable-text")[0].innerText = q.name; o.appendChild(r); r.onclick = function () { h(o.children, "selected"); r.classList.add("selected"); p.config.animation = q.name; p.playTime = 0; p.setAnimation(q.name) } }); n.classList.add("spine-player-button-icon-animations-selected"); m.show(function () { n.classList.remove("spine-player-button-icon-animations-selected"); m.dom.remove(); p.lastPopup = null }); this.lastPopup = m }; l.prototype.showSkinsDialog = function (o) { var p = this; if (this.lastPopup) { this.lastPopup.dom.remove() } if (this.lastPopup && c(this.lastPopup.dom, "spine-player-popup-title")[0].textContent == "Skins") { this.lastPopup = null; o.classList.remove("spine-player-button-icon-skins-selected"); return } if (!this.skeleton || this.skeleton.data.animations.length == 0) { return } var m = new i(this.dom, this.playerControls, '\n\t\t\t\t<div class="spine-player-popup-title">Skins</div>\n\t\t\t\t<hr>\n\t\t\t\t<ul class="spine-player-list"></ul>\n\t\t\t'); var n = c(m.dom, "spine-player-list")[0]; this.skeleton.data.skins.forEach(function (q) { if (p.config.skins && p.config.skins.indexOf(q.name) < 0) { return } var r = d('\n\t\t\t\t\t<li class="spine-player-list-item selectable">\n\t\t\t\t\t\t<div class="selectable-circle">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class="selectable-text">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</li>\n\t\t\t\t'); if (q.name == p.config.skin) { r.classList.add("selected") } c(r, "selectable-text")[0].innerText = q.name; n.appendChild(r); r.onclick = function () { h(n.children, "selected"); r.classList.add("selected"); p.config.skin = q.name; p.skeleton.setSkinByName(p.config.skin); p.skeleton.setSlotsToSetupPose() } }); o.classList.add("spine-player-button-icon-skins-selected"); m.show(function () { o.classList.remove("spine-player-button-icon-skins-selected"); m.dom.remove(); p.lastPopup = null }); this.lastPopup = m }; l.prototype.showSettingsDialog = function (o) { var q = this; if (this.lastPopup) { this.lastPopup.dom.remove() } if (this.lastPopup && c(this.lastPopup.dom, "spine-player-popup-title")[0].textContent == "Debug") { this.lastPopup = null; o.classList.remove("spine-player-button-icon-settings-selected"); return } if (!this.skeleton || this.skeleton.data.animations.length == 0) { return } var n = new i(this.dom, this.playerControls, '\n\t\t\t\t<div class="spine-player-popup-title">Debug</div>\n\t\t\t\t<hr>\n\t\t\t\t<ul class="spine-player-list">\n\t\t\t\t</li>\n\t\t\t'); var p = c(n.dom, "spine-player-list")[0]; var m = function (t, r) { var v = d('<li class="spine-player-list-item"></li>'); var u = new a(t); v.appendChild(u.render()); u.setEnabled(q.config.debug[r]); u.change = function (s) { q.config.debug[r] = s }; p.appendChild(v) }; m("Bones", "bones"); m("Regions", "regions"); m("Meshes", "meshes"); m("Bounds", "bounds"); m("Paths", "paths"); m("Clipping", "clipping"); m("Points", "points"); m("Hulls", "hulls"); o.classList.add("spine-player-button-icon-settings-selected"); n.show(function () { o.classList.remove("spine-player-button-icon-settings-selected"); n.dom.remove(); q.lastPopup = null }); this.lastPopup = n }; l.prototype.drawFrame = function (D) { var x = this; if (D === void 0) { D = true } if (D && !this.stopRequestAnimationFrame) { requestAnimationFrame(function () { return x.drawFrame() }) } var w = this.context; var z = w.gl; var G = document; var t = G.fullscreenElement || G.webkitFullscreenElement || G.mozFullScreenElement || G.msFullscreenElement; var p = new k.Color().setFromString(t ? this.config.fullScreenBackgroundColor : this.config.backgroundColor); z.clearColor(p.r, p.g, p.b, p.a); z.clear(z.COLOR_BUFFER_BIT); this.loadingScreen.backgroundColor.setFromColor(p); this.loadingScreen.draw(this.assetManager.isLoadingComplete()); if (this.assetManager.isLoadingComplete() && this.skeleton == null) { this.loadSkeleton() } this.sceneRenderer.resize(k.webgl.ResizeMode.Expand); if (this.loaded) { if (!this.paused && this.config.animation) { this.time.update(); var E = this.time.delta * this.speed; var B = this.animationState.getCurrent(0).animation.duration; this.playTime += E; while (this.playTime >= B && B != 0) { this.playTime -= B } this.playTime = Math.max(0, Math.min(this.playTime, B)); this.timelineSlider.setValue(this.playTime / B); this.animationState.update(E); this.animationState.apply(this.skeleton) } this.skeleton.updateWorldTransform(); var A = { x: this.currentViewport.x - this.currentViewport.padLeft, y: this.currentViewport.y - this.currentViewport.padBottom, width: this.currentViewport.width + this.currentViewport.padLeft + this.currentViewport.padRight, height: this.currentViewport.height + this.currentViewport.padBottom + this.currentViewport.padTop }; var u = ((performance.now() - this.viewportTransitionStart) / 1000) / this.config.viewport.transitionTime; if (this.previousViewport && u < 1) { var s = { x: this.previousViewport.x - this.previousViewport.padLeft, y: this.previousViewport.y - this.previousViewport.padBottom, width: this.previousViewport.width + this.previousViewport.padLeft + this.previousViewport.padRight, height: this.previousViewport.height + this.previousViewport.padBottom + this.previousViewport.padTop }; A = { x: s.x + (A.x - s.x) * u, y: s.y + (A.y - s.y) * u, width: s.width + (A.width - s.width) * u, height: s.height + (A.height - s.height) * u } } var m = this.scale(A.width, A.height, this.canvas.width, this.canvas.height); this.sceneRenderer.camera.zoom = A.width / m.x; this.sceneRenderer.camera.position.x = A.x + A.width / 2; this.sceneRenderer.camera.position.y = A.y + A.height / 2; this.sceneRenderer.begin(); if (this.config.backgroundImage && this.config.backgroundImage.url) { var o = this.assetManager.get(this.config.backgroundImage.url); if (!(this.config.backgroundImage.hasOwnProperty("x") && this.config.backgroundImage.hasOwnProperty("y") && this.config.backgroundImage.hasOwnProperty("width") && this.config.backgroundImage.hasOwnProperty("height"))) { this.sceneRenderer.drawTexture(o, A.x, A.y, A.width, A.height) } else { this.sceneRenderer.drawTexture(o, this.config.backgroundImage.x, this.config.backgroundImage.y, this.config.backgroundImage.width, this.config.backgroundImage.height) } } this.sceneRenderer.drawSkeleton(this.skeleton, this.config.premultipliedAlpha); this.sceneRenderer.skeletonDebugRenderer.drawBones = this.config.debug.bones; this.sceneRenderer.skeletonDebugRenderer.drawBoundingBoxes = this.config.debug.bounds; this.sceneRenderer.skeletonDebugRenderer.drawClipping = this.config.debug.clipping; this.sceneRenderer.skeletonDebugRenderer.drawMeshHull = this.config.debug.hulls; this.sceneRenderer.skeletonDebugRenderer.drawPaths = this.config.debug.paths; this.sceneRenderer.skeletonDebugRenderer.drawRegionAttachments = this.config.debug.regions; this.sceneRenderer.skeletonDebugRenderer.drawMeshTriangles = this.config.debug.meshes; this.sceneRenderer.drawSkeletonDebug(this.skeleton, this.config.premultipliedAlpha); var n = this.config.controlBones; var v = this.selectedBones; var q = this.skeleton; z.lineWidth(2); for (var y = 0; y < n.length; y++) { var r = q.findBone(n[y]); if (!r) { continue } var C = v[y] !== null ? l.HOVER_COLOR_INNER : l.NON_HOVER_COLOR_INNER; var F = v[y] !== null ? l.HOVER_COLOR_OUTER : l.NON_HOVER_COLOR_OUTER; this.sceneRenderer.circle(true, q.x + r.worldX, q.y + r.worldY, 20, C); this.sceneRenderer.circle(false, q.x + r.worldX, q.y + r.worldY, 20, F) } z.lineWidth(1); if (this.config.viewport.debugRender) { this.sceneRenderer.rect(false, this.currentViewport.x, this.currentViewport.y, this.currentViewport.width, this.currentViewport.height, k.Color.GREEN); this.sceneRenderer.rect(false, A.x, A.y, A.width, A.height, k.Color.RED) } this.sceneRenderer.end(); this.sceneRenderer.camera.zoom = 0 } }; l.prototype.scale = function (p, s, r, m) { var q = m / r; var o = s / p; var t = q > o ? r / p : m / s; var n = new k.Vector2(); n.x = p * t; n.y = s * t; return n }; l.prototype.loadSkeleton = function () { var r = this; if (this.loaded) { return } if (this.assetManager.hasErrors()) { this.showError("Error: assets could not be loaded.<br><br>" + e(JSON.stringify(this.assetManager.getErrors()))); return } var m = this.assetManager.get(this.config.atlasUrl); var n; if (this.config.jsonUrl) { var o = this.assetManager.get(this.config.jsonUrl); var u = new k.SkeletonJson(new k.AtlasAttachmentLoader(m)); try { n = u.readSkeletonData(o) } catch (s) { this.showError("Error: could not load skeleton .json.<br><br>" + e(JSON.stringify(s))); return } } else { var t = this.assetManager.get(this.config.skelUrl); var q = new k.SkeletonBinary(new k.AtlasAttachmentLoader(m)); try { n = q.readSkeletonData(t) } catch (s) { this.showError("Error: could not load skeleton .skel.<br><br>" + e(JSON.stringify(s))); return } } this.skeleton = new k.Skeleton(n); var p = new k.AnimationStateData(n); p.defaultMix = this.config.defaultMix; this.animationState = new k.AnimationState(p); if (this.config.controlBones) { this.config.controlBones.forEach(function (v) { if (!n.findBone(v)) { r.showError("Error: control bone '" + v + "' does not exist in skeleton.") } }) } if (!this.config.skin) { if (n.skins.length > 0) { this.config.skin = n.skins[0].name } } if (this.config.skins && this.config.skin.length > 0) { this.config.skins.forEach(function (v) { if (!r.skeleton.data.findSkin(v)) { r.showError("Error: skin '" + v + "' in selectable skin list does not exist in skeleton."); return } }) } if (this.config.skin) { if (!this.skeleton.data.findSkin(this.config.skin)) { this.showError("Error: skin '" + this.config.skin + "' does not exist in skeleton."); return } this.skeleton.setSkinByName(this.config.skin); this.skeleton.setSlotsToSetupPose() } if (!this.config.viewport) { this.config.viewport = { animations: {}, debugRender: false, transitionTime: 0.2 } } if (typeof this.config.viewport.debugRender === "undefined") { this.config.viewport.debugRender = false } if (typeof this.config.viewport.transitionTime === "undefined") { this.config.viewport.transitionTime = 0.2 } if (!this.config.viewport.animations) { this.config.viewport.animations = {} } else { Object.getOwnPropertyNames(this.config.viewport.animations).forEach(function (v) { if (!n.findAnimation(v)) { r.showError("Error: animation '" + v + "' for which a viewport was specified does not exist in skeleton."); return } }) } if (this.config.animations && this.config.animations.length > 0) { this.config.animations.forEach(function (v) { if (!r.skeleton.data.findAnimation(v)) { r.showError("Error: animation '" + v + "' in selectable animation list does not exist in skeleton."); return } }); if (!this.config.animation) { this.config.animation = this.config.animations[0] } } if (!this.config.animation) { if (n.animations.length > 0) { this.config.animation = n.animations[0].name } } if (this.config.animation) { if (!n.findAnimation(this.config.animation)) { this.showError("Error: animation '" + this.config.animation + "' does not exist in skeleton."); return } this.play(); this.timelineSlider.change = function (v) { r.pause(); var w = r.animationState.getCurrent(0).animation.duration; var x = w * v; r.animationState.update(x - r.playTime); r.animationState.apply(r.skeleton); r.skeleton.updateWorldTransform(); r.playTime = x } } this.setupInput(); if (n.skins.length == 1 || (this.config.skins && this.config.skins.length == 1)) { this.skinButton.classList.add("spine-player-hidden") } if (n.animations.length == 1 || (this.config.animations && this.config.animations.length == 1)) { this.animationButton.classList.add("spine-player-hidden") } this.config.success(this); this.loaded = true }; l.prototype.setupInput = function () { var r = this; var A = this.config.controlBones; var m = this.selectedBones = new Array(this.config.controlBones.length); var p = this.canvas; var x = new k.webgl.Input(p); var s = null; var w = new k.webgl.Vector3(); var z = new k.webgl.Vector3(); var o = new k.Vector2(); var q = this.skeleton; var t = this.sceneRenderer; x.addListener({ down: function (B, E) { for (var C = 0; C < A.length; C++) { var D = q.findBone(A[C]); if (!D) { continue } t.camera.screenToWorld(w.set(B, E, 0), p.width, p.height); if (z.set(q.x + D.worldX, q.y + D.worldY, 0).distance(w) < 30) { s = D } } }, up: function (B, C) { if (s) { s = null } else { if (!r.config.showControls) { return } if (r.paused) { r.play() } else { r.pause() } } }, dragged: function (B, C) { if (s != null) { t.camera.screenToWorld(w.set(B, C, 0), p.width, p.height); if (s.parent !== null) { s.parent.worldToLocal(o.set(w.x - q.x, w.y - q.y)); s.x = o.x; s.y = o.y } else { s.x = w.x - q.x; s.y = w.y - q.y } } }, moved: function (B, E) { for (var C = 0; C < A.length; C++) { var D = q.findBone(A[C]); if (!D) { continue } t.camera.screenToWorld(w.set(B, E, 0), p.width, p.height); if (z.set(q.x + D.worldX, q.y + D.worldY, 0).distance(w) < 30) { m[C] = D } else { m[C] = null } } } }); var y = true; var u = false; document.addEventListener("mousemove", function (B) { if (B instanceof MouseEvent) { n(B.clientX, B.clientY) } }); document.addEventListener("touchmove", function (B) { if (B instanceof TouchEvent) { var C = B.changedTouches; if (C.length > 0) { var D = C[0]; n(D.clientX, D.clientY) } } }); var n = function (F, D) { if (!r.config.showControls) { return } var C = c(r.dom, "spine-player-popup"); y = v(F, D, r.playerControls.getBoundingClientRect()); u = v(F, D, r.canvas.getBoundingClientRect()); clearTimeout(r.cancelId); var E = C.length == 0 && !y && !u && !r.paused; if (E) { r.playerControls.classList.add("spine-player-controls-hidden") } else { r.playerControls.classList.remove("spine-player-controls-hidden") } if (!y && C.length == 0 && !r.paused) { var B = function () { if (!r.paused) { r.playerControls.classList.add("spine-player-controls-hidden") } }; r.cancelId = setTimeout(B, 1000) } }; var v = function (D, C, E) { var B = D - E.left; var F = C - E.top; return B >= 0 && B <= E.width && F >= 0 && F <= E.height } }; l.prototype.play = function () { var n = this; this.paused = false; var m = function () { if (!n.paused) { n.playerControls.classList.add("spine-player-controls-hidden") } }; this.cancelId = setTimeout(m, 1000); this.playButton.classList.remove("spine-player-button-icon-play"); this.playButton.classList.add("spine-player-button-icon-pause"); if (this.config.animation) { if (!this.animationState.getCurrent(0)) { this.setAnimation(this.config.animation) } } }; l.prototype.pause = function () { this.paused = true; this.playerControls.classList.remove("spine-player-controls-hidden"); clearTimeout(this.cancelId); this.playButton.classList.remove("spine-player-button-icon-pause"); this.playButton.classList.add("spine-player-button-icon-play") }; l.prototype.setAnimation = function (o) { this.previousViewport = this.currentViewport; var q = this.calculateAnimationViewport(o); var m = { x: q.x, y: q.y, width: q.width, height: q.height, padLeft: "10%", padRight: "10%", padTop: "10%", padBottom: "10%" }; var n = this.config.viewport; if (typeof n.x !== "undefined" && typeof n.y !== "undefined" && typeof n.width !== "undefined" && typeof n.height !== "undefined") { m.x = n.x; m.y = n.y; m.width = n.width; m.height = n.height } if (typeof n.padLeft !== "undefined") { m.padLeft = n.padLeft } if (typeof n.padRight !== "undefined") { m.padRight = n.padRight } if (typeof n.padTop !== "undefined") { m.padTop = n.padTop } if (typeof n.padBottom !== "undefined") { m.padBottom = n.padBottom } var p = this.config.viewport.animations[o]; if (p) { if (typeof p.x !== "undefined" && typeof p.y !== "undefined" && typeof p.width !== "undefined" && typeof p.height !== "undefined") { m.x = p.x; m.y = p.y; m.width = p.width; m.height = p.height } if (typeof p.padLeft !== "undefined") { m.padLeft = p.padLeft } if (typeof p.padRight !== "undefined") { m.padRight = p.padRight } if (typeof p.padTop !== "undefined") { m.padTop = p.padTop } if (typeof p.padBottom !== "undefined") { m.padBottom = p.padBottom } } m.padLeft = this.percentageToWorldUnit(m.width, m.padLeft); m.padRight = this.percentageToWorldUnit(m.width, m.padRight); m.padBottom = this.percentageToWorldUnit(m.height, m.padBottom); m.padTop = this.percentageToWorldUnit(m.height, m.padTop); this.currentViewport = m; this.viewportTransitionStart = performance.now(); this.animationState.clearTracks(); this.skeleton.setToSetupPose(); this.animationState.setAnimation(0, o, true) }; l.prototype.percentageToWorldUnit = function (m, n) { if (typeof n === "string") { return m * parseFloat(n.substr(0, n.length - 1)) / 100 } else { return n } }; l.prototype.calculateAnimationViewport = function (u) { var r = this.skeleton.data.findAnimation(u); this.animationState.clearTracks(); this.skeleton.setToSetupPose(); this.animationState.setAnimationWith(0, r, true); var v = 100; var o = r.duration > 0 ? r.duration / v : 0; var q = 100000000; var n = -100000000; var p = 100000000; var m = -100000000; var s = new k.Vector2(); var w = new k.Vector2(); for (var t = 0; t < v; t++) { this.animationState.update(o); this.animationState.apply(this.skeleton); this.skeleton.updateWorldTransform(); this.skeleton.getBounds(s, w); q = Math.min(s.x, q); n = Math.max(s.x + w.x, n); p = Math.min(s.y, p); m = Math.max(s.y + w.y, m) } s.x = q; s.y = p; w.x = n - q; w.y = m - p; return { x: s.x, y: s.y, width: w.x, height: w.y } }; l.prototype.stopRendering = function () { this.stopRequestAnimationFrame = true }; l.HOVER_COLOR_INNER = new k.Color(0.478, 0, 0, 0.25); l.HOVER_COLOR_OUTER = new k.Color(1, 1, 1, 1); l.NON_HOVER_COLOR_INNER = new k.Color(0.478, 0, 0, 0.5); l.NON_HOVER_COLOR_OUTER = new k.Color(1, 0, 0, 0.8); return l }()); k.SpinePlayer = j; function g(n, m) { if (n === m) { return true } var l = function (q, p) { for (var o = 0; o < q.children.length; o++) { var r = q.children[o]; if (r === p) { return true } if (l(r, p)) { return true } } return false }; return l(n, m) } function b(n, o) { var m = new Array(); var l = function (r, t, q) { for (var p = 0; p < r.children.length; p++) { var s = r.children[p]; if (s.id === t) { q.push(s) } l(s, t, q) } }; l(n, o, m); return m } function c(o, l) { var n = new Array(); var m = function (s, q, r) { for (var p = 0; p < s.children.length; p++) { var t = s.children[p]; if (t.classList.contains(q)) { r.push(t) } m(t, q, r) } }; m(o, l, n); return n } function d(l) { var m = document.createElement("div"); m.innerHTML = l; return m.children[0] } function h(n, l) { for (var m = 0; m < n.length; m++) { n[m].classList.remove(l) } } function e(l) { if (!l) { return "" } return l.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&#34;").replace(/'/g, "&#39;") } })(spine || (spine = {})); var spine; (function (b) { var a = (function () { function c(d) { this.prefix = "<html>\n<head>\n<style>\nbody {\n\tmargin: 0px;\n}\n</style>\n</head>\n<body>".trim(); this.postfix = "</body>"; this.timerId = 0; this.render(d) } c.prototype.render = function (d) { var g = this; var f = '\n\t\t\t\t<div class="spine-player-editor-container">\n\t\t\t\t\t<div class="spine-player-editor-code"></div>\n\t\t\t\t\t<iframe class="spine-player-editor-player"></iframe>\n\t\t\t\t</div>\n\t\t\t'; d.innerHTML = f; var e = d.getElementsByClassName("spine-player-editor-code")[0]; this.player = d.getElementsByClassName("spine-player-editor-player")[0]; requestAnimationFrame(function () { g.code = CodeMirror(e, { lineNumbers: true, tabSize: 3, indentUnit: 3, indentWithTabs: true, scrollBarStyle: "native", mode: "htmlmixed", theme: "monokai" }); g.code.on("change", function () { g.startPlayer() }); g.setCode(c.DEFAULT_CODE) }) }; c.prototype.setPreAndPostfix = function (d, e) { this.prefix = d; this.postfix = e; this.startPlayer() }; c.prototype.setCode = function (d) { this.code.setValue(d); this.startPlayer() }; c.prototype.startPlayer = function () { var d = this; clearTimeout(this.timerId); this.timerId = setTimeout(function () { var e = d.code.getDoc().getValue(); e = d.prefix + e + d.postfix; e = window.btoa(e); d.player.src = ""; d.player.src = "data:text/html;base64," + e }, 500) }; c.DEFAULT_CODE = '\n<script src="https://esotericsoftware.com/files/spine-player/3.7/spine-player.js"><\/script>\n<link rel="stylesheet" href="https://esotericsoftware.com/files/spine-player/3.7/spine-player.css">\n\n<div id="player-container" style="width: 100%; height: 100vh;"></div>\n\n<script>\nnew spine.SpinePlayer("player-container", {\n\tjsonUrl: "https://esotericsoftware.com/files/examples/spineboy/export/spineboy-pro.json",\n\tatlasUrl: "https://esotericsoftware.com/files/examples/spineboy/export/spineboy-pma.atlas"\n});\n<\/script>\n\t\t'.trim(); return c }()); b.SpinePlayerEditor = a })(spine || (spine = {}));